<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>prometheus - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package prometheus
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/prometheus/client_golang/prometheus"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package prometheus is the core instrumentation package. It provides metrics
primitives to instrument code for monitoring. It also offers a registry for
metrics. Sub-packages allow to expose the registered metrics via HTTP
(package promhttp) or push them to a Pushgateway (package push). There is
also a sub-package promauto, which provides metrics constructors with
automatic registration.
<p>All exported functions and methods are safe to be used concurrently unless
specified otherwise.
<h3 id="hdr-A_Basic_Example">A Basic Example</h3>
<p>As a starting point, a very basic usage example:
<pre>package main

import (
	&quot;log&quot;
	&quot;net/http&quot;

	&quot;github.com/prometheus/client_golang/prometheus&quot;
	&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;
)

type metrics struct {
	cpuTemp  prometheus.Gauge
	hdFailures *prometheus.CounterVec
}

func NewMetrics(reg prometheus.Registerer) *metrics {
	m := &amp;metrics{
		cpuTemp: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: &quot;cpu_temperature_celsius&quot;,
			Help: &quot;Current temperature of the CPU.&quot;,
		}),
		hdFailures: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: &quot;hd_errors_total&quot;,
				Help: &quot;Number of hard-disk errors.&quot;,
			},
			[]string{&quot;device&quot;},
		),
	}
	reg.MustRegister(m.cpuTemp)
	reg.MustRegister(m.hdFailures)
	return m
}

func main() {
	// Create a non-global registry.
	reg := prometheus.NewRegistry()

	// Create new metrics and register them using the custom registry.
	m := NewMetrics(reg)
	// Set values for the new created metrics.
	m.cpuTemp.Set(65.3)
	m.hdFailures.With(prometheus.Labels{&quot;device&quot;:&quot;/dev/sda&quot;}).Inc()

	// Expose metrics and custom registry via an HTTP server
	// using the HandleFor function. &quot;/metrics&quot; is the usual endpoint for that.
	http.Handle(&quot;/metrics&quot;, promhttp.HandlerFor(reg, promhttp.HandlerOpts{Registry: reg}))
	log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</pre>
<p>This is a complete program that exports two metrics, a Gauge and a Counter,
the latter with a label attached to turn it into a (one-dimensional) vector.
It register the metrics using a custom registry and exposes them via an HTTP server
on the /metrics endpoint.
<h3 id="hdr-Metrics">Metrics</h3>
<p>The number of exported identifiers in this package might appear a bit
overwhelming. However, in addition to the basic plumbing shown in the example
above, you only need to understand the different metric types and their
vector versions for basic usage. Furthermore, if you are not concerned with
fine-grained control of when and how to register metrics with the registry,
have a look at the promauto package, which will effectively allow you to
ignore registration altogether in simple cases.
<p>Above, you have already touched the Counter and the Gauge. There are two more
advanced metric types: the Summary and Histogram. A more thorough description
of those four metric types can be found in the Prometheus docs:
<a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a>
<p>In addition to the fundamental metric types Gauge, Counter, Summary, and
Histogram, a very important part of the Prometheus data model is the
partitioning of samples along dimensions called labels, which results in
metric vectors. The fundamental types are GaugeVec, CounterVec, SummaryVec,
and HistogramVec.
<p>While only the fundamental metric types implement the Metric interface, both
the metrics and their vector versions implement the Collector interface. A
Collector manages the collection of a number of Metrics, but for convenience,
a Metric can also “collect itself”. Note that Gauge, Counter, Summary, and
Histogram are interfaces themselves while GaugeVec, CounterVec, SummaryVec,
and HistogramVec are not.
<p>To create instances of Metrics and their vector versions, you need a suitable
…Opts struct, i.e. GaugeOpts, CounterOpts, SummaryOpts, or HistogramOpts.
<h3 id="hdr-Custom_Collectors_and_constant_Metrics">Custom Collectors and constant Metrics</h3>
<p>While you could create your own implementations of Metric, most likely you
will only ever implement the Collector interface on your own. At a first
glance, a custom Collector seems handy to bundle Metrics for common
registration (with the prime example of the different metric vectors above,
which bundle all the metrics of the same name but with different labels).
<p>There is a more involved use case, too: If you already have metrics
available, created outside of the Prometheus context, you don&apos;t need the
interface of the various Metric types. You essentially want to mirror the
existing numbers into Prometheus Metrics during collection. An own
implementation of the Collector interface is perfect for that. You can create
Metric instances “on the fly” using NewConstMetric, NewConstHistogram, and
NewConstSummary (and their respective Must… versions). NewConstMetric is used
for all metric types with just a float64 as their value: Counter, Gauge, and
a special “type” called Untyped. Use the latter if you are not sure if the
mirrored metric is a Counter or a Gauge. Creation of the Metric instance
happens in the Collect method. The Describe method has to return separate
Desc instances, representative of the “throw-away” metrics to be created
later.  NewDesc comes in handy to create those Desc instances. Alternatively,
you could return no Desc at all, which will mark the Collector “unchecked”.
No checks are performed at registration time, but metric consistency will
still be ensured at scrape time, i.e. any inconsistencies will lead to scrape
errors. Thus, with unchecked Collectors, the responsibility to not collect
metrics that lead to inconsistencies in the total scrape result lies with the
implementer of the Collector. While this is not a desirable state, it is
sometimes necessary. The typical use case is a situation where the exact
metrics to be returned by a Collector cannot be predicted at registration
time, but the implementer has sufficient knowledge of the whole system to
guarantee metric consistency.
<p>The Collector example illustrates the use case. You can also look at the
source code of the processCollector (mirroring process metrics), the
goCollector (mirroring Go metrics), or the expvarCollector (mirroring expvar
metrics) as examples that are used in this package itself.
<p>If you just need to call a function to get a single float value to collect as
a metric, GaugeFunc, CounterFunc, or UntypedFunc might be interesting
shortcuts.
<h3 id="hdr-Advanced_Uses_of_the_Registry">Advanced Uses of the Registry</h3>
<p>While MustRegister is the by far most common way of registering a Collector,
sometimes you might want to handle the errors the registration might cause.
As suggested by the name, MustRegister panics if an error occurs. With the
Register function, the error is returned and can be handled.
<p>An error is returned if the registered Collector is incompatible or
inconsistent with already registered metrics. The registry aims for
consistency of the collected metrics according to the Prometheus data model.
Inconsistencies are ideally detected at registration time, not at collect
time. The former will usually be detected at start-up time of a program,
while the latter will only happen at scrape time, possibly not even on the
first scrape if the inconsistency only becomes relevant later. That is the
main reason why a Collector and a Metric have to describe themselves to the
registry.
<p>So far, everything we did operated on the so-called default registry, as it
can be found in the global DefaultRegisterer variable. With NewRegistry, you
can create a custom registry, or you can even implement the Registerer or
Gatherer interfaces yourself. The methods Register and Unregister work in the
same way on a custom registry as the global functions Register and Unregister
on the default registry.
<p>There are a number of uses for custom registries: You can use registries with
special properties, see NewPedanticRegistry. You can avoid global state, as
it is imposed by the DefaultRegisterer. You can use multiple registries at
the same time to expose different metrics in different ways.  You can use
separate registries for testing purposes.
<p>Also note that the DefaultRegisterer comes registered with a Collector for Go
runtime metrics (via NewGoCollector) and a Collector for process metrics (via
NewProcessCollector). With a custom registry, you are in control and decide
yourself about the Collectors to register.
<h3 id="hdr-HTTP_Exposition">HTTP Exposition</h3>
<p>The Registry implements the Gatherer interface. The caller of the Gather
method can then expose the gathered metrics in some way. Usually, the metrics
are served via HTTP on the /metrics endpoint. That&apos;s happening in the example
above. The tools to expose metrics via HTTP are in the promhttp sub-package.
<h3 id="hdr-Pushing_to_the_Pushgateway">Pushing to the Pushgateway</h3>
<p>Function for pushing to the Pushgateway can be found in the push sub-package.
<h3 id="hdr-Graphite_Bridge">Graphite Bridge</h3>
<p>Functions and examples to push metrics from a Gatherer to Graphite can be
found in the graphite sub-package.
<h3 id="hdr-Other_Means_of_Exposition">Other Means of Exposition</h3>
<p>More ways of exposing metrics can easily be added by following the approaches
of the existing implementations.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#BuildFQName">func BuildFQName(namespace, subsystem, name string) string</a></dd>
			
				
				<dd><a href="index.html#DescribeByCollect">func DescribeByCollect(c Collector, descs chan&lt;- *Desc)</a></dd>
			
				
				<dd><a href="index.html#ExponentialBuckets">func ExponentialBuckets(start, factor float64, count int) []float64</a></dd>
			
				
				<dd><a href="index.html#ExponentialBucketsRange">func ExponentialBucketsRange(min, max float64, count int) []float64</a></dd>
			
				
				<dd><a href="index.html#LinearBuckets">func LinearBuckets(start, width float64, count int) []float64</a></dd>
			
				
				<dd><a href="index.html#MakeLabelPairs">func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair</a></dd>
			
				
				<dd><a href="index.html#MustRegister">func MustRegister(cs ...Collector)</a></dd>
			
				
				<dd><a href="index.html#NewPidFileFn">func NewPidFileFn(pidFilePath string) func() (int, error)</a></dd>
			
				
				<dd><a href="index.html#Register">func Register(c Collector) error</a></dd>
			
				
				<dd><a href="index.html#Unregister">func Unregister(c Collector) bool</a></dd>
			
				
				<dd><a href="index.html#WriteToTextfile">func WriteToTextfile(filename string, g Gatherer) error</a></dd>
			
			
				
				<dd><a href="index.html#AlreadyRegisteredError">type AlreadyRegisteredError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#AlreadyRegisteredError.Error">func (err AlreadyRegisteredError) Error() string</a></dd>
				
			
				
				<dd><a href="index.html#Collector">type Collector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewBuildInfoCollector">func NewBuildInfoCollector() Collector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewExpvarCollector">func NewExpvarCollector(exports map[string]*Desc) Collector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewGoCollector">func NewGoCollector(opts ...func(o *internal.GoCollectorOptions)) Collector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewProcessCollector">func NewProcessCollector(opts ProcessCollectorOpts) Collector</a></dd>
				
				
			
				
				<dd><a href="index.html#ConstrainableLabels">type ConstrainableLabels</a></dd>
				
				
			
				
				<dd><a href="index.html#ConstrainedLabel">type ConstrainedLabel</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConstrainedLabel.Constrain">func (cl ConstrainedLabel) Constrain(v string) string</a></dd>
				
			
				
				<dd><a href="index.html#ConstrainedLabels">type ConstrainedLabels</a></dd>
				
				
			
				
				<dd><a href="index.html#Counter">type Counter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewCounter">func NewCounter(opts CounterOpts) Counter</a></dd>
				
				
			
				
				<dd><a href="index.html#CounterFunc">type CounterFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewCounterFunc">func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc</a></dd>
				
				
			
				
				<dd><a href="index.html#CounterOpts">type CounterOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#CounterVec">type CounterVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewCounterVec">func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.CurryWith">func (v *CounterVec) CurryWith(labels Labels) (*CounterVec, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.GetMetricWith">func (v *CounterVec) GetMetricWith(labels Labels) (Counter, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.GetMetricWithLabelValues">func (v *CounterVec) GetMetricWithLabelValues(lvs ...string) (Counter, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.MustCurryWith">func (v *CounterVec) MustCurryWith(labels Labels) *CounterVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.With">func (v *CounterVec) With(labels Labels) Counter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CounterVec.WithLabelValues">func (v *CounterVec) WithLabelValues(lvs ...string) Counter</a></dd>
				
			
				
				<dd><a href="index.html#CounterVecOpts">type CounterVecOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#Desc">type Desc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewDesc">func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewInvalidDesc">func NewInvalidDesc(err error) *Desc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Desc.String">func (d *Desc) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Exemplar">type Exemplar</a></dd>
				
				
			
				
				<dd><a href="index.html#ExemplarAdder">type ExemplarAdder</a></dd>
				
				
			
				
				<dd><a href="index.html#ExemplarObserver">type ExemplarObserver</a></dd>
				
				
			
				
				<dd><a href="index.html#Gatherer">type Gatherer</a></dd>
				
				
			
				
				<dd><a href="index.html#GathererFunc">type GathererFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GathererFunc.Gather">func (gf GathererFunc) Gather() ([]*dto.MetricFamily, error)</a></dd>
				
			
				
				<dd><a href="index.html#Gatherers">type Gatherers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Gatherers.Gather">func (gs Gatherers) Gather() ([]*dto.MetricFamily, error)</a></dd>
				
			
				
				<dd><a href="index.html#Gauge">type Gauge</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewGauge">func NewGauge(opts GaugeOpts) Gauge</a></dd>
				
				
			
				
				<dd><a href="index.html#GaugeFunc">type GaugeFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewGaugeFunc">func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc</a></dd>
				
				
			
				
				<dd><a href="index.html#GaugeOpts">type GaugeOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#GaugeVec">type GaugeVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewGaugeVec">func NewGaugeVec(opts GaugeOpts, labelNames []string) *GaugeVec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.CurryWith">func (v *GaugeVec) CurryWith(labels Labels) (*GaugeVec, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.GetMetricWith">func (v *GaugeVec) GetMetricWith(labels Labels) (Gauge, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.GetMetricWithLabelValues">func (v *GaugeVec) GetMetricWithLabelValues(lvs ...string) (Gauge, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.MustCurryWith">func (v *GaugeVec) MustCurryWith(labels Labels) *GaugeVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.With">func (v *GaugeVec) With(labels Labels) Gauge</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GaugeVec.WithLabelValues">func (v *GaugeVec) WithLabelValues(lvs ...string) Gauge</a></dd>
				
			
				
				<dd><a href="index.html#GaugeVecOpts">type GaugeVecOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#Histogram">type Histogram</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewHistogram">func NewHistogram(opts HistogramOpts) Histogram</a></dd>
				
				
			
				
				<dd><a href="index.html#HistogramOpts">type HistogramOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#HistogramVec">type HistogramVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewHistogramVec">func NewHistogramVec(opts HistogramOpts, labelNames []string) *HistogramVec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.CurryWith">func (v *HistogramVec) CurryWith(labels Labels) (ObserverVec, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.GetMetricWith">func (v *HistogramVec) GetMetricWith(labels Labels) (Observer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.GetMetricWithLabelValues">func (v *HistogramVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.MustCurryWith">func (v *HistogramVec) MustCurryWith(labels Labels) ObserverVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.With">func (v *HistogramVec) With(labels Labels) Observer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HistogramVec.WithLabelValues">func (v *HistogramVec) WithLabelValues(lvs ...string) Observer</a></dd>
				
			
				
				<dd><a href="index.html#HistogramVecOpts">type HistogramVecOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#Labels">type Labels</a></dd>
				
				
			
				
				<dd><a href="index.html#Metric">type Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustNewConstHistogram">func MustNewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustNewConstMetric">func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustNewConstSummary">func MustNewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustNewMetricWithExemplars">func MustNewMetricWithExemplars(m Metric, exemplars ...Exemplar) Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConstHistogram">func NewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConstMetric">func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConstSummary">func NewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewInvalidMetric">func NewInvalidMetric(desc *Desc, err error) Metric</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewMetricWithExemplars">func NewMetricWithExemplars(m Metric, exemplars ...Exemplar) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewMetricWithTimestamp">func NewMetricWithTimestamp(t time.Time, m Metric) Metric</a></dd>
				
				
			
				
				<dd><a href="index.html#MetricVec">type MetricVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewMetricVec">func NewMetricVec(desc *Desc, newMetric func(lvs ...string) Metric) *MetricVec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.Collect">func (m *MetricVec) Collect(ch chan&lt;- Metric)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.CurryWith">func (m *MetricVec) CurryWith(labels Labels) (*MetricVec, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.Delete">func (m *MetricVec) Delete(labels Labels) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.DeleteLabelValues">func (m *MetricVec) DeleteLabelValues(lvs ...string) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.DeletePartialMatch">func (m *MetricVec) DeletePartialMatch(labels Labels) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.Describe">func (m *MetricVec) Describe(ch chan&lt;- *Desc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.GetMetricWith">func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.GetMetricWithLabelValues">func (m *MetricVec) GetMetricWithLabelValues(lvs ...string) (Metric, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MetricVec.Reset">func (m *MetricVec) Reset()</a></dd>
				
			
				
				<dd><a href="index.html#MultiError">type MultiError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiError.Append">func (errs *MultiError) Append(err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiError.Error">func (errs MultiError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiError.MaybeUnwrap">func (errs MultiError) MaybeUnwrap() error</a></dd>
				
			
				
				<dd><a href="index.html#MultiTRegistry">type MultiTRegistry</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewMultiTRegistry">func NewMultiTRegistry(tGatherers ...TransactionalGatherer) *MultiTRegistry</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiTRegistry.Gather">func (r *MultiTRegistry) Gather() (mfs []*dto.MetricFamily, done func(), err error)</a></dd>
				
			
				
				<dd><a href="index.html#Observer">type Observer</a></dd>
				
				
			
				
				<dd><a href="index.html#ObserverFunc">type ObserverFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ObserverFunc.Observe">func (f ObserverFunc) Observe(value float64)</a></dd>
				
			
				
				<dd><a href="index.html#ObserverVec">type ObserverVec</a></dd>
				
				
			
				
				<dd><a href="index.html#Opts">type Opts</a></dd>
				
				
			
				
				<dd><a href="index.html#ProcessCollectorOpts">type ProcessCollectorOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#Registerer">type Registerer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WrapRegistererWith">func WrapRegistererWith(labels Labels, reg Registerer) Registerer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WrapRegistererWithPrefix">func WrapRegistererWithPrefix(prefix string, reg Registerer) Registerer</a></dd>
				
				
			
				
				<dd><a href="index.html#Registry">type Registry</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPedanticRegistry">func NewPedanticRegistry() *Registry</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewRegistry">func NewRegistry() *Registry</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.Collect">func (r *Registry) Collect(ch chan&lt;- Metric)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.Describe">func (r *Registry) Describe(ch chan&lt;- *Desc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.Gather">func (r *Registry) Gather() ([]*dto.MetricFamily, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.MustRegister">func (r *Registry) MustRegister(cs ...Collector)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.Register">func (r *Registry) Register(c Collector) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Registry.Unregister">func (r *Registry) Unregister(c Collector) bool</a></dd>
				
			
				
				<dd><a href="index.html#Summary">type Summary</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewSummary">func NewSummary(opts SummaryOpts) Summary</a></dd>
				
				
			
				
				<dd><a href="index.html#SummaryOpts">type SummaryOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#SummaryVec">type SummaryVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewSummaryVec">func NewSummaryVec(opts SummaryOpts, labelNames []string) *SummaryVec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.CurryWith">func (v *SummaryVec) CurryWith(labels Labels) (ObserverVec, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.GetMetricWith">func (v *SummaryVec) GetMetricWith(labels Labels) (Observer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.GetMetricWithLabelValues">func (v *SummaryVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.MustCurryWith">func (v *SummaryVec) MustCurryWith(labels Labels) ObserverVec</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.With">func (v *SummaryVec) With(labels Labels) Observer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SummaryVec.WithLabelValues">func (v *SummaryVec) WithLabelValues(lvs ...string) Observer</a></dd>
				
			
				
				<dd><a href="index.html#SummaryVecOpts">type SummaryVecOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#Timer">type Timer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewTimer">func NewTimer(o Observer) *Timer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Timer.ObserveDuration">func (t *Timer) ObserveDuration() time.Duration</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Timer.ObserveDurationWithExemplar">func (t *Timer) ObserveDurationWithExemplar(exemplar Labels) time.Duration</a></dd>
				
			
				
				<dd><a href="index.html#TransactionalGatherer">type TransactionalGatherer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ToTransactionalGatherer">func ToTransactionalGatherer(g Gatherer) TransactionalGatherer</a></dd>
				
				
			
				
				<dd><a href="index.html#UnconstrainedLabels">type UnconstrainedLabels</a></dd>
				
				
			
				
				<dd><a href="index.html#UntypedFunc">type UntypedFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewUntypedFunc">func NewUntypedFunc(opts UntypedOpts, function func() float64) UntypedFunc</a></dd>
				
				
			
				
				<dd><a href="index.html#UntypedOpts">type UntypedOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#ValueType">type ValueType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueType.ToDTO">func (v ValueType) ToDTO() *dto.MetricType</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_AlreadyRegisteredError">AlreadyRegisteredError</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Collector">Collector</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_CounterVec">CounterVec</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Gatherers">Gatherers</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Gauge">Gauge</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_GaugeFunc_constLabels">GaugeFunc (ConstLabels)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_GaugeFunc_simple">GaugeFunc (Simple)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_GaugeVec">GaugeVec</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Histogram">Histogram</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_MetricVec">MetricVec</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_NewConstHistogram">NewConstHistogram</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_NewConstSummary">NewConstSummary</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_NewExpvarCollector">NewExpvarCollector</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_NewMetricWithTimestamp">NewMetricWithTimestamp</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Register">Register</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Registry_grouping">Registry (Grouping)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Summary">Summary</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SummaryVec">SummaryVec</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Timer">Timer</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Timer_complex">Timer (Complex)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Timer_gauge">Timer (Gauge)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/build_info_collector.go">build_info_collector.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/collector.go">collector.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go">counter.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/desc.go">desc.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/expvar_collector.go">expvar_collector.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/fnv.go">fnv.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go">gauge.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/get_pid.go">get_pid.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/go_collector.go">go_collector.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/go_collector_latest.go">go_collector_latest.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go">histogram.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go">labels.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go">metric.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/num_threads.go">num_threads.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go">observer.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/process_collector.go">process_collector.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/process_collector_other.go">process_collector_other.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go">registry.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go">summary.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/timer.go">timer.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/untyped.go">untyped.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go">value.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go">vec.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vnext.go">vnext.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/wrap.go">wrap.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Default values for SummaryOpts.

				<pre>const (
    <span class="comment">// DefMaxAge is the default duration for which observations stay</span>
    <span class="comment">// relevant.</span>
    <span id="DefMaxAge">DefMaxAge</span> <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Duration">Duration</a> = 10 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Minute">Minute</a>
    <span class="comment">// DefAgeBuckets is the default number of buckets used to calculate the</span>
    <span class="comment">// age of observations.</span>
    <span id="DefAgeBuckets">DefAgeBuckets</span> = 5
    <span class="comment">// DefBufCap is the standard buffer size for collecting Summary observations.</span>
    <span id="DefBufCap">DefBufCap</span> = 500
)</pre>
			
				<p>DefNativeHistogramZeroThreshold is the default value for
NativeHistogramZeroThreshold in the HistogramOpts.
<p>The value is 2^-128 (or 0.5*2^-127 in the actual IEEE 754 representation),
which is a bucket boundary at all possible resolutions.

				<pre>const <span id="DefNativeHistogramZeroThreshold">DefNativeHistogramZeroThreshold</span> = 2.938735877055719e-39</pre>
			
				<p>ExemplarMaxRunes is the max total number of runes allowed in exemplar labels.

				<pre>const <span id="ExemplarMaxRunes">ExemplarMaxRunes</span> = 128</pre>
			
				<p>NativeHistogramZeroThresholdZero can be used as NativeHistogramZeroThreshold
in the HistogramOpts to create a zero bucket of width zero, i.e. a zero
bucket that only receives observations of precisely zero.

				<pre>const <span id="NativeHistogramZeroThresholdZero">NativeHistogramZeroThresholdZero</span> = -1</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>DefaultRegisterer and DefaultGatherer are the implementations of the
Registerer and Gatherer interface a number of convenience functions in this
package act on. Initially, both variables point to the same Registry, which
has a process collector (currently on Linux only, see NewProcessCollector)
and a Go collector (see NewGoCollector, in particular the note about
stop-the-world implication with Go versions older than 1.9) already
registered. This approach to keep default instances as global state mirrors
the approach of other packages in the Go standard library. Note that there
are caveats. Change the variables with caution and only if you understand the
consequences. Users who want to avoid global state altogether should not use
the convenience functions and act on custom instances instead.

				<pre>var (
    <span id="DefaultRegisterer">DefaultRegisterer</span> <a href="index.html#Registerer">Registerer</a> = defaultRegistry
    <span id="DefaultGatherer">DefaultGatherer</span>   <a href="index.html#Gatherer">Gatherer</a>   = defaultRegistry
)</pre>
			
				
				<pre>var (
    <span id="CounterMetricTypePtr">CounterMetricTypePtr</span> = func() *<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType">MetricType</a> { d := <a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType_COUNTER">MetricType_COUNTER</a>; return &amp;d }()
    <span id="GaugeMetricTypePtr">GaugeMetricTypePtr</span>   = func() *<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType">MetricType</a> { d := <a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType_GAUGE">MetricType_GAUGE</a>; return &amp;d }()
    <span id="UntypedMetricTypePtr">UntypedMetricTypePtr</span> = func() *<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType">MetricType</a> { d := <a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType_UNTYPED">MetricType_UNTYPED</a>; return &amp;d }()
)</pre>
			
				<p>DefBuckets are the default Histogram buckets. The default buckets are
tailored to broadly measure the response time (in seconds) of a network
service. Most likely, however, you will be required to define buckets
customized to your use case.

				<pre>var <span id="DefBuckets">DefBuckets</span> = []<a href="../../../../builtin/index.html#float64">float64</a>{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10}</pre>
			
				<p>V2 is a struct that can be referenced to access experimental API that might
be present in v2 of client golang someday. It offers extended functionality
of v1 with slightly changed API. It is acceptable to use some pieces from v1
and e.g `prometheus.NewGauge` and some from v2 e.g. `prometheus.V2.NewDesc`
in the same codebase.

				<pre>var <span id="V2">V2</span> = v2{}</pre>
			
		
		
			
			
			<h2 id="BuildFQName">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=4437:4495#L94">BuildFQName</a>
				<a class="permalink" href="index.html#BuildFQName">&#xb6;</a>
				
				
			</h2>
			<pre>func BuildFQName(namespace, subsystem, name <a href="../../../../builtin/index.html#string">string</a>) <a href="../../../../builtin/index.html#string">string</a></pre>
			<p>BuildFQName joins the given three name components by &quot;_&quot;. Empty name
components are ignored. If the name parameter itself is empty, an empty
string is returned, no matter what. Metric implementations included in this
library use this function internally to generate the fully-qualified metric
name from the name component in their Opts. Users of the library will only
need this function if they implement their own Metric or instantiate a Desc
(with NewDesc) directly.

			
			

		
			
			
			<h2 id="DescribeByCollect">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/collector.go?s=4396:4451#L77">DescribeByCollect</a>
				<a class="permalink" href="index.html#DescribeByCollect">&#xb6;</a>
				
				
			</h2>
			<pre>func DescribeByCollect(c <a href="index.html#Collector">Collector</a>, descs chan&lt;- *<a href="index.html#Desc">Desc</a>)</pre>
			<p>DescribeByCollect is a helper to implement the Describe method of a custom
Collector. It collects the metrics from the provided Collector and sends
their descriptors to the provided channel.
<p>If a Collector collects the same metrics throughout its lifetime, its
Describe method can simply be implemented as:
<pre>func (c customCollector) Describe(ch chan&lt;- *Desc) {
	DescribeByCollect(c, ch)
}
</pre>
<p>However, this will not work if the metrics collected change dynamically over
the lifetime of the Collector in a way that their combined set of descriptors
changes as well. The shortcut implementation will then violate the contract
of the Describe method. If a Collector sometimes collects no metrics at all
(for example vectors like CounterVec, GaugeVec, etc., which only collect
metrics after a metric with a fully specified label set has been accessed),
it might even get registered as an unchecked Collector (cf. the Register
method of the Registerer interface). Hence, only use this shortcut
implementation of Describe if you are certain to fulfill the contract.
<p>The Collector example demonstrates a use of DescribeByCollect.

			
			

		
			
			
			<h2 id="ExponentialBuckets">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=16794:16861#L298">ExponentialBuckets</a>
				<a class="permalink" href="index.html#ExponentialBuckets">&#xb6;</a>
				
				
			</h2>
			<pre>func ExponentialBuckets(start, factor <a href="../../../../builtin/index.html#float64">float64</a>, count <a href="../../../../builtin/index.html#int">int</a>) []<a href="../../../../builtin/index.html#float64">float64</a></pre>
			<p>ExponentialBuckets creates &apos;count&apos; regular buckets, where the lowest bucket
has an upper bound of &apos;start&apos; and each following bucket&apos;s upper bound is
&apos;factor&apos; times the previous bucket&apos;s upper bound. The final +Inf bucket is
not counted and not included in the returned slice. The returned slice is
meant to be used for the Buckets field of HistogramOpts.
<p>The function panics if &apos;count&apos; is 0 or negative, if &apos;start&apos; is 0 or negative,
or if &apos;factor&apos; is less than or equal 1.

			
			

		
			
			
			<h2 id="ExponentialBucketsRange">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=17583:17650#L322">ExponentialBucketsRange</a>
				<a class="permalink" href="index.html#ExponentialBucketsRange">&#xb6;</a>
				
				
			</h2>
			<pre>func ExponentialBucketsRange(min, max <a href="../../../../builtin/index.html#float64">float64</a>, count <a href="../../../../builtin/index.html#int">int</a>) []<a href="../../../../builtin/index.html#float64">float64</a></pre>
			<p>ExponentialBucketsRange creates &apos;count&apos; buckets, where the lowest bucket is
&apos;min&apos; and the highest bucket is &apos;max&apos;. The final +Inf bucket is not counted
and not included in the returned slice. The returned slice is meant to be
used for the Buckets field of HistogramOpts.
<p>The function panics if &apos;count&apos; is 0 or negative, if &apos;min&apos; is 0 or negative.

			
			

		
			
			
			<h2 id="LinearBuckets">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=16045:16106#L278">LinearBuckets</a>
				<a class="permalink" href="index.html#LinearBuckets">&#xb6;</a>
				
				
			</h2>
			<pre>func LinearBuckets(start, width <a href="../../../../builtin/index.html#float64">float64</a>, count <a href="../../../../builtin/index.html#int">int</a>) []<a href="../../../../builtin/index.html#float64">float64</a></pre>
			<p>LinearBuckets creates &apos;count&apos; regular buckets, each &apos;width&apos; wide, where the
lowest bucket has an upper bound of &apos;start&apos;. The final +Inf bucket is not
counted and not included in the returned slice. The returned slice is meant
to be used for the Buckets field of HistogramOpts.
<p>The function panics if &apos;count&apos; is zero or negative.

			
			

		
			
			
			<h2 id="MakeLabelPairs">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go?s=5381:5451#L168">MakeLabelPairs</a>
				<a class="permalink" href="index.html#MakeLabelPairs">&#xb6;</a>
				
				
			</h2>
			<pre>func MakeLabelPairs(desc *<a href="index.html#Desc">Desc</a>, labelValues []<a href="../../../../builtin/index.html#string">string</a>) []*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#LabelPair">LabelPair</a></pre>
			<p>MakeLabelPairs is a helper function to create protobuf LabelPairs from the
variable and constant labels in the provided Desc. The values for the
variable labels are defined by the labelValues slice, which must be in the
same order as the corresponding variable labels in the Desc.
<p>This function is only needed for custom Metric implementations. See MetricVec
example.

			
			

		
			
			
			<h2 id="MustRegister">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=7679:7713#L166">MustRegister</a>
				<a class="permalink" href="index.html#MustRegister">&#xb6;</a>
				
				
			</h2>
			<pre>func MustRegister(cs ...<a href="index.html#Collector">Collector</a>)</pre>
			<p>MustRegister registers the provided Collectors with the DefaultRegisterer and
panics if any error occurs.
<p>MustRegister is a shortcut for DefaultRegisterer.MustRegister(cs...). See
there for more details.

			
			

		
			
			
			<h2 id="NewPidFileFn">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/process_collector.go?s=4273:4330#L141">NewPidFileFn</a>
				<a class="permalink" href="index.html#NewPidFileFn">&#xb6;</a>
				
				
			</h2>
			<pre>func NewPidFileFn(pidFilePath <a href="../../../../builtin/index.html#string">string</a>) func() (<a href="../../../../builtin/index.html#int">int</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>NewPidFileFn returns a function that retrieves a pid from the specified file.
It is meant to be used for the PidFn field in ProcessCollectorOpts.

			
			

		
			
			
			<h2 id="Register">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=7384:7416#L157">Register</a>
				<a class="permalink" href="index.html#Register">&#xb6;</a>
				
				
			</h2>
			<pre>func Register(c <a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#error">error</a></pre>
			<p>Register registers the provided Collector with the DefaultRegisterer.
<p>Register is a shortcut for DefaultRegisterer.Register(c). See there for more
details.

			<div id="example_Register" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Imagine you have a worker pool and want to count the tasks completed.</span>
taskCounter := prometheus.NewCounter(prometheus.CounterOpts{
    Subsystem: &#34;worker_pool&#34;,
    Name:      &#34;completed_tasks_total&#34;,
    Help:      &#34;Total number of tasks completed.&#34;,
})
<span class="comment">// This will register fine.</span>
if err := prometheus.Register(taskCounter); err != nil {
    fmt.Println(err)
} else {
    fmt.Println(&#34;taskCounter registered.&#34;)
}
<span class="comment">// Don&#39;t forget to tell the HTTP server about the Prometheus handler.</span>
<span class="comment">// (In a real program, you still need to start the HTTP server...)</span>
http.Handle(&#34;/metrics&#34;, promhttp.Handler())

<span class="comment">// Now you can start workers and give every one of them a pointer to</span>
<span class="comment">// taskCounter and let it increment it whenever it completes a task.</span>
taskCounter.Inc() <span class="comment">// This has to happen somewhere in the worker code.</span>

<span class="comment">// But wait, you want to see how individual workers perform. So you need</span>
<span class="comment">// a vector of counters, with one element for each worker.</span>
taskCounterVec := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Subsystem: &#34;worker_pool&#34;,
        Name:      &#34;completed_tasks_total&#34;,
        Help:      &#34;Total number of tasks completed.&#34;,
    },
    []string{&#34;worker_id&#34;},
)

<span class="comment">// Registering will fail because we already have a metric of that name.</span>
if err := prometheus.Register(taskCounterVec); err != nil {
    fmt.Println(&#34;taskCounterVec not registered:&#34;, err)
} else {
    fmt.Println(&#34;taskCounterVec registered.&#34;)
}

<span class="comment">// To fix, first unregister the old taskCounter.</span>
if prometheus.Unregister(taskCounter) {
    fmt.Println(&#34;taskCounter unregistered.&#34;)
}

<span class="comment">// Try registering taskCounterVec again.</span>
if err := prometheus.Register(taskCounterVec); err != nil {
    fmt.Println(&#34;taskCounterVec not registered:&#34;, err)
} else {
    fmt.Println(&#34;taskCounterVec registered.&#34;)
}
<span class="comment">// Bummer! Still doesn&#39;t work.</span>

<span class="comment">// Prometheus will not allow you to ever export metrics with</span>
<span class="comment">// inconsistent help strings or label names. After unregistering, the</span>
<span class="comment">// unregistered metrics will cease to show up in the /metrics HTTP</span>
<span class="comment">// response, but the registry still remembers that those metrics had</span>
<span class="comment">// been exported before. For this example, we will now choose a</span>
<span class="comment">// different name. (In a real program, you would obviously not export</span>
<span class="comment">// the obsolete metric in the first place.)</span>
taskCounterVec = prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Subsystem: &#34;worker_pool&#34;,
        Name:      &#34;completed_tasks_by_id&#34;,
        Help:      &#34;Total number of tasks completed.&#34;,
    },
    []string{&#34;worker_id&#34;},
)
if err := prometheus.Register(taskCounterVec); err != nil {
    fmt.Println(&#34;taskCounterVec not registered:&#34;, err)
} else {
    fmt.Println(&#34;taskCounterVec registered.&#34;)
}
<span class="comment">// Finally it worked!</span>

<span class="comment">// The workers have to tell taskCounterVec their id to increment the</span>
<span class="comment">// right element in the metric vector.</span>
taskCounterVec.WithLabelValues(&#34;42&#34;).Inc() <span class="comment">// Code from worker 42.</span>

<span class="comment">// Each worker could also keep a reference to their own counter element</span>
<span class="comment">// around. Pick the counter at initialization time of the worker.</span>
myCounter := taskCounterVec.WithLabelValues(&#34;42&#34;) <span class="comment">// From worker 42 initialization code.</span>
myCounter.Inc()                                   <span class="comment">// Somewhere in the code of that worker.</span>

<span class="comment">// Note that something like WithLabelValues(&#34;42&#34;, &#34;spurious arg&#34;) would</span>
<span class="comment">// panic (because you have provided too many label values). If you want</span>
<span class="comment">// to get an error instead, use GetMetricWithLabelValues(...) instead.</span>
notMyCounter, err := taskCounterVec.GetMetricWithLabelValues(&#34;42&#34;, &#34;spurious arg&#34;)
if err != nil {
    fmt.Println(&#34;Worker initialization failed:&#34;, err)
}
if notMyCounter == nil {
    fmt.Println(&#34;notMyCounter is nil.&#34;)
}

<span class="comment">// A different (and somewhat tricky) approach is to use</span>
<span class="comment">// ConstLabels. ConstLabels are pairs of label names and label values</span>
<span class="comment">// that never change. Each worker creates and registers an own Counter</span>
<span class="comment">// instance where the only difference is in the value of the</span>
<span class="comment">// ConstLabels. Those Counters can all be registered because the</span>
<span class="comment">// different ConstLabel values guarantee that each worker will increment</span>
<span class="comment">// a different Counter metric.</span>
counterOpts := prometheus.CounterOpts{
    Subsystem:   &#34;worker_pool&#34;,
    Name:        &#34;completed_tasks&#34;,
    Help:        &#34;Total number of tasks completed.&#34;,
    ConstLabels: prometheus.Labels{&#34;worker_id&#34;: &#34;42&#34;},
}
taskCounterForWorker42 := prometheus.NewCounter(counterOpts)
if err := prometheus.Register(taskCounterForWorker42); err != nil {
    fmt.Println(&#34;taskCounterVForWorker42 not registered:&#34;, err)
} else {
    fmt.Println(&#34;taskCounterForWorker42 registered.&#34;)
}
<span class="comment">// Obviously, in real code, taskCounterForWorker42 would be a member</span>
<span class="comment">// variable of a worker struct, and the &#34;42&#34; would be retrieved with a</span>
<span class="comment">// GetId() method or something. The Counter would be created and</span>
<span class="comment">// registered in the initialization code of the worker.</span>

<span class="comment">// For the creation of the next Counter, we can recycle</span>
<span class="comment">// counterOpts. Just change the ConstLabels.</span>
counterOpts.ConstLabels = prometheus.Labels{&#34;worker_id&#34;: &#34;2001&#34;}
taskCounterForWorker2001 := prometheus.NewCounter(counterOpts)
if err := prometheus.Register(taskCounterForWorker2001); err != nil {
    fmt.Println(&#34;taskCounterVForWorker2001 not registered:&#34;, err)
} else {
    fmt.Println(&#34;taskCounterForWorker2001 registered.&#34;)
}

taskCounterForWorker2001.Inc()
taskCounterForWorker42.Inc()
taskCounterForWorker2001.Inc()

<span class="comment">// Yet another approach would be to turn the workers themselves into</span>
<span class="comment">// Collectors and register them. See the Collector example for details.</span>

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">taskCounter registered.
taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: &#34;worker_pool_completed_tasks_total&#34;, help: &#34;Total number of tasks completed.&#34;, constLabels: {}, variableLabels: [{worker_id &lt;nil&gt;}]} has different label names or a different help string
taskCounter unregistered.
taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: &#34;worker_pool_completed_tasks_total&#34;, help: &#34;Total number of tasks completed.&#34;, constLabels: {}, variableLabels: [{worker_id &lt;nil&gt;}]} has different label names or a different help string
taskCounterVec registered.
Worker initialization failed: inconsistent label cardinality: expected 1 label values but got 2 in []string{&#34;42&#34;, &#34;spurious arg&#34;}
notMyCounter is nil.
taskCounterForWorker42 registered.
taskCounterForWorker2001 registered.
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Unregister">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=7953:7986#L175">Unregister</a>
				<a class="permalink" href="index.html#Unregister">&#xb6;</a>
				
				
			</h2>
			<pre>func Unregister(c <a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#bool">bool</a></pre>
			<p>Unregister removes the registration of the provided Collector from the
DefaultRegisterer.
<p>Unregister is a shortcut for DefaultRegisterer.Unregister(c). See there for
more details.

			
			

		
			
			
			<h2 id="WriteToTextfile">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=19658:19713#L582">WriteToTextfile</a>
				<a class="permalink" href="index.html#WriteToTextfile">&#xb6;</a>
				
				
			</h2>
			<pre>func WriteToTextfile(filename <a href="../../../../builtin/index.html#string">string</a>, g <a href="index.html#Gatherer">Gatherer</a>) <a href="../../../../builtin/index.html#error">error</a></pre>
			<p>WriteToTextfile calls Gather on the provided Gatherer, encodes the result in the
Prometheus text format, and writes it to a temporary file. Upon success, the
temporary file is renamed to the provided filename.
<p>This is intended for use with the textfile collector of the node exporter.
Note that the node exporter expects the filename to be suffixed with &quot;.prom&quot;.

			
			

		
		
			
			
			<h2 id="AlreadyRegisteredError">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=8841:8922#L195">AlreadyRegisteredError</a>
				<a class="permalink" href="index.html#AlreadyRegisteredError">&#xb6;</a>
				
				
			</h2>
			<p>AlreadyRegisteredError is returned by the Register method if the Collector to
be registered has already been registered before, or a different Collector
that collects the same metrics has been registered before. Registration fails
in that case, but you can detect from the kind of error what has
happened. The error contains fields for the existing Collector and the
(rejected) new Collector that equals the existing one. This can be used to
find out if an equal Collector has been registered before and switch over to
using the old one, as demonstrated in the example.

			<pre>type AlreadyRegisteredError struct {
<span id="AlreadyRegisteredError.ExistingCollector"></span>    ExistingCollector, NewCollector <a href="index.html#Collector">Collector</a>
}
</pre>

			

			

			<div id="example_AlreadyRegisteredError" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
reqCounter := prometheus.NewCounter(prometheus.CounterOpts{
    Name: &#34;requests_total&#34;,
    Help: &#34;The total number of requests served.&#34;,
})
if err := prometheus.Register(reqCounter); err != nil {
    are := &amp;prometheus.AlreadyRegisteredError{}
    if errors.As(err, are) {
        <span class="comment">// A counter for that metric has been registered before.</span>
        <span class="comment">// Use the old counter from now on.</span>
        reqCounter = are.ExistingCollector.(prometheus.Counter)
    } else {
        <span class="comment">// Something else went wrong!</span>
        panic(err)
    }
}
reqCounter.Inc()
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="AlreadyRegisteredError.Error">func (AlreadyRegisteredError) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=8924:8972#L199">Error</a>
					<a class="permalink" href="index.html#AlreadyRegisteredError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (err <a href="index.html#AlreadyRegisteredError">AlreadyRegisteredError</a>) Error() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Collector">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/collector.go?s=1338:3210#L17">Collector</a>
				<a class="permalink" href="index.html#Collector">&#xb6;</a>
				
				
			</h2>
			<p>Collector is the interface implemented by anything that can be used by
Prometheus to collect metrics. A Collector has to be registered for
collection. See Registerer.Register.
<p>The stock metrics provided by this package (Gauge, Counter, Summary,
Histogram, Untyped) are also Collectors (which only ever collect one metric,
namely itself). An implementer of Collector may, however, collect multiple
metrics in a coordinated fashion and/or create metrics on the fly. Examples
for collectors already implemented in this library are the metric vectors
(i.e. collection of multiple instances of the same Metric but with different
label values) like GaugeVec or SummaryVec, and the ExpvarCollector.

			<pre>type Collector interface {
    <span class="comment">// Describe sends the super-set of all possible descriptors of metrics</span>
    <span class="comment">// collected by this Collector to the provided channel and returns once</span>
    <span class="comment">// the last descriptor has been sent. The sent descriptors fulfill the</span>
    <span class="comment">// consistency and uniqueness requirements described in the Desc</span>
    <span class="comment">// documentation.</span>
    <span class="comment">//</span>
    <span class="comment">// It is valid if one and the same Collector sends duplicate</span>
    <span class="comment">// descriptors. Those duplicates are simply ignored. However, two</span>
    <span class="comment">// different Collectors must not send duplicate descriptors.</span>
    <span class="comment">//</span>
    <span class="comment">// Sending no descriptor at all marks the Collector as “unchecked”,</span>
    <span class="comment">// i.e. no checks will be performed at registration time, and the</span>
    <span class="comment">// Collector may yield any Metric it sees fit in its Collect method.</span>
    <span class="comment">//</span>
    <span class="comment">// This method idempotently sends the same descriptors throughout the</span>
    <span class="comment">// lifetime of the Collector. It may be called concurrently and</span>
    <span class="comment">// therefore must be implemented in a concurrency safe way.</span>
    <span class="comment">//</span>
    <span class="comment">// If a Collector encounters an error while executing this method, it</span>
    <span class="comment">// must send an invalid descriptor (created with NewInvalidDesc) to</span>
    <span class="comment">// signal the error to the registry.</span>
    Describe(chan&lt;- *<a href="index.html#Desc">Desc</a>)
    <span class="comment">// Collect is called by the Prometheus registry when collecting</span>
    <span class="comment">// metrics. The implementation sends each collected metric via the</span>
    <span class="comment">// provided channel and returns once the last metric has been sent. The</span>
    <span class="comment">// descriptor of each sent metric is one of those returned by Describe</span>
    <span class="comment">// (unless the Collector is unchecked, see above). Returned metrics that</span>
    <span class="comment">// share the same descriptor must differ in their variable label</span>
    <span class="comment">// values.</span>
    <span class="comment">//</span>
    <span class="comment">// This method may be called concurrently and must therefore be</span>
    <span class="comment">// implemented in a concurrency safe way. Blocking occurs at the expense</span>
    <span class="comment">// of total performance of rendering all registered metrics. Ideally,</span>
    <span class="comment">// Collector implementations support concurrent readers.</span>
    Collect(chan&lt;- <a href="index.html#Metric">Metric</a>)
}</pre>

			

			

			<div id="example_Collector" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package prometheus_test

import (
    &#34;log&#34;
    &#34;net/http&#34;

    &#34;github.com/prometheus/client_golang/prometheus&#34;
    &#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;
)

<span class="comment">// ClusterManager is an example for a system that might have been built without</span>
<span class="comment">// Prometheus in mind. It models a central manager of jobs running in a</span>
<span class="comment">// cluster. Thus, we implement a custom Collector called</span>
<span class="comment">// ClusterManagerCollector, which collects information from a ClusterManager</span>
<span class="comment">// using its provided methods and turns them into Prometheus Metrics for</span>
<span class="comment">// collection.</span>
<span class="comment">//</span>
<span class="comment">// An additional challenge is that multiple instances of the ClusterManager are</span>
<span class="comment">// run within the same binary, each in charge of a different zone. We need to</span>
<span class="comment">// make use of wrapping Registerers to be able to register each</span>
<span class="comment">// ClusterManagerCollector instance with Prometheus.</span>
type ClusterManager struct {
    Zone string
    <span class="comment">// Contains many more fields not listed in this example.</span>
}

<span class="comment">// ReallyExpensiveAssessmentOfTheSystemState is a mock for the data gathering a</span>
<span class="comment">// real cluster manager would have to do. Since it may actually be really</span>
<span class="comment">// expensive, it must only be called once per collection. This implementation,</span>
<span class="comment">// obviously, only returns some made-up data.</span>
func (c *ClusterManager) ReallyExpensiveAssessmentOfTheSystemState() (
    oomCountByHost map[string]int, ramUsageByHost map[string]float64,
) {
    <span class="comment">// Just example fake data.</span>
    oomCountByHost = map[string]int{
        &#34;foo.example.org&#34;: 42,
        &#34;bar.example.org&#34;: 2001,
    }
    ramUsageByHost = map[string]float64{
        &#34;foo.example.org&#34;: 6.023e23,
        &#34;bar.example.org&#34;: 3.14,
    }
    return
}

<span class="comment">// ClusterManagerCollector implements the Collector interface.</span>
type ClusterManagerCollector struct {
    ClusterManager *ClusterManager
}

<span class="comment">// Descriptors used by the ClusterManagerCollector below.</span>
var (
    oomCountDesc = prometheus.NewDesc(
        &#34;clustermanager_oom_crashes_total&#34;,
        &#34;Number of OOM crashes.&#34;,
        []string{&#34;host&#34;}, nil,
    )
    ramUsageDesc = prometheus.NewDesc(
        &#34;clustermanager_ram_usage_bytes&#34;,
        &#34;RAM usage as reported to the cluster manager.&#34;,
        []string{&#34;host&#34;}, nil,
    )
)

<span class="comment">// Describe is implemented with DescribeByCollect. That&#39;s possible because the</span>
<span class="comment">// Collect method will always return the same two metrics with the same two</span>
<span class="comment">// descriptors.</span>
func (cc ClusterManagerCollector) Describe(ch chan&lt;- *prometheus.Desc) {
    prometheus.DescribeByCollect(cc, ch)
}

<span class="comment">// Collect first triggers the ReallyExpensiveAssessmentOfTheSystemState. Then it</span>
<span class="comment">// creates constant metrics for each host on the fly based on the returned data.</span>
<span class="comment">//</span>
<span class="comment">// Note that Collect could be called concurrently, so we depend on</span>
<span class="comment">// ReallyExpensiveAssessmentOfTheSystemState to be concurrency-safe.</span>
func (cc ClusterManagerCollector) Collect(ch chan&lt;- prometheus.Metric) {
    oomCountByHost, ramUsageByHost := cc.ClusterManager.ReallyExpensiveAssessmentOfTheSystemState()
    for host, oomCount := range oomCountByHost {
        ch &lt;- prometheus.MustNewConstMetric(
            oomCountDesc,
            prometheus.CounterValue,
            float64(oomCount),
            host,
        )
    }
    for host, ramUsage := range ramUsageByHost {
        ch &lt;- prometheus.MustNewConstMetric(
            ramUsageDesc,
            prometheus.GaugeValue,
            ramUsage,
            host,
        )
    }
}

<span class="comment">// NewClusterManager first creates a Prometheus-ignorant ClusterManager</span>
<span class="comment">// instance. Then, it creates a ClusterManagerCollector for the just created</span>
<span class="comment">// ClusterManager. Finally, it registers the ClusterManagerCollector with a</span>
<span class="comment">// wrapping Registerer that adds the zone as a label. In this way, the metrics</span>
<span class="comment">// collected by different ClusterManagerCollectors do not collide.</span>
func NewClusterManager(zone string, reg prometheus.Registerer) *ClusterManager {
    c := &amp;ClusterManager{
        Zone: zone,
    }
    cc := ClusterManagerCollector{ClusterManager: c}
    prometheus.WrapRegistererWith(prometheus.Labels{&#34;zone&#34;: zone}, reg).MustRegister(cc)
    return c
}

func ExampleCollector() {
    <span class="comment">// Since we are dealing with custom Collector implementations, it might</span>
    <span class="comment">// be a good idea to try it out with a pedantic registry.</span>
    reg := prometheus.NewPedanticRegistry()

    <span class="comment">// Construct cluster managers. In real code, we would assign them to</span>
    <span class="comment">// variables to then do something with them.</span>
    NewClusterManager(&#34;db&#34;, reg)
    NewClusterManager(&#34;ca&#34;, reg)

    <span class="comment">// Add the standard process and Go metrics to the custom registry.</span>
    reg.MustRegister(
        prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}),
        prometheus.NewGoCollector(),
    )

    http.Handle(&#34;/metrics&#34;, promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
    log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil))
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewBuildInfoCollector">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/build_info_collector.go?s=819:857#L12">NewBuildInfoCollector</a>
					<a class="permalink" href="index.html#NewBuildInfoCollector">&#xb6;</a>
					
					
				</h3>
				<pre>func NewBuildInfoCollector() <a href="index.html#Collector">Collector</a></pre>
				<p>NewBuildInfoCollector is the obsolete version of collectors.NewBuildInfoCollector.
See there for documentation.
<p>Deprecated: Use collectors.NewBuildInfoCollector instead.

				
				
			
				
				<h3 id="NewExpvarCollector">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/expvar_collector.go?s=884:943#L19">NewExpvarCollector</a>
					<a class="permalink" href="index.html#NewExpvarCollector">&#xb6;</a>
					
					
				</h3>
				<pre>func NewExpvarCollector(exports map[<a href="../../../../builtin/index.html#string">string</a>]*<a href="index.html#Desc">Desc</a>) <a href="index.html#Collector">Collector</a></pre>
				<p>NewExpvarCollector is the obsolete version of collectors.NewExpvarCollector.
See there for documentation.
<p>Deprecated: Use collectors.NewExpvarCollector instead.

				<div id="example_NewExpvarCollector" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">expvarCollector := prometheus.NewExpvarCollector(map[string]*prometheus.Desc{
    &#34;memstats&#34;: prometheus.NewDesc(
        &#34;expvar_memstats&#34;,
        &#34;All numeric memstats as one metric family. Not a good role-model, actually... ;-)&#34;,
        []string{&#34;type&#34;}, nil,
    ),
    &#34;lone-int&#34;: prometheus.NewDesc(
        &#34;expvar_lone_int&#34;,
        &#34;Just an expvar int as an example.&#34;,
        nil, nil,
    ),
    &#34;http-request-map&#34;: prometheus.NewDesc(
        &#34;expvar_http_request_total&#34;,
        &#34;How many http requests processed, partitioned by status code and http method.&#34;,
        []string{&#34;code&#34;, &#34;method&#34;}, nil,
    ),
})
prometheus.MustRegister(expvarCollector)

<span class="comment">// The Prometheus part is done here. But to show that this example is</span>
<span class="comment">// doing anything, we have to manually export something via expvar.  In</span>
<span class="comment">// real-life use-cases, some library would already have exported via</span>
<span class="comment">// expvar what we want to re-export as Prometheus metrics.</span>
expvar.NewInt(&#34;lone-int&#34;).Set(42)
expvarMap := expvar.NewMap(&#34;http-request-map&#34;)
var (
    expvarMap1, expvarMap2                             expvar.Map
    expvarInt11, expvarInt12, expvarInt21, expvarInt22 expvar.Int
)
expvarMap1.Init()
expvarMap2.Init()
expvarInt11.Set(3)
expvarInt12.Set(13)
expvarInt21.Set(11)
expvarInt22.Set(212)
expvarMap1.Set(&#34;POST&#34;, &amp;expvarInt11)
expvarMap1.Set(&#34;GET&#34;, &amp;expvarInt12)
expvarMap2.Set(&#34;POST&#34;, &amp;expvarInt21)
expvarMap2.Set(&#34;GET&#34;, &amp;expvarInt22)
expvarMap.Set(&#34;404&#34;, &amp;expvarMap1)
expvarMap.Set(&#34;200&#34;, &amp;expvarMap2)
<span class="comment">// Results in the following expvar map:</span>
<span class="comment">// &#34;http-request-count&#34;: {&#34;200&#34;: {&#34;POST&#34;: 11, &#34;GET&#34;: 212}, &#34;404&#34;: {&#34;POST&#34;: 3, &#34;GET&#34;: 13}}</span>

<span class="comment">// Let&#39;s see what the scrape would yield, but exclude the memstats metrics.</span>
metricStrings := []string{}
metric := dto.Metric{}
metricChan := make(chan prometheus.Metric)
go func() {
    expvarCollector.Collect(metricChan)
    close(metricChan)
}()
for m := range metricChan {
    if !strings.Contains(m.Desc().String(), &#34;expvar_memstats&#34;) {
        metric.Reset()
        m.Write(&amp;metric)
        metricStrings = append(metricStrings, metric.String())
    }
}
sort.Strings(metricStrings)
for _, s := range metricStrings {
    fmt.Println(strings.TrimRight(s, &#34; &#34;))
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">label:&lt;name:&#34;code&#34; value:&#34;200&#34; &gt; label:&lt;name:&#34;method&#34; value:&#34;GET&#34; &gt; untyped:&lt;value:212 &gt;
label:&lt;name:&#34;code&#34; value:&#34;200&#34; &gt; label:&lt;name:&#34;method&#34; value:&#34;POST&#34; &gt; untyped:&lt;value:11 &gt;
label:&lt;name:&#34;code&#34; value:&#34;404&#34; &gt; label:&lt;name:&#34;method&#34; value:&#34;GET&#34; &gt; untyped:&lt;value:13 &gt;
label:&lt;name:&#34;code&#34; value:&#34;404&#34; &gt; label:&lt;name:&#34;method&#34; value:&#34;POST&#34; &gt; untyped:&lt;value:3 &gt;
untyped:&lt;value:42 &gt;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="NewGoCollector">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/go_collector_latest.go?s=5588:5663#L155">NewGoCollector</a>
					<a class="permalink" href="index.html#NewGoCollector">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGoCollector(opts ...func(o *<a href="internal/index.html">internal</a>.<a href="internal/index.html#GoCollectorOptions">GoCollectorOptions</a>)) <a href="index.html#Collector">Collector</a></pre>
				<p>NewGoCollector is the obsolete version of collectors.NewGoCollector.
See there for documentation.
<p>Deprecated: Use collectors.NewGoCollector instead.

				
				
			
				
				<h3 id="NewProcessCollector">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/process_collector.go?s=2136:2197#L50">NewProcessCollector</a>
					<a class="permalink" href="index.html#NewProcessCollector">&#xb6;</a>
					
					
				</h3>
				<pre>func NewProcessCollector(opts <a href="index.html#ProcessCollectorOpts">ProcessCollectorOpts</a>) <a href="index.html#Collector">Collector</a></pre>
				<p>NewProcessCollector is the obsolete version of collectors.NewProcessCollector.
See there for documentation.
<p>Deprecated: Use collectors.NewProcessCollector instead.

				
				
			

			
		
			
			
			<h2 id="ConstrainableLabels">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=1836:1936#L50">ConstrainableLabels</a>
				<a class="permalink" href="index.html#ConstrainableLabels">&#xb6;</a>
				
				
			</h2>
			<p>ConstrainableLabels is an interface that allows creating of labels that can
be optionally constrained.
<pre>prometheus.V2().NewCounterVec(CounterVecOpts{
  CounterOpts: {...}, // Usual CounterOpts fields
  VariableLabels: []ConstrainedLabels{
    {Name: &quot;A&quot;},
    {Name: &quot;B&quot;, Constraint: func(v string) string { ... }},
  },
})
</pre>

			<pre>type ConstrainableLabels interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ConstrainedLabel">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=1273:1356#L28">ConstrainedLabel</a>
				<a class="permalink" href="index.html#ConstrainedLabel">&#xb6;</a>
				
				
			</h2>
			<p>ConstrainedLabels represents a label name and its constrain function
to normalize label values. This type is commonly used when constructing
metric vector Collectors.

			<pre>type ConstrainedLabel struct {
<span id="ConstrainedLabel.Name"></span>    Name       <a href="../../../../builtin/index.html#string">string</a>
<span id="ConstrainedLabel.Constraint"></span>    Constraint func(<a href="../../../../builtin/index.html#string">string</a>) <a href="../../../../builtin/index.html#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ConstrainedLabel.Constrain">func (ConstrainedLabel) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=1358:1411#L33">Constrain</a>
					<a class="permalink" href="index.html#ConstrainedLabel.Constrain">&#xb6;</a>
					
					
				</h3>
				<pre>func (cl <a href="index.html#ConstrainedLabel">ConstrainedLabel</a>) Constrain(v <a href="../../../../builtin/index.html#string">string</a>) <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ConstrainedLabels">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=2123:2164#L58">ConstrainedLabels</a>
				<a class="permalink" href="index.html#ConstrainedLabels">&#xb6;</a>
				
				
			</h2>
			<p>ConstrainedLabels represents a collection of label name -&gt; constrain function
to normalize label values. This type is commonly used when constructing
metric vector Collectors.

			<pre>type ConstrainedLabels []<a href="index.html#ConstrainedLabel">ConstrainedLabel</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Counter">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=1137:1383#L24">Counter</a>
				<a class="permalink" href="index.html#Counter">&#xb6;</a>
				
				
			</h2>
			<p>Counter is a Metric that represents a single numerical value that only ever
goes up. That implies that it cannot be used to count items whose number can
also go down, e.g. the number of currently running goroutines. Those
&quot;counters&quot; are represented by Gauges.
<p>A Counter is typically used to count requests served, tasks completed, errors
occurred, etc.
<p>To create Counter instances, use NewCounter.

			<pre>type Counter interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>

    <span class="comment">// Inc increments the counter by 1. Use Add to increment it by arbitrary</span>
    <span class="comment">// non-negative values.</span>
    Inc()
    <span class="comment">// Add adds the given value to the counter. It panics if the value is &lt;</span>
    <span class="comment">// 0.</span>
    Add(<a href="../../../../builtin/index.html#float64">float64</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewCounter">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=3430:3471#L76">NewCounter</a>
					<a class="permalink" href="index.html#NewCounter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCounter(opts <a href="index.html#CounterOpts">CounterOpts</a>) <a href="index.html#Counter">Counter</a></pre>
				<p>NewCounter creates a new Counter based on the provided CounterOpts.
<p>The returned implementation also implements ExemplarAdder. It is safe to
perform the corresponding type assertion.
<p>The returned implementation tracks the counter value in two separate
variables, a float64 and a uint64. The latter is used to track calls of the
Inc method and calls of the Add method with a value that can be represented
as a uint64. This allows atomic increments of the counter with optimal
performance. (It is common to have an Inc call in very hot execution paths.)
Both internal tracking values are added up in the Write method. This has to
be taken into account when it comes to precision and overflow behavior.

				
				
			

			
		
			
			
			<h2 id="CounterFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=11580:11629#L316">CounterFunc</a>
				<a class="permalink" href="index.html#CounterFunc">&#xb6;</a>
				
				
			</h2>
			<p>CounterFunc is a Counter whose value is determined at collect time by calling a
provided function.
<p>To create CounterFunc instances, use NewCounterFunc.

			<pre>type CounterFunc interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewCounterFunc">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=12259:12333#L331">NewCounterFunc</a>
					<a class="permalink" href="index.html#NewCounterFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCounterFunc(opts <a href="index.html#CounterOpts">CounterOpts</a>, function func() <a href="../../../../builtin/index.html#float64">float64</a>) <a href="index.html#CounterFunc">CounterFunc</a></pre>
				<p>NewCounterFunc creates a new CounterFunc based on the provided
CounterOpts. The value reported is determined by calling the given function
from within the Write method. Take into account that metric collection may
happen concurrently. If that results in concurrent calls to Write, like in
the case where a CounterFunc is directly registered with Prometheus, the
provided function must be concurrency-safe. The function should also honor
the contract for a Counter (values only go up, not down), but compliance will
not be checked.
<p>Check out the ExampleGaugeFunc examples for the similar GaugeFunc.

				
				
			

			
		
			
			
			<h2 id="CounterOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=2191:2212#L50">CounterOpts</a>
				<a class="permalink" href="index.html#CounterOpts">&#xb6;</a>
				
				
			</h2>
			<p>CounterOpts is an alias for Opts. See there for doc comments.

			<pre>type CounterOpts <a href="index.html#Opts">Opts</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="CounterVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=5926:5964#L172">CounterVec</a>
				<a class="permalink" href="index.html#CounterVec">&#xb6;</a>
				
				
			</h2>
			<p>CounterVec is a Collector that bundles a set of Counters that all share the
same Desc, but have different values for their variable labels. This is used
if you want to count the same thing partitioned by various dimensions
(e.g. number of HTTP requests, partitioned by response code and
method). Create instances with NewCounterVec.

			<pre>type CounterVec struct {
    *<a href="index.html#MetricVec">MetricVec</a>
}
</pre>

			

			

			<div id="example_CounterVec" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
httpReqs := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Name: &#34;http_requests_total&#34;,
        Help: &#34;How many HTTP requests processed, partitioned by status code and HTTP method.&#34;,
    },
    []string{&#34;code&#34;, &#34;method&#34;},
)
prometheus.MustRegister(httpReqs)

httpReqs.WithLabelValues(&#34;404&#34;, &#34;POST&#34;).Add(42)

<span class="comment">// If you have to access the same set of labels very frequently, it</span>
<span class="comment">// might be good to retrieve the metric only once and keep a handle to</span>
<span class="comment">// it. But beware of deletion of that metric, see below!</span>
m := httpReqs.WithLabelValues(&#34;200&#34;, &#34;GET&#34;)
for i := 0; i &lt; 1000000; i++ {
    m.Inc()
}
<span class="comment">// Delete a metric from the vector. If you have previously kept a handle</span>
<span class="comment">// to that metric (as above), future updates via that handle will go</span>
<span class="comment">// unseen (even if you re-create a metric with the same label set</span>
<span class="comment">// later).</span>
httpReqs.DeleteLabelValues(&#34;200&#34;, &#34;GET&#34;)
<span class="comment">// Same thing with the more verbose Labels syntax.</span>
httpReqs.Delete(prometheus.Labels{&#34;method&#34;: &#34;GET&#34;, &#34;code&#34;: &#34;200&#34;})
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewCounterVec">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=6087:6156#L178">NewCounterVec</a>
					<a class="permalink" href="index.html#NewCounterVec">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCounterVec(opts <a href="index.html#CounterOpts">CounterOpts</a>, labelNames []<a href="../../../../builtin/index.html#string">string</a>) *<a href="index.html#CounterVec">CounterVec</a></pre>
				<p>NewCounterVec creates a new CounterVec based on the provided CounterOpts and
partitioned by the given label names.

				
				
			

			
				
				<h3 id="CounterVec.CurryWith">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=10992:11058#L294">CurryWith</a>
					<a class="permalink" href="index.html#CounterVec.CurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) CurryWith(labels <a href="index.html#Labels">Labels</a>) (*<a href="index.html#CounterVec">CounterVec</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>CurryWith returns a vector curried with the provided labels, i.e. the
returned vector has those labels pre-set for all labeled operations performed
on it. The cardinality of the curried vector is reduced accordingly. The
order of the remaining labels stays the same (just with the curried labels
taken out of the sequence – which is relevant for the
(GetMetric)WithLabelValues methods). It is possible to curry a curried
vector, but only with labels not yet used for currying before.
<p>The metrics contained in the CounterVec are shared between the curried and
uncurried vectors. They are just accessed differently. Curried and uncurried
vectors behave identically in terms of collection. Only one must be
registered with a given registry (usually the uncurried version). The Reset
method deletes all metrics, even if called on a curried vector.

				
				
				
			
				
				<h3 id="CounterVec.GetMetricWith">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=9178:9244#L248">GetMetricWith</a>
					<a class="permalink" href="index.html#CounterVec.GetMetricWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) GetMetricWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#Counter">Counter</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWith returns the Counter for the given Labels map (the label names
must match those of the variable labels in Desc). If that label map is
accessed for the first time, a new Counter is created. Implications of
creating a Counter without using it and keeping the Counter for later use are
the same as for GetMetricWithLabelValues.
<p>An error is returned if the number and names of the Labels are inconsistent
with those of the variable labels in Desc (minus any curried labels).
<p>This method is used for the same purpose as
GetMetricWithLabelValues(...string). See there for pros and cons of the two
methods.

				
				
				
			
				
				<h3 id="CounterVec.GetMetricWithLabelValues">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=8314:8391#L228">GetMetricWithLabelValues</a>
					<a class="permalink" href="index.html#CounterVec.GetMetricWithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Counter">Counter</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWithLabelValues returns the Counter for the given slice of label
values (same order as the variable labels in Desc). If that combination of
label values is accessed for the first time, a new Counter is created.
<p>It is possible to call this method without using the returned Counter to only
create the new Counter but leave it at its starting value 0. See also the
SummaryVec example.
<p>Keeping the Counter for later use is possible (and should be considered if
performance is critical), but keep in mind that Reset, DeleteLabelValues and
Delete can be used to delete the Counter from the CounterVec. In that case,
the Counter will still exist, but it will not be exported anymore, even if a
Counter with the same label values is created later.
<p>An error is returned if the number of label values is not the same as the
number of variable labels in Desc (minus any curried labels).
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
an alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).
See also the GaugeVec example.

				
				
				
			
				
				<h3 id="CounterVec.MustCurryWith">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=11271:11332#L304">MustCurryWith</a>
					<a class="permalink" href="index.html#CounterVec.MustCurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) MustCurryWith(labels <a href="index.html#Labels">Labels</a>) *<a href="index.html#CounterVec">CounterVec</a></pre>
				<p>MustCurryWith works as CurryWith but panics where CurryWith would have
returned an error.

				
				
				
			
				
				<h3 id="CounterVec.With">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=9975:10023#L273">With</a>
					<a class="permalink" href="index.html#CounterVec.With">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) With(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#Counter">Counter</a></pre>
				<p>With works as GetMetricWith, but panics where GetMetricWithLabels would have
returned an error. Not returning an error allows shortcuts like
<pre>myVec.With(prometheus.Labels{&quot;code&quot;: &quot;404&quot;, &quot;method&quot;: &quot;GET&quot;}).Add(42)
</pre>

				
				
				
			
				
				<h3 id="CounterVec.WithLabelValues">func (*CounterVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=9598:9657#L261">WithLabelValues</a>
					<a class="permalink" href="index.html#CounterVec.WithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#CounterVec">CounterVec</a>) WithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Counter">Counter</a></pre>
				<p>WithLabelValues works as GetMetricWithLabelValues, but panics where
GetMetricWithLabelValues would have returned an error. Not returning an
error allows shortcuts like
<pre>myVec.WithLabelValues(&quot;404&quot;, &quot;GET&quot;).Add(42)
</pre>

				
				
				
			
		
			
			
			<h2 id="CounterVecOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=2429:2692#L55">CounterVecOpts</a>
				<a class="permalink" href="index.html#CounterVecOpts">&#xb6;</a>
				
				
			</h2>
			<p>CounterVecOpts bundles the options to create a CounterVec metric.
It is mandatory to set CounterOpts, see there for mandatory fields. VariableLabels
is optional and can safely be left to its default value.

			<pre>type CounterVecOpts struct {
    <a href="index.html#CounterOpts">CounterOpts</a>

<span id="CounterVecOpts.VariableLabels"></span>    <span class="comment">// VariableLabels are used to partition the metric vector by the given set</span>
    <span class="comment">// of labels. Each label value will be constrained with the optional Contraint</span>
    <span class="comment">// function, if provided.</span>
    VariableLabels <a href="index.html#ConstrainableLabels">ConstrainableLabels</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Desc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/desc.go?s=1734:2661#L35">Desc</a>
				<a class="permalink" href="index.html#Desc">&#xb6;</a>
				
				
			</h2>
			<p>Desc is the descriptor used by every Prometheus Metric. It is essentially
the immutable meta-data of a Metric. The normal Metric implementations
included in this package manage their Desc under the hood. Users only have to
deal with Desc if they use advanced features like the ExpvarCollector or
custom Collectors and Metrics.
<p>Descriptors registered with the same registry have to fulfill certain
consistency and uniqueness criteria if they share the same fully-qualified
name: They must have the same help string and the same label names (aka label
dimensions) in each, constLabels and variableLabels, but they must differ in
the values of the constLabels.
<p>Descriptors that share the same fully-qualified names and the same label
values of their constLabels are considered equal.
<p>Use NewDesc to create new Desc instances.

			<pre>type Desc struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewDesc">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/desc.go?s=3207:3291#L68">NewDesc</a>
					<a class="permalink" href="index.html#NewDesc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewDesc(fqName, help <a href="../../../../builtin/index.html#string">string</a>, variableLabels []<a href="../../../../builtin/index.html#string">string</a>, constLabels <a href="index.html#Labels">Labels</a>) *<a href="index.html#Desc">Desc</a></pre>
				<p>NewDesc allocates and initializes a new Desc. Errors are recorded in the Desc
and will be reported on registration time. variableLabels and constLabels can
be nil if no such labels should be set. fqName must not be empty.
<p>variableLabels only contain the label names. Their label values are variable
and therefore not part of the Desc. (They are managed within the Metric.)
<p>For constLabels, the label values are constant. Therefore, they are fully
specified in the Desc. See the Collector example for a usage pattern.

				
				
			
				
				<h3 id="NewInvalidDesc">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/desc.go?s=7141:7177#L168">NewInvalidDesc</a>
					<a class="permalink" href="index.html#NewInvalidDesc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewInvalidDesc(err <a href="../../../../builtin/index.html#error">error</a>) *<a href="index.html#Desc">Desc</a></pre>
				<p>NewInvalidDesc returns an invalid descriptor, i.e. a descriptor with the
provided error set. If a collector returning such a descriptor is registered,
registration will fail with the provided error. NewInvalidDesc can be used by
a Collector to signal inability to describe itself.

				
				
			

			
				
				<h3 id="Desc.String">func (*Desc) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/desc.go?s=7213:7243#L174">String</a>
					<a class="permalink" href="index.html#Desc.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="index.html#Desc">Desc</a>) String() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Exemplar">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=7627:7857#L194">Exemplar</a>
				<a class="permalink" href="index.html#Exemplar">&#xb6;</a>
				
				
			</h2>
			<p>Exemplar is easier to use, user-facing representation of *dto.Exemplar.

			<pre>type Exemplar struct {
<span id="Exemplar.Value"></span>    Value  <a href="../../../../builtin/index.html#float64">float64</a>
<span id="Exemplar.Labels"></span>    Labels <a href="index.html#Labels">Labels</a>
    <span class="comment">// Optional.</span>
    <span class="comment">// Default value (time.Time{}) indicates its empty, which should be</span>
    <span class="comment">// understood as time.Now() time at the moment of creation of metric.</span>
<span id="Exemplar.Timestamp"></span>    Timestamp <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Time">Time</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ExemplarAdder">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/counter.go?s=2043:2124#L45">ExemplarAdder</a>
				<a class="permalink" href="index.html#ExemplarAdder">&#xb6;</a>
				
				
			</h2>
			<p>ExemplarAdder is implemented by Counters that offer the option of adding a
value to the Counter together with an exemplar. Its AddWithExemplar method
works like the Add method of the Counter interface but also replaces the
currently saved exemplar (if any) with a new one, created from the provided
value, the current time as timestamp, and the provided labels. Empty Labels
will lead to a valid (label-less) exemplar. But if Labels is nil, the current
exemplar is left in place. AddWithExemplar panics if the value is &lt; 0, if any
of the provided labels are invalid, or if the provided labels contain more
than 128 runes in total.

			<pre>type ExemplarAdder interface {
    AddWithExemplar(value <a href="../../../../builtin/index.html#float64">float64</a>, exemplar <a href="index.html#Labels">Labels</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ExemplarObserver">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go?s=2494:2582#L52">ExemplarObserver</a>
				<a class="permalink" href="index.html#ExemplarObserver">&#xb6;</a>
				
				
			</h2>
			<p>ExemplarObserver is implemented by Observers that offer the option of
observing a value together with an exemplar. Its ObserveWithExemplar method
works like the Observe method of an Observer but also replaces the currently
saved exemplar (if any) with a new one, created from the provided value, the
current time as timestamp, and the provided Labels. Empty Labels will lead to
a valid (label-less) exemplar. But if Labels is nil, the current exemplar is
left in place. ObserveWithExemplar panics if any of the provided labels are
invalid or if the provided labels contain more than 128 runes in total.

			<pre>type ExemplarObserver interface {
    ObserveWithExemplar(value <a href="../../../../builtin/index.html#float64">float64</a>, exemplar <a href="index.html#Labels">Labels</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Gatherer">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=5884:7214#L130">Gatherer</a>
				<a class="permalink" href="index.html#Gatherer">&#xb6;</a>
				
				
			</h2>
			<p>Gatherer is the interface for the part of a registry in charge of gathering
the collected metrics into a number of MetricFamilies. The Gatherer interface
comes with the same general implication as described for the Registerer
interface.

			<pre>type Gatherer interface {
    <span class="comment">// Gather calls the Collect method of the registered Collectors and then</span>
    <span class="comment">// gathers the collected metrics into a lexicographically sorted slice</span>
    <span class="comment">// of uniquely named MetricFamily protobufs. Gather ensures that the</span>
    <span class="comment">// returned slice is valid and self-consistent so that it can be used</span>
    <span class="comment">// for valid exposition. As an exception to the strict consistency</span>
    <span class="comment">// requirements described for metric.Desc, Gather will tolerate</span>
    <span class="comment">// different sets of label names for metrics of the same metric family.</span>
    <span class="comment">//</span>
    <span class="comment">// Even if an error occurs, Gather attempts to gather as many metrics as</span>
    <span class="comment">// possible. Hence, if a non-nil error is returned, the returned</span>
    <span class="comment">// MetricFamily slice could be nil (in case of a fatal error that</span>
    <span class="comment">// prevented any meaningful metric collection) or contain a number of</span>
    <span class="comment">// MetricFamily protobufs, some of which might be incomplete, and some</span>
    <span class="comment">// might be missing altogether. The returned error (which might be a</span>
    <span class="comment">// MultiError) explains the details. Note that this is mostly useful for</span>
    <span class="comment">// debugging purposes. If the gathered protobufs are to be used for</span>
    <span class="comment">// exposition in actual monitoring, it is almost always better to not</span>
    <span class="comment">// expose an incomplete result and instead disregard the returned</span>
    <span class="comment">// MetricFamily protobufs in case the returned error is non-nil.</span>
    Gather() ([]*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, <a href="../../../../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="GathererFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=8082:8135#L180">GathererFunc</a>
				<a class="permalink" href="index.html#GathererFunc">&#xb6;</a>
				
				
			</h2>
			<p>GathererFunc turns a function into a Gatherer.

			<pre>type GathererFunc func() ([]*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>

			

			

			
			
			

			

			
				
				<h3 id="GathererFunc.Gather">func (GathererFunc) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=8168:8228#L183">Gather</a>
					<a class="permalink" href="index.html#GathererFunc.Gather">&#xb6;</a>
					
					
				</h3>
				<pre>func (gf <a href="index.html#GathererFunc">GathererFunc</a>) Gather() ([]*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Gather implements Gatherer.

				
				
				
			
		
			
			
			<h2 id="Gatherers">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=24584:24609#L732">Gatherers</a>
				<a class="permalink" href="index.html#Gatherers">&#xb6;</a>
				
				
			</h2>
			<p>Gatherers is a slice of Gatherer instances that implements the Gatherer
interface itself. Its Gather method calls Gather on all Gatherers in the
slice in order and returns the merged results. Errors returned from the
Gather calls are all returned in a flattened MultiError. Duplicate and
inconsistent Metrics are skipped (first occurrence in slice order wins) and
reported in the returned error.
<p>Gatherers can be used to merge the Gather results from multiple
Registries. It also provides a way to directly inject existing MetricFamily
protobufs into the gathering by creating a custom Gatherer with a Gather
method that simply returns the existing MetricFamily protobufs. Note that no
registration is involved (in contrast to Collector registration), so
obviously registration-time checks cannot happen. Any inconsistencies between
the gathered MetricFamilies are reported as errors by the Gather method, and
inconsistent Metrics are dropped. Invalid parts of the MetricFamilies
(e.g. syntactically invalid metric or label names) will go undetected.

			<pre>type Gatherers []<a href="index.html#Gatherer">Gatherer</a></pre>

			

			

			<div id="example_Gatherers" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">reg := prometheus.NewRegistry()
temp := prometheus.NewGaugeVec(
    prometheus.GaugeOpts{
        Name: &#34;temperature_kelvin&#34;,
        Help: &#34;Temperature in Kelvin.&#34;,
    },
    []string{&#34;location&#34;},
)
reg.MustRegister(temp)
temp.WithLabelValues(&#34;outside&#34;).Set(273.14)
temp.WithLabelValues(&#34;inside&#34;).Set(298.44)

var parser expfmt.TextParser

text := `
# TYPE humidity_percent gauge
# HELP humidity_percent Humidity in %.
humidity_percent{location=&#34;outside&#34;} 45.4
humidity_percent{location=&#34;inside&#34;} 33.2
# TYPE temperature_kelvin gauge
# HELP temperature_kelvin Temperature in Kelvin.
temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
`

parseText := func() ([]*dto.MetricFamily, error) {
    parsed, err := parser.TextToMetricFamilies(strings.NewReader(text))
    if err != nil {
        return nil, err
    }
    var result []*dto.MetricFamily
    for _, mf := range parsed {
        result = append(result, mf)
    }
    return result, nil
}

gatherers := prometheus.Gatherers{
    reg,
    prometheus.GathererFunc(parseText),
}

gathering, err := gatherers.Gather()
if err != nil {
    fmt.Println(err)
}

out := &amp;bytes.Buffer{}
for _, mf := range gathering {
    if _, err := expfmt.MetricFamilyToText(out, mf); err != nil {
        panic(err)
    }
}
fmt.Print(out.String())
fmt.Println(&#34;----------&#34;)

<span class="comment">// Note how the temperature_kelvin metric family has been merged from</span>
<span class="comment">// different sources. Now try</span>
text = `
# TYPE humidity_percent gauge
# HELP humidity_percent Humidity in %.
humidity_percent{location=&#34;outside&#34;} 45.4
humidity_percent{location=&#34;inside&#34;} 33.2
# TYPE temperature_kelvin gauge
# HELP temperature_kelvin Temperature in Kelvin.
# Duplicate metric:
temperature_kelvin{location=&#34;outside&#34;} 265.3
 # Missing location label (note that this is undesirable but valid):
temperature_kelvin 4.5
`

gathering, err = gatherers.Gather()
if err != nil {
    fmt.Println(err)
}
<span class="comment">// Note that still as many metrics as possible are returned:</span>
out.Reset()
for _, mf := range gathering {
    if _, err := expfmt.MetricFamilyToText(out, mf); err != nil {
        panic(err)
    }
}
fmt.Print(out.String())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output"># HELP humidity_percent Humidity in %.
# TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
# HELP temperature_kelvin Temperature in Kelvin.
# TYPE temperature_kelvin gauge
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
temperature_kelvin{location=&#34;somewhere else&#34;} 4.5
----------
collected metric &#34;temperature_kelvin&#34; { label:&lt;name:&#34;location&#34; value:&#34;outside&#34; &gt; gauge:&lt;value:265.3 &gt; } was collected before with the same name and label values
# HELP humidity_percent Humidity in %.
# TYPE humidity_percent gauge
humidity_percent{location=&#34;inside&#34;} 33.2
humidity_percent{location=&#34;outside&#34;} 45.4
# HELP temperature_kelvin Temperature in Kelvin.
# TYPE temperature_kelvin gauge
temperature_kelvin 4.5
temperature_kelvin{location=&#34;inside&#34;} 298.44
temperature_kelvin{location=&#34;outside&#34;} 273.14
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Gatherers.Gather">func (Gatherers) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=24642:24699#L735">Gather</a>
					<a class="permalink" href="index.html#Gatherers.Gather">&#xb6;</a>
					
					
				</h3>
				<pre>func (gs <a href="index.html#Gatherers">Gatherers</a>) Gather() ([]*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Gather implements Gatherer.

				
				
				
			
		
			
			
			<h2 id="Gauge">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=1034:1678#L22">Gauge</a>
				<a class="permalink" href="index.html#Gauge">&#xb6;</a>
				
				
			</h2>
			<p>Gauge is a Metric that represents a single numerical value that can
arbitrarily go up and down.
<p>A Gauge is typically used for measured values like temperatures or current
memory usage, but also &quot;counts&quot; that can go up and down, like the number of
running goroutines.
<p>To create Gauge instances, use NewGauge.

			<pre>type Gauge interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>

    <span class="comment">// Set sets the Gauge to an arbitrary value.</span>
    Set(<a href="../../../../builtin/index.html#float64">float64</a>)
    <span class="comment">// Inc increments the Gauge by 1. Use Add to increment it by arbitrary</span>
    <span class="comment">// values.</span>
    Inc()
    <span class="comment">// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary</span>
    <span class="comment">// values.</span>
    Dec()
    <span class="comment">// Add adds the given value to the Gauge. (The value can be negative,</span>
    <span class="comment">// resulting in a decrease of the Gauge.)</span>
    Add(<a href="../../../../builtin/index.html#float64">float64</a>)
    <span class="comment">// Sub subtracts the given value from the Gauge. (The value can be</span>
    <span class="comment">// negative, resulting in an increase of the Gauge.)</span>
    Sub(<a href="../../../../builtin/index.html#float64">float64</a>)

    <span class="comment">// SetToCurrentTime sets the Gauge to the current Unix time in seconds.</span>
    SetToCurrentTime()
}</pre>

			

			

			<div id="example_Gauge" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
opsQueued := prometheus.NewGauge(prometheus.GaugeOpts{
    Namespace: &#34;our_company&#34;,
    Subsystem: &#34;blob_storage&#34;,
    Name:      &#34;ops_queued&#34;,
    Help:      &#34;Number of blob storage operations waiting to be processed.&#34;,
})
prometheus.MustRegister(opsQueued)

<span class="comment">// 10 operations queued by the goroutine managing incoming requests.</span>
opsQueued.Add(10)
<span class="comment">// A worker goroutine has picked up a waiting operation.</span>
opsQueued.Dec()
<span class="comment">// And once more...</span>
opsQueued.Dec()
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewGauge">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=2727:2762#L68">NewGauge</a>
					<a class="permalink" href="index.html#NewGauge">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGauge(opts <a href="index.html#GaugeOpts">GaugeOpts</a>) <a href="index.html#Gauge">Gauge</a></pre>
				<p>NewGauge creates a new Gauge based on the provided GaugeOpts.
<p>The returned implementation is optimized for a fast Set method. If you have a
choice for managing the value of a Gauge via Set vs. Inc/Dec/Add/Sub, pick
the former. For example, the Inc method of the returned Gauge is slower than
the Inc method of a Counter returned by NewCounter. This matches the typical
scenarios for Gauges and Counters, where the former tends to be Set-heavy and
the latter Inc-heavy.

				
				
			

			
		
			
			
			<h2 id="GaugeFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=9969:10016#L280">GaugeFunc</a>
				<a class="permalink" href="index.html#GaugeFunc">&#xb6;</a>
				
				
			</h2>
			<p>GaugeFunc is a Gauge whose value is determined at collect time by calling a
provided function.
<p>To create GaugeFunc instances, use NewGaugeFunc.

			<pre>type GaugeFunc interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>
}</pre>

			

			

			<div id="example_GaugeFunc_constLabels" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ConstLabels)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ConstLabels)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// primaryDB and secondaryDB represent two example *sql.DB connections we want to instrument.</span>
var primaryDB, secondaryDB interface {
    Stats() struct{ OpenConnections int }
}

if err := prometheus.Register(prometheus.NewGaugeFunc(
    prometheus.GaugeOpts{
        Namespace:   &#34;mysql&#34;,
        Name:        &#34;connections_open&#34;,
        Help:        &#34;Number of mysql connections open.&#34;,
        ConstLabels: prometheus.Labels{&#34;destination&#34;: &#34;primary&#34;},
    },
    func() float64 { return float64(primaryDB.Stats().OpenConnections) },
)); err == nil {
    fmt.Println(`GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}`)
}

if err := prometheus.Register(prometheus.NewGaugeFunc(
    prometheus.GaugeOpts{
        Namespace:   &#34;mysql&#34;,
        Name:        &#34;connections_open&#34;,
        Help:        &#34;Number of mysql connections open.&#34;,
        ConstLabels: prometheus.Labels{&#34;destination&#34;: &#34;secondary&#34;},
    },
    func() float64 { return float64(secondaryDB.Stats().OpenConnections) },
)); err == nil {
    fmt.Println(`GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}`)
}

<span class="comment">// Note that we can register more than once GaugeFunc with same metric name</span>
<span class="comment">// as long as their const labels are consistent.</span>

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">GaugeFunc &#39;connections_open&#39; for primary DB connection registered with labels {destination=&#34;primary&#34;}
GaugeFunc &#39;connections_open&#39; for secondary DB connection registered with labels {destination=&#34;secondary&#34;}
</pre>
			
		
	</div>
</div>
<div id="example_GaugeFunc_simple" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Simple)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Simple)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">if err := prometheus.Register(prometheus.NewGaugeFunc(
    prometheus.GaugeOpts{
        Subsystem: &#34;runtime&#34;,
        Name:      &#34;goroutines_count&#34;,
        Help:      &#34;Number of goroutines that currently exist.&#34;,
    },
    func() float64 { return float64(runtime.NumGoroutine()) },
)); err == nil {
    fmt.Println(&#34;GaugeFunc &#39;goroutines_count&#39; registered.&#34;)
}
<span class="comment">// Note that the count of goroutines is a gauge (and not a counter) as</span>
<span class="comment">// it can go up and down.</span>

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">GaugeFunc &#39;goroutines_count&#39; registered.
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewGaugeFunc">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=10553:10621#L294">NewGaugeFunc</a>
					<a class="permalink" href="index.html#NewGaugeFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGaugeFunc(opts <a href="index.html#GaugeOpts">GaugeOpts</a>, function func() <a href="../../../../builtin/index.html#float64">float64</a>) <a href="index.html#GaugeFunc">GaugeFunc</a></pre>
				<p>NewGaugeFunc creates a new GaugeFunc based on the provided GaugeOpts. The
value reported is determined by calling the given function from within the
Write method. Take into account that metric collection may happen
concurrently. Therefore, it must be safe to call the provided function
concurrently.
<p>NewGaugeFunc is a good way to create an “info” style metric with a constant
value of 1. Example:
<a href="https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56">https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56</a>

				
				
			

			
		
			
			
			<h2 id="GaugeOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=1743:1762#L46">GaugeOpts</a>
				<a class="permalink" href="index.html#GaugeOpts">&#xb6;</a>
				
				
			</h2>
			<p>GaugeOpts is an alias for Opts. See there for doc comments.

			<pre>type GaugeOpts <a href="index.html#Opts">Opts</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="GaugeVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=4428:4464#L136">GaugeVec</a>
				<a class="permalink" href="index.html#GaugeVec">&#xb6;</a>
				
				
			</h2>
			<p>GaugeVec is a Collector that bundles a set of Gauges that all share the same
Desc, but have different values for their variable labels. This is used if
you want to count the same thing partitioned by various dimensions
(e.g. number of operations queued, partitioned by user and operation
type). Create instances with NewGaugeVec.

			<pre>type GaugeVec struct {
    *<a href="index.html#MetricVec">MetricVec</a>
}
</pre>

			

			

			<div id="example_GaugeVec" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
opsQueued := prometheus.NewGaugeVec(
    prometheus.GaugeOpts{
        Namespace: &#34;our_company&#34;,
        Subsystem: &#34;blob_storage&#34;,
        Name:      &#34;ops_queued&#34;,
        Help:      &#34;Number of blob storage operations waiting to be processed, partitioned by user and type.&#34;,
    },
    []string{
        <span class="comment">// Which user has requested the operation?</span>
        &#34;user&#34;,
        <span class="comment">// Of what type is the operation?</span>
        &#34;type&#34;,
    },
)
prometheus.MustRegister(opsQueued)

<span class="comment">// Increase a value using compact (but order-sensitive!) WithLabelValues().</span>
opsQueued.WithLabelValues(&#34;bob&#34;, &#34;put&#34;).Add(4)
<span class="comment">// Increase a value with a map using WithLabels. More verbose, but order</span>
<span class="comment">// doesn&#39;t matter anymore.</span>
opsQueued.With(prometheus.Labels{&#34;type&#34;: &#34;delete&#34;, &#34;user&#34;: &#34;alice&#34;}).Inc()
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewGaugeVec">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=4581:4644#L142">NewGaugeVec</a>
					<a class="permalink" href="index.html#NewGaugeVec">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGaugeVec(opts <a href="index.html#GaugeOpts">GaugeOpts</a>, labelNames []<a href="../../../../builtin/index.html#string">string</a>) *<a href="index.html#GaugeVec">GaugeVec</a></pre>
				<p>NewGaugeVec creates a new GaugeVec based on the provided GaugeOpts and
partitioned by the given label names.

				
				
			

			
				
				<h3 id="GaugeVec.CurryWith">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=9399:9461#L258">CurryWith</a>
					<a class="permalink" href="index.html#GaugeVec.CurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) CurryWith(labels <a href="index.html#Labels">Labels</a>) (*<a href="index.html#GaugeVec">GaugeVec</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>CurryWith returns a vector curried with the provided labels, i.e. the
returned vector has those labels pre-set for all labeled operations performed
on it. The cardinality of the curried vector is reduced accordingly. The
order of the remaining labels stays the same (just with the curried labels
taken out of the sequence – which is relevant for the
(GetMetric)WithLabelValues methods). It is possible to curry a curried
vector, but only with labels not yet used for currying before.
<p>The metrics contained in the GaugeVec are shared between the curried and
uncurried vectors. They are just accessed differently. Curried and uncurried
vectors behave identically in terms of collection. Only one must be
registered with a given registry (usually the uncurried version). The Reset
method deletes all metrics, even if called on a curried vector.

				
				
				
			
				
				<h3 id="GaugeVec.GetMetricWith">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=7601:7663#L212">GetMetricWith</a>
					<a class="permalink" href="index.html#GaugeVec.GetMetricWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) GetMetricWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#Gauge">Gauge</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWith returns the Gauge for the given Labels map (the label names
must match those of the variable labels in Desc). If that label map is
accessed for the first time, a new Gauge is created. Implications of
creating a Gauge without using it and keeping the Gauge for later use are
the same as for GetMetricWithLabelValues.
<p>An error is returned if the number and names of the Labels are inconsistent
with those of the variable labels in Desc (minus any curried labels).
<p>This method is used for the same purpose as
GetMetricWithLabelValues(...string). See there for pros and cons of the two
methods.

				
				
				
			
				
				<h3 id="GaugeVec.GetMetricWithLabelValues">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=6751:6824#L192">GetMetricWithLabelValues</a>
					<a class="permalink" href="index.html#GaugeVec.GetMetricWithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Gauge">Gauge</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWithLabelValues returns the Gauge for the given slice of label
values (same order as the variable labels in Desc). If that combination of
label values is accessed for the first time, a new Gauge is created.
<p>It is possible to call this method without using the returned Gauge to only
create the new Gauge but leave it at its starting value 0. See also the
SummaryVec example.
<p>Keeping the Gauge for later use is possible (and should be considered if
performance is critical), but keep in mind that Reset, DeleteLabelValues and
Delete can be used to delete the Gauge from the GaugeVec. In that case, the
Gauge will still exist, but it will not be exported anymore, even if a
Gauge with the same label values is created later. See also the CounterVec
example.
<p>An error is returned if the number of label values is not the same as the
number of variable labels in Desc (minus any curried labels).
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
an alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).

				
				
				
			
				
				<h3 id="GaugeVec.MustCurryWith">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=9672:9729#L268">MustCurryWith</a>
					<a class="permalink" href="index.html#GaugeVec.MustCurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) MustCurryWith(labels <a href="index.html#Labels">Labels</a>) *<a href="index.html#GaugeVec">GaugeVec</a></pre>
				<p>MustCurryWith works as CurryWith but panics where CurryWith would have
returned an error.

				
				
				
			
				
				<h3 id="GaugeVec.With">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=8388:8432#L237">With</a>
					<a class="permalink" href="index.html#GaugeVec.With">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) With(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#Gauge">Gauge</a></pre>
				<p>With works as GetMetricWith, but panics where GetMetricWithLabels would have
returned an error. Not returning an error allows shortcuts like
<pre>myVec.With(prometheus.Labels{&quot;code&quot;: &quot;404&quot;, &quot;method&quot;: &quot;GET&quot;}).Add(42)
</pre>

				
				
				
			
				
				<h3 id="GaugeVec.WithLabelValues">func (*GaugeVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=8015:8070#L225">WithLabelValues</a>
					<a class="permalink" href="index.html#GaugeVec.WithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#GaugeVec">GaugeVec</a>) WithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Gauge">Gauge</a></pre>
				<p>WithLabelValues works as GetMetricWithLabelValues, but panics where
GetMetricWithLabelValues would have returned an error. Not returning an
error allows shortcuts like
<pre>myVec.WithLabelValues(&quot;404&quot;, &quot;GET&quot;).Add(42)
</pre>

				
				
				
			
		
			
			
			<h2 id="GaugeVecOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/gauge.go?s=1973:2232#L51">GaugeVecOpts</a>
				<a class="permalink" href="index.html#GaugeVecOpts">&#xb6;</a>
				
				
			</h2>
			<p>GaugeVecOpts bundles the options to create a GaugeVec metric.
It is mandatory to set GaugeOpts, see there for mandatory fields. VariableLabels
is optional and can safely be left to its default value.

			<pre>type GaugeVecOpts struct {
    <a href="index.html#GaugeOpts">GaugeOpts</a>

<span id="GaugeVecOpts.VariableLabels"></span>    <span class="comment">// VariableLabels are used to partition the metric vector by the given set</span>
    <span class="comment">// of labels. Each label value will be constrained with the optional Contraint</span>
    <span class="comment">// function, if provided.</span>
    VariableLabels <a href="index.html#ConstrainableLabels">ConstrainableLabels</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Histogram">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=14023:14529#L232">Histogram</a>
				<a class="permalink" href="index.html#Histogram">&#xb6;</a>
				
				
			</h2>
			<p>A Histogram counts individual observations from an event or sample stream in
configurable static buckets (or in dynamic sparse buckets as part of the
experimental Native Histograms, see below for more details). Similar to a
Summary, it also provides a sum of observations and an observation count.
<p>On the Prometheus server, quantiles can be calculated from a Histogram using
the histogram_quantile PromQL function.
<p>Note that Histograms, in contrast to Summaries, can be aggregated in PromQL
(see the documentation for detailed procedures). However, Histograms require
the user to pre-define suitable buckets, and they are in general less
accurate. (Both problems are addressed by the experimental Native
Histograms. To use them, configure a NativeHistogramBucketFactor in the
HistogramOpts. They also require a Prometheus server v2.40+ with the
corresponding feature flag enabled.)
<p>The Observe method of a Histogram has a very low performance overhead in
comparison with the Observe method of a Summary.
<p>To create Histogram instances, use NewHistogram.

			<pre>type Histogram interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>

    <span class="comment">// Observe adds a single observation to the histogram. Observations are</span>
    <span class="comment">// usually positive or zero. Negative observations are accepted but</span>
    <span class="comment">// prevent current versions of Prometheus from properly detecting</span>
    <span class="comment">// counter resets in the sum of observations. (The experimental Native</span>
    <span class="comment">// Histograms handle negative observations properly.) See</span>
    <span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span>
    <span class="comment">// for details.</span>
    Observe(<a href="../../../../builtin/index.html#float64">float64</a>)
}</pre>

			

			

			<div id="example_Histogram" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">temps := prometheus.NewHistogram(prometheus.HistogramOpts{
    Name:    &#34;pond_temperature_celsius&#34;,
    Help:    &#34;The temperature of the frog pond.&#34;, <span class="comment">// Sorry, we can&#39;t measure how badly it smells.</span>
    Buckets: prometheus.LinearBuckets(20, 5, 5),  <span class="comment">// 5 buckets, each 5 centigrade wide.</span>
})

<span class="comment">// Simulate some observations.</span>
for i := 0; i &lt; 1000; i++ {
    temps.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)
}

<span class="comment">// Just for demonstration, let&#39;s check the state of the histogram by</span>
<span class="comment">// (ab)using its Write method (which is usually only used by Prometheus</span>
<span class="comment">// internally).</span>
metric := &amp;dto.Metric{}
temps.Write(metric)
fmt.Println(proto.MarshalTextString(metric))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">histogram: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  bucket: &lt;
    cumulative_count: 192
    upper_bound: 20
  &gt;
  bucket: &lt;
    cumulative_count: 366
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 501
    upper_bound: 30
  &gt;
  bucket: &lt;
    cumulative_count: 638
    upper_bound: 35
  &gt;
  bucket: &lt;
    cumulative_count: 816
    upper_bound: 40
  &gt;
&gt;
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewHistogram">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=25525:25572#L479">NewHistogram</a>
					<a class="permalink" href="index.html#NewHistogram">&#xb6;</a>
					
					
				</h3>
				<pre>func NewHistogram(opts <a href="index.html#HistogramOpts">HistogramOpts</a>) <a href="index.html#Histogram">Histogram</a></pre>
				<p>NewHistogram creates a new Histogram based on the provided HistogramOpts. It
panics if the buckets in HistogramOpts are not in strictly increasing order.
<p>The returned implementation also implements ExemplarObserver. It is safe to
perform the corresponding type assertion. Exemplars are tracked separately
for each bucket.

				
				
			

			
		
			
			
			<h2 id="HistogramOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=18491:24693#L348">HistogramOpts</a>
				<a class="permalink" href="index.html#HistogramOpts">&#xb6;</a>
				
				
			</h2>
			<p>HistogramOpts bundles the options for creating a Histogram metric. It is
mandatory to set Name to a non-empty string. All other fields are optional
and can safely be left at their zero value, although it is strongly
encouraged to set a Help string.

			<pre>type HistogramOpts struct {
<span id="HistogramOpts.Namespace"></span>    <span class="comment">// Namespace, Subsystem, and Name are components of the fully-qualified</span>
    <span class="comment">// name of the Histogram (created by joining these components with</span>
    <span class="comment">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the</span>
    <span class="comment">// name. Note that the fully-qualified name of the Histogram must be a</span>
    <span class="comment">// valid Prometheus metric name.</span>
    Namespace <a href="../../../../builtin/index.html#string">string</a>
<span id="HistogramOpts.Subsystem"></span>    Subsystem <a href="../../../../builtin/index.html#string">string</a>
<span id="HistogramOpts.Name"></span>    Name      <a href="../../../../builtin/index.html#string">string</a>

<span id="HistogramOpts.Help"></span>    <span class="comment">// Help provides information about this Histogram.</span>
    <span class="comment">//</span>
    <span class="comment">// Metrics with the same fully-qualified name must have the same Help</span>
    <span class="comment">// string.</span>
    Help <a href="../../../../builtin/index.html#string">string</a>

<span id="HistogramOpts.ConstLabels"></span>    <span class="comment">// ConstLabels are used to attach fixed labels to this metric. Metrics</span>
    <span class="comment">// with the same fully-qualified name must have the same label names in</span>
    <span class="comment">// their ConstLabels.</span>
    <span class="comment">//</span>
    <span class="comment">// ConstLabels are only used rarely. In particular, do not use them to</span>
    <span class="comment">// attach the same labels to all your metrics. Those use cases are</span>
    <span class="comment">// better covered by target labels set by the scraping Prometheus</span>
    <span class="comment">// server, or by one specific metric (e.g. a build_info or a</span>
    <span class="comment">// machine_role metric). See also</span>
    <span class="comment">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels</span>
    ConstLabels <a href="index.html#Labels">Labels</a>

<span id="HistogramOpts.Buckets"></span>    <span class="comment">// Buckets defines the buckets into which observations are counted. Each</span>
    <span class="comment">// element in the slice is the upper inclusive bound of a bucket. The</span>
    <span class="comment">// values must be sorted in strictly increasing order. There is no need</span>
    <span class="comment">// to add a highest bucket with +Inf bound, it will be added</span>
    <span class="comment">// implicitly. If Buckets is left as nil or set to a slice of length</span>
    <span class="comment">// zero, it is replaced by default buckets. The default buckets are</span>
    <span class="comment">// DefBuckets if no buckets for a native histogram (see below) are used,</span>
    <span class="comment">// otherwise the default is no buckets. (In other words, if you want to</span>
    <span class="comment">// use both reguler buckets and buckets for a native histogram, you have</span>
    <span class="comment">// to define the regular buckets here explicitly.)</span>
    Buckets []<a href="../../../../builtin/index.html#float64">float64</a>

    <span class="comment">// If NativeHistogramBucketFactor is greater than one, so-called sparse</span>
    <span class="comment">// buckets are used (in addition to the regular buckets, if defined</span>
    <span class="comment">// above). A Histogram with sparse buckets will be ingested as a Native</span>
    <span class="comment">// Histogram by a Prometheus server with that feature enabled (requires</span>
    <span class="comment">// Prometheus v2.40+). Sparse buckets are exponential buckets covering</span>
    <span class="comment">// the whole float64 range (with the exception of the “zero” bucket, see</span>
    <span class="comment">// SparseBucketsZeroThreshold below). From any one bucket to the next,</span>
    <span class="comment">// the width of the bucket grows by a constant</span>
    <span class="comment">// factor. NativeHistogramBucketFactor provides an upper bound for this</span>
    <span class="comment">// factor (exception see below). The smaller</span>
<span id="HistogramOpts.NativeHistogramBucketFactor"></span>    <span class="comment">// NativeHistogramBucketFactor, the more buckets will be used and thus</span>
    <span class="comment">// the more costly the histogram will become. A generally good trade-off</span>
    <span class="comment">// between cost and accuracy is a value of 1.1 (each bucket is at most</span>
    <span class="comment">// 10% wider than the previous one), which will result in each power of</span>
    <span class="comment">// two divided into 8 buckets (e.g. there will be 8 buckets between 1</span>
    <span class="comment">// and 2, same as between 2 and 4, and 4 and 8, etc.).</span>
    <span class="comment">//</span>
    <span class="comment">// Details about the actually used factor: The factor is calculated as</span>
    <span class="comment">// 2^(2^n), where n is an integer number between (and including) -8 and</span>
    <span class="comment">// 4. n is chosen so that the resulting factor is the largest that is</span>
    <span class="comment">// still smaller or equal to NativeHistogramBucketFactor. Note that the</span>
    <span class="comment">// smallest possible factor is therefore approx. 1.00271 (i.e. 2^(2^-8)</span>
    <span class="comment">// ). If NativeHistogramBucketFactor is greater than 1 but smaller than</span>
    <span class="comment">// 2^(2^-8), then the actually used factor is still 2^(2^-8) even though</span>
    <span class="comment">// it is larger than the provided NativeHistogramBucketFactor.</span>
    <span class="comment">//</span>
    <span class="comment">// NOTE: Native Histograms are still an experimental feature. Their</span>
    <span class="comment">// behavior might still change without a major version</span>
    <span class="comment">// bump. Subsequently, all NativeHistogram... options here might still</span>
    <span class="comment">// change their behavior or name (or might completely disappear) without</span>
    <span class="comment">// a major version bump.</span>
    NativeHistogramBucketFactor <a href="../../../../builtin/index.html#float64">float64</a>
    <span class="comment">// All observations with an absolute value of less or equal</span>
<span id="HistogramOpts.NativeHistogramZeroThreshold"></span>    <span class="comment">// NativeHistogramZeroThreshold are accumulated into a “zero”</span>
    <span class="comment">// bucket. For best results, this should be close to a bucket</span>
    <span class="comment">// boundary. This is usually the case if picking a power of two. If</span>
    <span class="comment">// NativeHistogramZeroThreshold is left at zero,</span>
    <span class="comment">// DefSparseBucketsZeroThreshold is used as the threshold. To configure</span>
    <span class="comment">// a zero bucket with an actual threshold of zero (i.e. only</span>
    <span class="comment">// observations of precisely zero will go into the zero bucket), set</span>
    <span class="comment">// NativeHistogramZeroThreshold to the NativeHistogramZeroThresholdZero</span>
    <span class="comment">// constant (or any negative float value).</span>
    NativeHistogramZeroThreshold <a href="../../../../builtin/index.html#float64">float64</a>

    <span class="comment">// The remaining fields define a strategy to limit the number of</span>
    <span class="comment">// populated sparse buckets. If NativeHistogramMaxBucketNumber is left</span>
    <span class="comment">// at zero, the number of buckets is not limited. (Note that this might</span>
    <span class="comment">// lead to unbounded memory consumption if the values observed by the</span>
    <span class="comment">// Histogram are sufficiently wide-spread. In particular, this could be</span>
    <span class="comment">// used as a DoS attack vector. Where the observed values depend on</span>
    <span class="comment">// external inputs, it is highly recommended to set a</span>
<span id="HistogramOpts.NativeHistogramMaxBucketNumber"></span>    <span class="comment">// NativeHistogramMaxBucketNumber.)  Once the set</span>
    <span class="comment">// NativeHistogramMaxBucketNumber is exceeded, the following strategy is</span>
    <span class="comment">// enacted: First, if the last reset (or the creation) of the histogram</span>
    <span class="comment">// is at least NativeHistogramMinResetDuration ago, then the whole</span>
    <span class="comment">// histogram is reset to its initial state (including regular</span>
    <span class="comment">// buckets). If less time has passed, or if</span>
<span id="HistogramOpts.NativeHistogramMinResetDuration"></span>    <span class="comment">// NativeHistogramMinResetDuration is zero, no reset is</span>
    <span class="comment">// performed. Instead, the zero threshold is increased sufficiently to</span>
    <span class="comment">// reduce the number of buckets to or below</span>
    <span class="comment">// NativeHistogramMaxBucketNumber, but not to more than</span>
<span id="HistogramOpts.NativeHistogramMaxZeroThreshold"></span>    <span class="comment">// NativeHistogramMaxZeroThreshold. Thus, if</span>
    <span class="comment">// NativeHistogramMaxZeroThreshold is already at or below the current</span>
    <span class="comment">// zero threshold, nothing happens at this step. After that, if the</span>
    <span class="comment">// number of buckets still exceeds NativeHistogramMaxBucketNumber, the</span>
    <span class="comment">// resolution of the histogram is reduced by doubling the width of the</span>
    <span class="comment">// sparse buckets (up to a growth factor between one bucket to the next</span>
    <span class="comment">// of 2^(2^4) = 65536, see above).</span>
    NativeHistogramMaxBucketNumber  <a href="../../../../builtin/index.html#uint32">uint32</a>
    NativeHistogramMinResetDuration <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Duration">Duration</a>
    NativeHistogramMaxZeroThreshold <a href="../../../../builtin/index.html#float64">float64</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="HistogramVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=47347:47387#L1027">HistogramVec</a>
				<a class="permalink" href="index.html#HistogramVec">&#xb6;</a>
				
				
			</h2>
			<p>HistogramVec is a Collector that bundles a set of Histograms that all share the
same Desc, but have different values for their variable labels. This is used
if you want to count the same thing partitioned by various dimensions
(e.g. HTTP request latencies, partitioned by status code and method). Create
instances with NewHistogramVec.

			<pre>type HistogramVec struct {
    *<a href="index.html#MetricVec">MetricVec</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewHistogramVec">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=47516:47591#L1033">NewHistogramVec</a>
					<a class="permalink" href="index.html#NewHistogramVec">&#xb6;</a>
					
					
				</h3>
				<pre>func NewHistogramVec(opts <a href="index.html#HistogramOpts">HistogramOpts</a>, labelNames []<a href="../../../../builtin/index.html#string">string</a>) *<a href="index.html#HistogramVec">HistogramVec</a></pre>
				<p>NewHistogramVec creates a new HistogramVec based on the provided HistogramOpts and
partitioned by the given label names.

				
				
			

			
				
				<h3 id="HistogramVec.CurryWith">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=52297:52365#L1145">CurryWith</a>
					<a class="permalink" href="index.html#HistogramVec.CurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) CurryWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#ObserverVec">ObserverVec</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>CurryWith returns a vector curried with the provided labels, i.e. the
returned vector has those labels pre-set for all labeled operations performed
on it. The cardinality of the curried vector is reduced accordingly. The
order of the remaining labels stays the same (just with the curried labels
taken out of the sequence – which is relevant for the
(GetMetric)WithLabelValues methods). It is possible to curry a curried
vector, but only with labels not yet used for currying before.
<p>The metrics contained in the HistogramVec are shared between the curried and
uncurried vectors. They are just accessed differently. Curried and uncurried
vectors behave identically in terms of collection. Only one must be
registered with a given registry (usually the uncurried version). The Reset
method deletes all metrics, even if called on a curried vector.

				
				
				
			
				
				<h3 id="HistogramVec.GetMetricWith">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=50458:50527#L1099">GetMetricWith</a>
					<a class="permalink" href="index.html#HistogramVec.GetMetricWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) GetMetricWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWith returns the Histogram for the given Labels map (the label names
must match those of the variable labels in Desc). If that label map is
accessed for the first time, a new Histogram is created. Implications of
creating a Histogram without using it and keeping the Histogram for later use
are the same as for GetMetricWithLabelValues.
<p>An error is returned if the number and names of the Labels are inconsistent
with those of the variable labels in Desc (minus any curried labels).
<p>This method is used for the same purpose as
GetMetricWithLabelValues(...string). See there for pros and cons of the two
methods.

				
				
				
			
				
				<h3 id="HistogramVec.GetMetricWithLabelValues">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=49582:49662#L1079">GetMetricWithLabelValues</a>
					<a class="permalink" href="index.html#HistogramVec.GetMetricWithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWithLabelValues returns the Histogram for the given slice of label
values (same order as the variable labels in Desc). If that combination of
label values is accessed for the first time, a new Histogram is created.
<p>It is possible to call this method without using the returned Histogram to only
create the new Histogram but leave it at its starting value, a Histogram without
any observations.
<p>Keeping the Histogram for later use is possible (and should be considered if
performance is critical), but keep in mind that Reset, DeleteLabelValues and
Delete can be used to delete the Histogram from the HistogramVec. In that case, the
Histogram will still exist, but it will not be exported anymore, even if a
Histogram with the same label values is created later. See also the CounterVec
example.
<p>An error is returned if the number of label values is not the same as the
number of variable labels in Desc (minus any curried labels).
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
an alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).
See also the GaugeVec example.

				
				
				
			
				
				<h3 id="HistogramVec.MustCurryWith">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=52580:52643#L1155">MustCurryWith</a>
					<a class="permalink" href="index.html#HistogramVec.MustCurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) MustCurryWith(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#ObserverVec">ObserverVec</a></pre>
				<p>MustCurryWith works as CurryWith but panics where CurryWith would have
returned an error.

				
				
				
			
				
				<h3 id="HistogramVec.With">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=51275:51326#L1124">With</a>
					<a class="permalink" href="index.html#HistogramVec.With">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) With(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#Observer">Observer</a></pre>
				<p>With works as GetMetricWith but panics where GetMetricWithLabels would have
returned an error. Not returning an error allows shortcuts like
<pre>myVec.With(prometheus.Labels{&quot;code&quot;: &quot;404&quot;, &quot;method&quot;: &quot;GET&quot;}).Observe(42.21)
</pre>

				
				
				
			
				
				<h3 id="HistogramVec.WithLabelValues">func (*HistogramVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=50889:50951#L1112">WithLabelValues</a>
					<a class="permalink" href="index.html#HistogramVec.WithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#HistogramVec">HistogramVec</a>) WithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Observer">Observer</a></pre>
				<p>WithLabelValues works as GetMetricWithLabelValues, but panics where
GetMetricWithLabelValues would have returned an error. Not returning an
error allows shortcuts like
<pre>myVec.WithLabelValues(&quot;404&quot;, &quot;GET&quot;).Observe(42.21)
</pre>

				
				
				
			
		
			
			
			<h2 id="HistogramVecOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=24916:25183#L464">HistogramVecOpts</a>
				<a class="permalink" href="index.html#HistogramVecOpts">&#xb6;</a>
				
				
			</h2>
			<p>HistogramVecOpts bundles the options to create a HistogramVec metric.
It is mandatory to set HistogramOpts, see there for mandatory fields. VariableLabels
is optional and can safely be left to its default value.

			<pre>type HistogramVecOpts struct {
    <a href="index.html#HistogramOpts">HistogramOpts</a>

<span id="HistogramVecOpts.VariableLabels"></span>    <span class="comment">// VariableLabels are used to partition the metric vector by the given set</span>
    <span class="comment">// of labels. Each label value will be constrained with the optional Contraint</span>
    <span class="comment">// function, if provided.</span>
    VariableLabels <a href="index.html#ConstrainableLabels">ConstrainableLabels</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Labels">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=1066:1095#L23">Labels</a>
				<a class="permalink" href="index.html#Labels">&#xb6;</a>
				
				
			</h2>
			<p>Labels represents a collection of label name -&gt; value mappings. This type is
commonly used with the With(Labels) and GetMetricWith(Labels) methods of
metric vector Collectors, e.g.:
<pre>myVec.With(Labels{&quot;code&quot;: &quot;404&quot;, &quot;method&quot;: &quot;GET&quot;}).Add(42)
</pre>
<p>The other use-case is the specification of constant label pairs in Opts or to
create a Desc.

			<pre>type Labels map[<a href="../../../../builtin/index.html#string">string</a>]<a href="../../../../builtin/index.html#string">string</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Metric">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=1070:2385#L23">Metric</a>
				<a class="permalink" href="index.html#Metric">&#xb6;</a>
				
				
			</h2>
			<p>A Metric models a single sample value with its meta data being exported to
Prometheus. Implementations of Metric in this package are Gauge, Counter,
Histogram, Summary, and Untyped.

			<pre>type Metric interface {
    <span class="comment">// Desc returns the descriptor for the Metric. This method idempotently</span>
    <span class="comment">// returns the same descriptor throughout the lifetime of the</span>
    <span class="comment">// Metric. The returned descriptor is immutable by contract. A Metric</span>
    <span class="comment">// unable to describe itself must return an invalid descriptor (created</span>
    <span class="comment">// with NewInvalidDesc).</span>
    Desc() *<a href="index.html#Desc">Desc</a>
    <span class="comment">// Write encodes the Metric into a &#34;Metric&#34; Protocol Buffer data</span>
    <span class="comment">// transmission object.</span>
    <span class="comment">//</span>
    <span class="comment">// Metric implementations must observe concurrency safety as reads of</span>
    <span class="comment">// this metric may occur at any time, and any blocking occurs at the</span>
    <span class="comment">// expense of total performance of rendering all registered</span>
    <span class="comment">// metrics. Ideally, Metric implementations should support concurrent</span>
    <span class="comment">// readers.</span>
    <span class="comment">//</span>
    <span class="comment">// While populating dto.Metric, it is the responsibility of the</span>
    <span class="comment">// implementation to ensure validity of the Metric protobuf (like valid</span>
    <span class="comment">// UTF-8 strings or syntactically valid metric and label names). It is</span>
    <span class="comment">// recommended to sort labels lexicographically. Callers of Write should</span>
    <span class="comment">// still make sure of sorting if they depend on it.</span>
    Write(*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#Metric">Metric</a>) <a href="../../../../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="MustNewConstHistogram">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=54890:55021#L1237">MustNewConstHistogram</a>
					<a class="permalink" href="index.html#MustNewConstHistogram">&#xb6;</a>
					
					
				</h3>
				<pre>func MustNewConstHistogram(
    desc *<a href="index.html#Desc">Desc</a>,
    count <a href="../../../../builtin/index.html#uint64">uint64</a>,
    sum <a href="../../../../builtin/index.html#float64">float64</a>,
    buckets map[<a href="../../../../builtin/index.html#float64">float64</a>]<a href="../../../../builtin/index.html#uint64">uint64</a>,
    labelValues ...<a href="../../../../builtin/index.html#string">string</a>,
) <a href="index.html#Metric">Metric</a></pre>
				<p>MustNewConstHistogram is a version of NewConstHistogram that panics where
NewConstHistogram would have returned an error.

				
				
			
				
				<h3 id="MustNewConstMetric">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go?s=4010:4111#L115">MustNewConstMetric</a>
					<a class="permalink" href="index.html#MustNewConstMetric">&#xb6;</a>
					
					
				</h3>
				<pre>func MustNewConstMetric(desc *<a href="index.html#Desc">Desc</a>, valueType <a href="index.html#ValueType">ValueType</a>, value <a href="../../../../builtin/index.html#float64">float64</a>, labelValues ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Metric">Metric</a></pre>
				<p>MustNewConstMetric is a version of NewConstMetric that panics where
NewConstMetric would have returned an error.

				
				
			
				
				<h3 id="MustNewConstSummary">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=25221:25353#L744">MustNewConstSummary</a>
					<a class="permalink" href="index.html#MustNewConstSummary">&#xb6;</a>
					
					
				</h3>
				<pre>func MustNewConstSummary(
    desc *<a href="index.html#Desc">Desc</a>,
    count <a href="../../../../builtin/index.html#uint64">uint64</a>,
    sum <a href="../../../../builtin/index.html#float64">float64</a>,
    quantiles map[<a href="../../../../builtin/index.html#float64">float64</a>]<a href="../../../../builtin/index.html#float64">float64</a>,
    labelValues ...<a href="../../../../builtin/index.html#string">string</a>,
) <a href="index.html#Metric">Metric</a></pre>
				<p>MustNewConstSummary is a version of NewConstSummary that panics where
NewConstMetric would have returned an error.

				
				
			
				
				<h3 id="MustNewMetricWithExemplars">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=8970:9041#L238">MustNewMetricWithExemplars</a>
					<a class="permalink" href="index.html#MustNewMetricWithExemplars">&#xb6;</a>
					
					
				</h3>
				<pre>func MustNewMetricWithExemplars(m <a href="index.html#Metric">Metric</a>, exemplars ...<a href="index.html#Exemplar">Exemplar</a>) <a href="index.html#Metric">Metric</a></pre>
				<p>MustNewMetricWithExemplars is a version of NewMetricWithExemplars that panics where
NewMetricWithExemplars would have returned an error.

				
				
			
				
				<h3 id="NewConstHistogram">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/histogram.go?s=54302:54438#L1213">NewConstHistogram</a>
					<a class="permalink" href="index.html#NewConstHistogram">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConstHistogram(
    desc *<a href="index.html#Desc">Desc</a>,
    count <a href="../../../../builtin/index.html#uint64">uint64</a>,
    sum <a href="../../../../builtin/index.html#float64">float64</a>,
    buckets map[<a href="../../../../builtin/index.html#float64">float64</a>]<a href="../../../../builtin/index.html#uint64">uint64</a>,
    labelValues ...<a href="../../../../builtin/index.html#string">string</a>,
) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>NewConstHistogram returns a metric representing a Prometheus histogram with
fixed values for the count, sum, and bucket counts. As those parameters
cannot be changed, the returned value does not implement the Histogram
interface (but only the Metric interface). Users of this package will not
have much use for it in regular operations. However, when implementing custom
Collectors, it is useful as a throw-away metric that is generated on the fly
to send it to Prometheus in the Collect method.
<p>buckets is a map of upper bounds to cumulative counts, excluding the +Inf
bucket. The +Inf bucket is implicit, and its value is equal to the provided count.
<p>NewConstHistogram returns an error if the length of labelValues is not
consistent with the variable labels in Desc or if Desc is invalid.

				<div id="example_NewConstHistogram" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">desc := prometheus.NewDesc(
    &#34;http_request_duration_seconds&#34;,
    &#34;A histogram of the HTTP request durations.&#34;,
    []string{&#34;code&#34;, &#34;method&#34;},
    prometheus.Labels{&#34;owner&#34;: &#34;example&#34;},
)

<span class="comment">// Create a constant histogram from values we got from a 3rd party telemetry system.</span>
h := prometheus.MustNewConstHistogram(
    desc,
    4711, 403.34,
    map[float64]uint64{25: 121, 50: 2403, 100: 3221, 200: 4233},
    &#34;200&#34;, &#34;get&#34;,
)

<span class="comment">// Just for demonstration, let&#39;s check the state of the histogram by</span>
<span class="comment">// (ab)using its Write method (which is usually only used by Prometheus</span>
<span class="comment">// internally).</span>
metric := &amp;dto.Metric{}
h.Write(metric)
fmt.Println(proto.MarshalTextString(metric))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
histogram: &lt;
  sample_count: 4711
  sample_sum: 403.34
  bucket: &lt;
    cumulative_count: 121
    upper_bound: 25
  &gt;
  bucket: &lt;
    cumulative_count: 2403
    upper_bound: 50
  &gt;
  bucket: &lt;
    cumulative_count: 3221
    upper_bound: 100
  &gt;
  bucket: &lt;
    cumulative_count: 4233
    upper_bound: 200
  &gt;
&gt;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="NewConstMetric">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go?s=3408:3514#L94">NewConstMetric</a>
					<a class="permalink" href="index.html#NewConstMetric">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConstMetric(desc *<a href="index.html#Desc">Desc</a>, valueType <a href="index.html#ValueType">ValueType</a>, value <a href="../../../../builtin/index.html#float64">float64</a>, labelValues ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>NewConstMetric returns a metric with one fixed value that cannot be
changed. Users of this package will not have much use for it in regular
operations. However, when implementing custom Collectors, it is useful as a
throw-away metric that is generated on the fly to send it to Prometheus in
the Collect method. NewConstMetric returns an error if the length of
labelValues is not consistent with the variable labels in Desc or if Desc is
invalid.

				
				
			
				
				<h3 id="NewConstSummary">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=24639:24776#L720">NewConstSummary</a>
					<a class="permalink" href="index.html#NewConstSummary">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConstSummary(
    desc *<a href="index.html#Desc">Desc</a>,
    count <a href="../../../../builtin/index.html#uint64">uint64</a>,
    sum <a href="../../../../builtin/index.html#float64">float64</a>,
    quantiles map[<a href="../../../../builtin/index.html#float64">float64</a>]<a href="../../../../builtin/index.html#float64">float64</a>,
    labelValues ...<a href="../../../../builtin/index.html#string">string</a>,
) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>NewConstSummary returns a metric representing a Prometheus summary with fixed
values for the count, sum, and quantiles. As those parameters cannot be
changed, the returned value does not implement the Summary interface (but
only the Metric interface). Users of this package will not have much use for
it in regular operations. However, when implementing custom Collectors, it is
useful as a throw-away metric that is generated on the fly to send it to
Prometheus in the Collect method.
<p>quantiles maps ranks to quantile values. For example, a median latency of
0.23s and a 99th percentile latency of 0.56s would be expressed as:
<pre>map[float64]float64{0.5: 0.23, 0.99: 0.56}
</pre>
<p>NewConstSummary returns an error if the length of labelValues is not
consistent with the variable labels in Desc or if Desc is invalid.

				<div id="example_NewConstSummary" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">desc := prometheus.NewDesc(
    &#34;http_request_duration_seconds&#34;,
    &#34;A summary of the HTTP request durations.&#34;,
    []string{&#34;code&#34;, &#34;method&#34;},
    prometheus.Labels{&#34;owner&#34;: &#34;example&#34;},
)

<span class="comment">// Create a constant summary from values we got from a 3rd party telemetry system.</span>
s := prometheus.MustNewConstSummary(
    desc,
    4711, 403.34,
    map[float64]float64{0.5: 42.3, 0.9: 323.3},
    &#34;200&#34;, &#34;get&#34;,
)

<span class="comment">// Just for demonstration, let&#39;s check the state of the summary by</span>
<span class="comment">// (ab)using its Write method (which is usually only used by Prometheus</span>
<span class="comment">// internally).</span>
metric := &amp;dto.Metric{}
s.Write(metric)
fmt.Println(proto.MarshalTextString(metric))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">label: &lt;
  name: &#34;code&#34;
  value: &#34;200&#34;
&gt;
label: &lt;
  name: &#34;method&#34;
  value: &#34;get&#34;
&gt;
label: &lt;
  name: &#34;owner&#34;
  value: &#34;example&#34;
&gt;
summary: &lt;
  sample_count: 4711
  sample_sum: 403.34
  quantile: &lt;
    quantile: 0.5
    value: 42.3
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 323.3
  &gt;
&gt;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="NewInvalidMetric">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=5087:5138#L117">NewInvalidMetric</a>
					<a class="permalink" href="index.html#NewInvalidMetric">&#xb6;</a>
					
					
				</h3>
				<pre>func NewInvalidMetric(desc *<a href="index.html#Desc">Desc</a>, err <a href="../../../../builtin/index.html#error">error</a>) <a href="index.html#Metric">Metric</a></pre>
				<p>NewInvalidMetric returns a metric whose Write method always returns the
provided error. It is useful if a Collector finds itself unable to collect
a metric and wishes to report an error to the registry.

				
				
			
				
				<h3 id="NewMetricWithExemplars">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=8299:8375#L212">NewMetricWithExemplars</a>
					<a class="permalink" href="index.html#NewMetricWithExemplars">&#xb6;</a>
					
					
				</h3>
				<pre>func NewMetricWithExemplars(m <a href="index.html#Metric">Metric</a>, exemplars ...<a href="index.html#Exemplar">Exemplar</a>) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>NewMetricWithExemplars returns a new Metric wrapping the provided Metric with given
exemplars. Exemplars are validated.
<p>Only last applicable exemplar is injected from the list.
For example for Counter it means last exemplar is injected.
For Histogram, it means last applicable exemplar for each bucket is injected.
<p>NewMetricWithExemplars works best with MustNewConstMetric and
MustNewConstHistogram, see example.

				
				
			
				
				<h3 id="NewMetricWithTimestamp">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=6231:6288#L149">NewMetricWithTimestamp</a>
					<a class="permalink" href="index.html#NewMetricWithTimestamp">&#xb6;</a>
					
					
				</h3>
				<pre>func NewMetricWithTimestamp(t <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Time">Time</a>, m <a href="index.html#Metric">Metric</a>) <a href="index.html#Metric">Metric</a></pre>
				<p>NewMetricWithTimestamp returns a new Metric wrapping the provided Metric in a
way that it has an explicit timestamp set to the provided Time. This is only
useful in rare cases as the timestamp of a Prometheus metric should usually
be set by the Prometheus server during scraping. Exceptions include mirroring
metrics with given timestamps from other metric
sources.
<p>NewMetricWithTimestamp works best with MustNewConstMetric,
MustNewConstHistogram, and MustNewConstSummary, see example.
<p>Currently, the exposition formats used by Prometheus are limited to
millisecond resolution. Thus, the provided time will be rounded down to the
next full millisecond value.

				<div id="example_NewMetricWithTimestamp" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">desc := prometheus.NewDesc(
    &#34;temperature_kelvin&#34;,
    &#34;Current temperature in Kelvin.&#34;,
    nil, nil,
)

<span class="comment">// Create a constant gauge from values we got from an external</span>
<span class="comment">// temperature reporting system. Those values are reported with a slight</span>
<span class="comment">// delay, so we want to add the timestamp of the actual measurement.</span>
temperatureReportedByExternalSystem := 298.15
timeReportedByExternalSystem := time.Date(2009, time.November, 10, 23, 0, 0, 12345678, time.UTC)
s := prometheus.NewMetricWithTimestamp(
    timeReportedByExternalSystem,
    prometheus.MustNewConstMetric(
        desc, prometheus.GaugeValue, temperatureReportedByExternalSystem,
    ),
)

<span class="comment">// Just for demonstration, let&#39;s check the state of the gauge by</span>
<span class="comment">// (ab)using its Write method (which is usually only used by Prometheus</span>
<span class="comment">// internally).</span>
metric := &amp;dto.Metric{}
s.Write(metric)
fmt.Println(proto.MarshalTextString(metric))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">gauge: &lt;
  value: 298.15
&gt;
timestamp_ms: 1257894000012
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="MetricVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=1565:1795#L26">MetricVec</a>
				<a class="permalink" href="index.html#MetricVec">&#xb6;</a>
				
				
			</h2>
			<p>MetricVec is a Collector to bundle metrics of the same name that differ in
their label values. MetricVec is not used directly but as a building block
for implementations of vectors of a given metric type, like GaugeVec,
CounterVec, SummaryVec, and HistogramVec. It is exported so that it can be
used for custom Metric implementations.
<p>To create a FooVec for custom Metric Foo, embed a pointer to MetricVec in
FooVec and initialize it with NewMetricVec. Implement wrappers for
GetMetricWithLabelValues and GetMetricWith that return (Foo, error) rather
than (Metric, error). Similarly, create a wrapper for CurryWith that returns
(*FooVec, error) rather than (*MetricVec, error). It is recommended to also
add the convenience methods WithLabelValues, With, and MustCurryWith, which
panic instead of returning errors. See also the MetricVec example.

			<pre>type MetricVec struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_MetricVec" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package prometheus_test

import (
    &#34;fmt&#34;

    <span class="comment">//nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.</span>
    &#34;github.com/golang/protobuf/proto&#34;

    dto &#34;github.com/prometheus/client_model/go&#34;

    &#34;github.com/prometheus/client_golang/prometheus&#34;
)

<span class="comment">// Info implements an info pseudo-metric, which is modeled as a Gauge that</span>
<span class="comment">// always has a value of 1. In practice, you would just use a Gauge directly,</span>
<span class="comment">// but for this example, we pretend it would be useful to have a “native”</span>
<span class="comment">// implementation.</span>
type Info struct {
    desc       *prometheus.Desc
    labelPairs []*dto.LabelPair
}

func (i Info) Desc() *prometheus.Desc {
    return i.desc
}

func (i Info) Write(out *dto.Metric) error {
    out.Label = i.labelPairs
    out.Gauge = &amp;dto.Gauge{Value: proto.Float64(1)}
    return nil
}

<span class="comment">// InfoVec is the vector version for Info. As an info metric never changes, we</span>
<span class="comment">// wouldn&#39;t really need to wrap GetMetricWithLabelValues and GetMetricWith</span>
<span class="comment">// because Info has no additional methods compared to the vanilla Metric that</span>
<span class="comment">// the unwrapped MetricVec methods return. However, to demonstrate all there is</span>
<span class="comment">// to do to fully implement a vector for a custom Metric implementation, we do</span>
<span class="comment">// it in this example anyway.</span>
type InfoVec struct {
    *prometheus.MetricVec
}

func NewInfoVec(name, help string, labelNames []string) *InfoVec {
    desc := prometheus.NewDesc(name, help, labelNames, nil)
    return &amp;InfoVec{
        MetricVec: prometheus.NewMetricVec(desc, func(lvs ...string) prometheus.Metric {
            if len(lvs) != len(labelNames) {
                panic(&#34;inconsistent label cardinality&#34;)
            }
            return Info{desc: desc, labelPairs: prometheus.MakeLabelPairs(desc, lvs)}
        }),
    }
}

func (v *InfoVec) GetMetricWithLabelValues(lvs ...string) (Info, error) {
    metric, err := v.MetricVec.GetMetricWithLabelValues(lvs...)
    return metric.(Info), err
}

func (v *InfoVec) GetMetricWith(labels prometheus.Labels) (Info, error) {
    metric, err := v.MetricVec.GetMetricWith(labels)
    return metric.(Info), err
}

func (v *InfoVec) WithLabelValues(lvs ...string) Info {
    i, err := v.GetMetricWithLabelValues(lvs...)
    if err != nil {
        panic(err)
    }
    return i
}

func (v *InfoVec) With(labels prometheus.Labels) Info {
    i, err := v.GetMetricWith(labels)
    if err != nil {
        panic(err)
    }
    return i
}

func (v *InfoVec) CurryWith(labels prometheus.Labels) (*InfoVec, error) {
    vec, err := v.MetricVec.CurryWith(labels)
    if vec != nil {
        return &amp;InfoVec{vec}, err
    }
    return nil, err
}

func (v *InfoVec) MustCurryWith(labels prometheus.Labels) *InfoVec {
    vec, err := v.CurryWith(labels)
    if err != nil {
        panic(err)
    }
    return vec
}

func ExampleMetricVec() {
    infoVec := NewInfoVec(
        &#34;library_version_info&#34;,
        &#34;Versions of the libraries used in this binary.&#34;,
        []string{&#34;library&#34;, &#34;version&#34;},
    )

    infoVec.WithLabelValues(&#34;prometheus/client_golang&#34;, &#34;1.7.1&#34;)
    infoVec.WithLabelValues(&#34;k8s.io/client-go&#34;, &#34;0.18.8&#34;)

    <span class="comment">// Just for demonstration, let&#39;s check the state of the InfoVec by</span>
    <span class="comment">// registering it with a custom registry and then let it collect the</span>
    <span class="comment">// metrics.</span>
    reg := prometheus.NewRegistry()
    reg.MustRegister(infoVec)

    metricFamilies, err := reg.Gather()
    if err != nil || len(metricFamilies) != 1 {
        panic(&#34;unexpected behavior of custom test registry&#34;)
    }
    fmt.Println(proto.MarshalTextString(metricFamilies[0]))

    <span class="comment">// Output:</span>
    <span class="comment">// name: &#34;library_version_info&#34;</span>
    <span class="comment">// help: &#34;Versions of the libraries used in this binary.&#34;</span>
    <span class="comment">// type: GAUGE</span>
    <span class="comment">// metric: &lt;</span>
    <span class="comment">//   label: &lt;</span>
    <span class="comment">//     name: &#34;library&#34;</span>
    <span class="comment">//     value: &#34;k8s.io/client-go&#34;</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">//   label: &lt;</span>
    <span class="comment">//     name: &#34;version&#34;</span>
    <span class="comment">//     value: &#34;0.18.8&#34;</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">//   gauge: &lt;</span>
    <span class="comment">//     value: 1</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">// &gt;</span>
    <span class="comment">// metric: &lt;</span>
    <span class="comment">//   label: &lt;</span>
    <span class="comment">//     name: &#34;library&#34;</span>
    <span class="comment">//     value: &#34;prometheus/client_golang&#34;</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">//   label: &lt;</span>
    <span class="comment">//     name: &#34;version&#34;</span>
    <span class="comment">//     value: &#34;1.7.1&#34;</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">//   gauge: &lt;</span>
    <span class="comment">//     value: 1</span>
    <span class="comment">//   &gt;</span>
    <span class="comment">// &gt;</span>
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewMetricVec">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=1847:1925#L37">NewMetricVec</a>
					<a class="permalink" href="index.html#NewMetricVec">&#xb6;</a>
					
					
				</h3>
				<pre>func NewMetricVec(desc *<a href="index.html#Desc">Desc</a>, newMetric func(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Metric">Metric</a>) *<a href="index.html#MetricVec">MetricVec</a></pre>
				<p>NewMetricVec returns an initialized metricVec.

				
				
			

			
				
				<h3 id="MetricVec.Collect">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=4781:4826#L112">Collect</a>
					<a class="permalink" href="index.html#MetricVec.Collect">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) Collect(ch chan&lt;- <a href="index.html#Metric">Metric</a>)</pre>
				<p>Collect implements Collector.

				
				
				
			
				
				<h3 id="MetricVec.CurryWith">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=6023:6087#L134">CurryWith</a>
					<a class="permalink" href="index.html#MetricVec.CurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) CurryWith(labels <a href="index.html#Labels">Labels</a>) (*<a href="index.html#MetricVec">MetricVec</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>CurryWith returns a vector curried with the provided labels, i.e. the
returned vector has those labels pre-set for all labeled operations performed
on it. The cardinality of the curried vector is reduced accordingly. The
order of the remaining labels stays the same (just with the curried labels
taken out of the sequence – which is relevant for the
(GetMetric)WithLabelValues methods). It is possible to curry a curried
vector, but only with labels not yet used for currying before.
<p>The metrics contained in the MetricVec are shared between the curried and
uncurried vectors. They are just accessed differently. Curried and uncurried
vectors behave identically in terms of collection. Only one must be
registered with a given registry (usually the uncurried version). The Reset
method deletes all metrics, even if called on a curried vector.
<p>Note that CurryWith is usually not called directly but through a wrapper
around MetricVec, implementing a vector for a specific Metric
implementation, for example GaugeVec.

				
				
				
			
				
				<h3 id="MetricVec.Delete">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=3775:3821#L84">Delete</a>
					<a class="permalink" href="index.html#MetricVec.Delete">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) Delete(labels <a href="index.html#Labels">Labels</a>) <a href="../../../../builtin/index.html#bool">bool</a></pre>
				<p>Delete deletes the metric where the variable labels are the same as those
passed in as labels. It returns true if a metric was deleted.
<p>It is not an error if the number and names of the Labels are inconsistent
with those of the VariableLabels in Desc. However, such inconsistent Labels
can never match an actual metric, so the method will always return false in
that case.
<p>This method is used for the same purpose as DeleteLabelValues(...string). See
there for pros and cons of the two methods.

				
				
				
			
				
				<h3 id="MetricVec.DeleteLabelValues">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=3002:3059#L64">DeleteLabelValues</a>
					<a class="permalink" href="index.html#MetricVec.DeleteLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) DeleteLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="../../../../builtin/index.html#bool">bool</a></pre>
				<p>DeleteLabelValues removes the metric where the variable labels are the same
as those passed in as labels (same order as the VariableLabels in Desc). It
returns true if a metric was deleted.
<p>It is not an error if the number of label values is not the same as the
number of VariableLabels in Desc. However, such inconsistent label count can
never match an actual metric, so the method will always return false in that
case.
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider Delete(Labels) as an
alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).
See also the CounterVec example.

				
				
				
			
				
				<h3 id="MetricVec.DeletePartialMatch">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=4379:4436#L100">DeletePartialMatch</a>
					<a class="permalink" href="index.html#MetricVec.DeletePartialMatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) DeletePartialMatch(labels <a href="index.html#Labels">Labels</a>) <a href="../../../../builtin/index.html#int">int</a></pre>
				<p>DeletePartialMatch deletes all metrics where the variable labels contain all of those
passed in as labels. The order of the labels does not matter.
It returns the number of metrics deleted.
<p>Note that curried labels will never be matched if deleting from the curried vector.
To match curried labels with DeletePartialMatch, it must be called on the base vector.

				
				
				
			
				
				<h3 id="MetricVec.Describe">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=4672:4717#L109">Describe</a>
					<a class="permalink" href="index.html#MetricVec.Describe">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) Describe(ch chan&lt;- *<a href="index.html#Desc">Desc</a>)</pre>
				<p>Describe implements Collector.

				
				
				
			
				
				<h3 id="MetricVec.GetMetricWith">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=9568:9632#L220">GetMetricWith</a>
					<a class="permalink" href="index.html#MetricVec.GetMetricWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) GetMetricWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWith returns the Metric for the given Labels map (the label names
must match those of the variable labels in Desc). If that label map is
accessed for the first time, a new Metric is created. Implications of
creating a Metric without using it and keeping the Metric for later use
are the same as for GetMetricWithLabelValues.
<p>An error is returned if the number and names of the Labels are inconsistent
with those of the variable labels in Desc (minus any curried labels).
<p>This method is used for the same purpose as
GetMetricWithLabelValues(...string). See there for pros and cons of the two
methods.
<p>Note that GetMetricWith is usually not called directly but through a wrapper
around MetricVec, implementing a vector for a specific Metric implementation,
for example GaugeVec.

				
				
				
			
				
				<h3 id="MetricVec.GetMetricWithLabelValues">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=8455:8530#L194">GetMetricWithLabelValues</a>
					<a class="permalink" href="index.html#MetricVec.GetMetricWithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Metric">Metric</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWithLabelValues returns the Metric for the given slice of label
values (same order as the variable labels in Desc). If that combination of
label values is accessed for the first time, a new Metric is created (by
calling the newMetric function provided during construction of the
MetricVec).
<p>It is possible to call this method without using the returned Metric to only
create the new Metric but leave it in its initial state.
<p>Keeping the Metric for later use is possible (and should be considered if
performance is critical), but keep in mind that Reset, DeleteLabelValues and
Delete can be used to delete the Metric from the MetricVec. In that case, the
Metric will still exist, but it will not be exported anymore, even if a
Metric with the same label values is created later.
<p>An error is returned if the number of label values is not the same as the
number of variable labels in Desc (minus any curried labels).
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
an alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).
<p>Note that GetMetricWithLabelValues is usually not called directly but through
a wrapper around MetricVec, implementing a vector for a specific Metric
implementation, for example GaugeVec.

				
				
				
			
				
				<h3 id="MetricVec.Reset">func (*MetricVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/vec.go?s=4901:4928#L115">Reset</a>
					<a class="permalink" href="index.html#MetricVec.Reset">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#MetricVec">MetricVec</a>) Reset()</pre>
				<p>Reset deletes all metrics in this vector.

				
				
				
			
		
			
			
			<h2 id="MultiError">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=9193:9216#L205">MultiError</a>
				<a class="permalink" href="index.html#MultiError">&#xb6;</a>
				
				
			</h2>
			<p>MultiError is a slice of errors implementing the error interface. It is used
by a Gatherer to report multiple errors during MetricFamily gathering.

			<pre>type MultiError []<a href="../../../../builtin/index.html#error">error</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="MultiError.Append">func (*MultiError) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=9668:9709#L222">Append</a>
					<a class="permalink" href="index.html#MultiError.Append">&#xb6;</a>
					
					
				</h3>
				<pre>func (errs *<a href="index.html#MultiError">MultiError</a>) Append(err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Append appends the provided error if it is not nil.

				
				
				
			
				
				<h3 id="MultiError.Error">func (MultiError) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=9370:9407#L209">Error</a>
					<a class="permalink" href="index.html#MultiError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (errs <a href="index.html#MultiError">MultiError</a>) Error() <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>Error formats the contained errors as a bullet point list, preceded by the
total number of errors. Note that this results in a multi-line string.

				
				
				
			
				
				<h3 id="MultiError.MaybeUnwrap">func (MultiError) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=10042:10084#L232">MaybeUnwrap</a>
					<a class="permalink" href="index.html#MultiError.MaybeUnwrap">&#xb6;</a>
					
					
				</h3>
				<pre>func (errs <a href="index.html#MultiError">MultiError</a>) MaybeUnwrap() <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>MaybeUnwrap returns nil if len(errs) is 0. It returns the first and only
contained error as error if len(errs is 1). In all other cases, it returns
the MultiError directly. This is helpful for returning a MultiError in a way
that only uses the MultiError if needed.

				
				
				
			
		
			
			
			<h2 id="MultiTRegistry">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=33111:33177#L988">MultiTRegistry</a>
				<a class="permalink" href="index.html#MultiTRegistry">&#xb6;</a>
				
				
			</h2>
			<p>MultiTRegistry is a TransactionalGatherer that joins gathered metrics from multiple
transactional gatherers.
<p>It is caller responsibility to ensure two registries have mutually exclusive metric families,
no deduplication will happen.

			<pre>type MultiTRegistry struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewMultiTRegistry">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=33224:33299#L993">NewMultiTRegistry</a>
					<a class="permalink" href="index.html#NewMultiTRegistry">&#xb6;</a>
					
					
				</h3>
				<pre>func NewMultiTRegistry(tGatherers ...<a href="index.html#TransactionalGatherer">TransactionalGatherer</a>) *<a href="index.html#MultiTRegistry">MultiTRegistry</a></pre>
				<p>NewMultiTRegistry creates MultiTRegistry.

				
				
			

			
				
				<h3 id="MultiTRegistry.Gather">func (*MultiTRegistry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=33413:33496#L1000">Gather</a>
					<a class="permalink" href="index.html#MultiTRegistry.Gather">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#MultiTRegistry">MultiTRegistry</a>) Gather() (mfs []*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, done func(), err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Gather implements TransactionalGatherer interface.

				
				
				
			
		
			
			
			<h2 id="Observer">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go?s=736:781#L8">Observer</a>
				<a class="permalink" href="index.html#Observer">&#xb6;</a>
				
				
			</h2>
			<p>Observer is the interface that wraps the Observe method, which is used by
Histogram and Summary to add observations.

			<pre>type Observer interface {
    Observe(<a href="../../../../builtin/index.html#float64">float64</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ObserverFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go?s=1365:1396#L25">ObserverFunc</a>
				<a class="permalink" href="index.html#ObserverFunc">&#xb6;</a>
				
				
			</h2>
			<p>The ObserverFunc type is an adapter to allow the use of ordinary
functions as Observers. If f is a function with the appropriate
signature, ObserverFunc(f) is an Observer that calls f.
<p>This adapter is usually used in connection with the Timer type, and there are
two general use cases:
<p>The most common one is to use a Gauge as the Observer for a Timer.
See the &quot;Gauge&quot; Timer example.
<p>The more advanced use case is to create a function that dynamically decides
which Observer to use for observing the duration. See the &quot;Complex&quot; Timer
example.

			<pre>type ObserverFunc func(<a href="../../../../builtin/index.html#float64">float64</a>)</pre>

			

			

			
			
			

			

			
				
				<h3 id="ObserverFunc.Observe">func (ObserverFunc) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go?s=1449:1493#L28">Observe</a>
					<a class="permalink" href="index.html#ObserverFunc.Observe">&#xb6;</a>
					
					
				</h3>
				<pre>func (f <a href="index.html#ObserverFunc">ObserverFunc</a>) Observe(value <a href="../../../../builtin/index.html#float64">float64</a>)</pre>
				<p>Observe calls f(value). It implements Observer.

				
				
				
			
		
			
			
			<h2 id="ObserverVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/observer.go?s=1588:1865#L33">ObserverVec</a>
				<a class="permalink" href="index.html#ObserverVec">&#xb6;</a>
				
				
			</h2>
			<p>ObserverVec is an interface implemented by `HistogramVec` and `SummaryVec`.

			<pre>type ObserverVec interface {
    GetMetricWith(<a href="index.html#Labels">Labels</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)
    GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)
    With(<a href="index.html#Labels">Labels</a>) <a href="index.html#Observer">Observer</a>
    WithLabelValues(...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Observer">Observer</a>
    CurryWith(<a href="index.html#Labels">Labels</a>) (<a href="index.html#ObserverVec">ObserverVec</a>, <a href="../../../../builtin/index.html#error">error</a>)
    MustCurryWith(<a href="index.html#Labels">Labels</a>) <a href="index.html#ObserverVec">ObserverVec</a>

    <a href="index.html#Collector">Collector</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Opts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/metric.go?s=2806:3945#L58">Opts</a>
				<a class="permalink" href="index.html#Opts">&#xb6;</a>
				
				
			</h2>
			<p>Opts bundles the options for creating most Metric types. Each metric
implementation XXX has its own XXXOpts type, but in most cases, it is just
an alias of this type (which might change when the requirement arises.)
<p>It is mandatory to set Name to a non-empty string. All other fields are
optional and can safely be left at their zero value, although it is strongly
encouraged to set a Help string.

			<pre>type Opts struct {
<span id="Opts.Namespace"></span>    <span class="comment">// Namespace, Subsystem, and Name are components of the fully-qualified</span>
    <span class="comment">// name of the Metric (created by joining these components with</span>
    <span class="comment">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the</span>
    <span class="comment">// name. Note that the fully-qualified name of the metric must be a</span>
    <span class="comment">// valid Prometheus metric name.</span>
    Namespace <a href="../../../../builtin/index.html#string">string</a>
<span id="Opts.Subsystem"></span>    Subsystem <a href="../../../../builtin/index.html#string">string</a>
<span id="Opts.Name"></span>    Name      <a href="../../../../builtin/index.html#string">string</a>

<span id="Opts.Help"></span>    <span class="comment">// Help provides information about this metric.</span>
    <span class="comment">//</span>
    <span class="comment">// Metrics with the same fully-qualified name must have the same Help</span>
    <span class="comment">// string.</span>
    Help <a href="../../../../builtin/index.html#string">string</a>

<span id="Opts.ConstLabels"></span>    <span class="comment">// ConstLabels are used to attach fixed labels to this metric. Metrics</span>
    <span class="comment">// with the same fully-qualified name must have the same label names in</span>
    <span class="comment">// their ConstLabels.</span>
    <span class="comment">//</span>
    <span class="comment">// ConstLabels are only used rarely. In particular, do not use them to</span>
    <span class="comment">// attach the same labels to all your metrics. Those use cases are</span>
    <span class="comment">// better covered by target labels set by the scraping Prometheus</span>
    <span class="comment">// server, or by one specific metric (e.g. a build_info or a</span>
    <span class="comment">// machine_role metric). See also</span>
    <span class="comment">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels</span>
    ConstLabels <a href="index.html#Labels">Labels</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ProcessCollectorOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/process_collector.go?s=1028:1958#L27">ProcessCollectorOpts</a>
				<a class="permalink" href="index.html#ProcessCollectorOpts">&#xb6;</a>
				
				
			</h2>
			<p>ProcessCollectorOpts defines the behavior of a process metrics collector
created with NewProcessCollector.

			<pre>type ProcessCollectorOpts struct {
<span id="ProcessCollectorOpts.PidFn"></span>    <span class="comment">// PidFn returns the PID of the process the collector collects metrics</span>
    <span class="comment">// for. It is called upon each collection. By default, the PID of the</span>
    <span class="comment">// current process is used, as determined on construction time by</span>
    <span class="comment">// calling os.Getpid().</span>
    PidFn func() (<a href="../../../../builtin/index.html#int">int</a>, <a href="../../../../builtin/index.html#error">error</a>)
    <span class="comment">// If non-empty, each of the collected metrics is prefixed by the</span>
    <span class="comment">// provided string and an underscore (&#34;_&#34;).</span>
<span id="ProcessCollectorOpts.Namespace"></span>    Namespace <a href="../../../../builtin/index.html#string">string</a>
    <span class="comment">// If true, any error encountered during collection is reported as an</span>
    <span class="comment">// invalid metric (see NewInvalidMetric). Otherwise, errors are ignored</span>
    <span class="comment">// and the collected metrics will be incomplete. (Possibly, no metrics</span>
    <span class="comment">// will be collected at all.) While that&#39;s usually not desired, it is</span>
    <span class="comment">// appropriate for the common &#34;mix-in&#34; of process metrics, where process</span>
    <span class="comment">// metrics are nice to have, but failing to collect them should not</span>
    <span class="comment">// disrupt the collection of the remaining metrics.</span>
<span id="ProcessCollectorOpts.ReportErrors"></span>    ReportErrors <a href="../../../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Registerer">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=3573:5633#L86">Registerer</a>
				<a class="permalink" href="index.html#Registerer">&#xb6;</a>
				
				
			</h2>
			<p>Registerer is the interface for the part of a registry in charge of
registering and unregistering. Users of custom registries should use
Registerer as type for registration purposes (rather than the Registry type
directly). In that way, they are free to use custom Registerer implementation
(e.g. for testing purposes).

			<pre>type Registerer interface {
    <span class="comment">// Register registers a new Collector to be included in metrics</span>
    <span class="comment">// collection. It returns an error if the descriptors provided by the</span>
    <span class="comment">// Collector are invalid or if they — in combination with descriptors of</span>
    <span class="comment">// already registered Collectors — do not fulfill the consistency and</span>
    <span class="comment">// uniqueness criteria described in the documentation of metric.Desc.</span>
    <span class="comment">//</span>
    <span class="comment">// If the provided Collector is equal to a Collector already registered</span>
    <span class="comment">// (which includes the case of re-registering the same Collector), the</span>
    <span class="comment">// returned error is an instance of AlreadyRegisteredError, which</span>
    <span class="comment">// contains the previously registered Collector.</span>
    <span class="comment">//</span>
    <span class="comment">// A Collector whose Describe method does not yield any Desc is treated</span>
    <span class="comment">// as unchecked. Registration will always succeed. No check for</span>
    <span class="comment">// re-registering (see previous paragraph) is performed. Thus, the</span>
    <span class="comment">// caller is responsible for not double-registering the same unchecked</span>
    <span class="comment">// Collector, and for providing a Collector that will not cause</span>
    <span class="comment">// inconsistent metrics on collection. (This would lead to scrape</span>
    <span class="comment">// errors.)</span>
    Register(<a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#error">error</a>
    <span class="comment">// MustRegister works like Register but registers any number of</span>
    <span class="comment">// Collectors and panics upon the first registration that causes an</span>
    <span class="comment">// error.</span>
    MustRegister(...<a href="index.html#Collector">Collector</a>)
    <span class="comment">// Unregister unregisters the Collector that equals the Collector passed</span>
    <span class="comment">// in as an argument.  (Two Collectors are considered equal if their</span>
    <span class="comment">// Describe method yields the same set of descriptors.) The function</span>
    <span class="comment">// returns whether a Collector was unregistered. Note that an unchecked</span>
    <span class="comment">// Collector cannot be unregistered (as its Describe method does not</span>
    <span class="comment">// yield any descriptor).</span>
    <span class="comment">//</span>
    <span class="comment">// Note that even after unregistering, it will not be possible to</span>
    <span class="comment">// register a new Collector that is inconsistent with the unregistered</span>
    <span class="comment">// Collector, e.g. a Collector collecting metrics with the same name but</span>
    <span class="comment">// a different help string. The rationale here is that the same registry</span>
    <span class="comment">// instance must only collect consistent metrics throughout its</span>
    <span class="comment">// lifetime.</span>
    Unregister(<a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#bool">bool</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="WrapRegistererWith">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/wrap.go?s=1926:1991#L36">WrapRegistererWith</a>
					<a class="permalink" href="index.html#WrapRegistererWith">&#xb6;</a>
					
					
				</h3>
				<pre>func WrapRegistererWith(labels <a href="index.html#Labels">Labels</a>, reg <a href="index.html#Registerer">Registerer</a>) <a href="index.html#Registerer">Registerer</a></pre>
				<p>WrapRegistererWith returns a Registerer wrapping the provided
Registerer. Collectors registered with the returned Registerer will be
registered with the wrapped Registerer in a modified way. The modified
Collector adds the provided Labels to all Metrics it collects (as
ConstLabels). The Metrics collected by the unmodified Collector must not
duplicate any of those labels. Wrapping a nil value is valid, resulting
in a no-op Registerer.
<p>WrapRegistererWith provides a way to add fixed labels to a subset of
Collectors. It should not be used to add fixed labels to all metrics
exposed. See also
<a href="https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels">https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels</a>
<p>Conflicts between Collectors registered through the original Registerer with
Collectors registered through the wrapping Registerer will still be
detected. Any AlreadyRegisteredError returned by the Register method of
either Registerer will contain the ExistingCollector in the form it was
provided to the respective registry.
<p>The Collector example demonstrates a use of WrapRegistererWith.

				
				
			
				
				<h3 id="WrapRegistererWithPrefix">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/wrap.go?s=3452:3523#L64">WrapRegistererWithPrefix</a>
					<a class="permalink" href="index.html#WrapRegistererWithPrefix">&#xb6;</a>
					
					
				</h3>
				<pre>func WrapRegistererWithPrefix(prefix <a href="../../../../builtin/index.html#string">string</a>, reg <a href="index.html#Registerer">Registerer</a>) <a href="index.html#Registerer">Registerer</a></pre>
				<p>WrapRegistererWithPrefix returns a Registerer wrapping the provided
Registerer. Collectors registered with the returned Registerer will be
registered with the wrapped Registerer in a modified way. The modified
Collector adds the provided prefix to the name of all Metrics it collects.
Wrapping a nil value is valid, resulting in a no-op Registerer.
<p>WrapRegistererWithPrefix is useful to have one place to prefix all metrics of
a sub-system. To make this work, register metrics of the sub-system with the
wrapping Registerer returned by WrapRegistererWithPrefix. It is rarely useful
to use the same prefix for all metrics exposed. In particular, do not prefix
metric names that are standardized across applications, as that would break
horizontal monitoring, for example the metrics provided by the Go collector
(see NewGoCollector) and the process collector (see NewProcessCollector). (In
fact, those metrics are already prefixed with “go_” or “process_”,
respectively.)
<p>Conflicts between Collectors registered through the original Registerer with
Collectors registered through the wrapping Registerer will still be
detected. Any AlreadyRegisteredError returned by the Register method of
either Registerer will contain the ExistingCollector in the form it was
provided to the respective registry.

				
				
			

			
		
			
			
			<h2 id="Registry">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=10600:10883#L250">Registry</a>
				<a class="permalink" href="index.html#Registry">&#xb6;</a>
				
				
			</h2>
			<p>Registry registers Prometheus collectors, collects their metrics, and gathers
them into MetricFamilies for exposition. It implements Registerer, Gatherer,
and Collector. The zero value is not usable. Create instances with
NewRegistry or NewPedanticRegistry.
<p>Registry implements Collector to allow it to be used for creating groups of
metrics. See the Grouping example for how this can be done.

			<pre>type Registry struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Registry_grouping" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Grouping)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Grouping)</span></p>
		<p>This example shows how to use multiple registries for registering and
unregistering groups of metrics.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Create a global registry.</span>
globalReg := prometheus.NewRegistry()

<span class="comment">// Spawn 10 workers, each of which will have their own group of metrics.</span>
for i := 0; i &lt; 10; i++ {
    <span class="comment">// Create a new registry for each worker, which acts as a group of</span>
    <span class="comment">// worker-specific metrics.</span>
    workerReg := prometheus.NewRegistry()
    globalReg.Register(workerReg)

    go func(workerID int) {
        <span class="comment">// Once the worker is done, it can unregister itself.</span>
        defer globalReg.Unregister(workerReg)

        workTime := prometheus.NewCounter(prometheus.CounterOpts{
            Name: &#34;worker_total_work_time_milliseconds&#34;,
            ConstLabels: prometheus.Labels{
                <span class="comment">// Generate a label unique to this worker so its metric doesn&#39;t</span>
                <span class="comment">// collide with the metrics from other workers.</span>
                &#34;worker_id&#34;: fmt.Sprintf(&#34;%d&#34;, workerID),
            },
        })
        workerReg.MustRegister(workTime)

        start := time.Now()
        time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))
        workTime.Add(float64(time.Since(start).Milliseconds()))
    }(i)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewPedanticRegistry">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=3134:3170#L75">NewPedanticRegistry</a>
					<a class="permalink" href="index.html#NewPedanticRegistry">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPedanticRegistry() *<a href="index.html#Registry">Registry</a></pre>
				<p>NewPedanticRegistry returns a registry that checks during collection if each
collected Metric is consistent with its reported Desc, and if the Desc has
actually been registered with the registry. Unchecked Collectors (those whose
Describe method does not yield any descriptors) are excluded from the check.
<p>Usually, a Registry will be happy as long as the union of all collected
Metrics is consistent and valid even if some metrics are not consistent with
their own Desc or a Desc provided by their registered Collector. Well-behaved
Collectors and Metrics will only provide consistent Descs. This Registry is
useful to test the implementation of Collectors and Metrics.

				
				
			
				
				<h3 id="NewRegistry">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=2252:2280#L57">NewRegistry</a>
					<a class="permalink" href="index.html#NewRegistry">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRegistry() *<a href="index.html#Registry">Registry</a></pre>
				<p>NewRegistry creates a new vanilla Registry without any Collectors
pre-registered.

				
				
			

			
				
				<h3 id="Registry.Collect">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=19069:19113#L564">Collect</a>
					<a class="permalink" href="index.html#Registry.Collect">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) Collect(ch chan&lt;- <a href="index.html#Metric">Metric</a>)</pre>
				<p>Collect implements Collector.

				
				
				
			
				
				<h3 id="Registry.Describe">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=18801:18845#L552">Describe</a>
					<a class="permalink" href="index.html#Registry.Describe">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) Describe(ch chan&lt;- *<a href="index.html#Desc">Desc</a>)</pre>
				<p>Describe implements Collector.

				
				
				
			
				
				<h3 id="Registry.Gather">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=14964:15020#L401">Gather</a>
					<a class="permalink" href="index.html#Registry.Gather">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) Gather() ([]*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Gather implements Gatherer.

				
				
				
			
				
				<h3 id="Registry.MustRegister">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=14794:14842#L392">MustRegister</a>
					<a class="permalink" href="index.html#Registry.MustRegister">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) MustRegister(cs ...<a href="index.html#Collector">Collector</a>)</pre>
				<p>MustRegister implements Registerer.

				
				
				
			
				
				<h3 id="Registry.Register">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=10920:10966#L260">Register</a>
					<a class="permalink" href="index.html#Registry.Register">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) Register(c <a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>Register implements Registerer.

				
				
				
			
				
				<h3 id="Registry.Unregister">func (*Registry) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=13975:14022#L355">Unregister</a>
					<a class="permalink" href="index.html#Registry.Unregister">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Registry">Registry</a>) Unregister(c <a href="index.html#Collector">Collector</a>) <a href="../../../../builtin/index.html#bool">bool</a></pre>
				<p>Unregister implements Registerer.

				
				
				
			
		
			
			
			<h2 id="Summary">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=2004:2426#L43">Summary</a>
				<a class="permalink" href="index.html#Summary">&#xb6;</a>
				
				
			</h2>
			<p>A Summary captures individual observations from an event or sample stream and
summarizes them in a manner similar to traditional summary statistics: 1. sum
of observations, 2. observation count, 3. rank estimations.
<p>A typical use-case is the observation of request latencies. By default, a
Summary provides the median, the 90th and the 99th percentile of the latency
as rank estimations. However, the default behavior will change in the
upcoming v1.0.0 of the library. There will be no rank estimations at all by
default. For a sane transition, it is recommended to set the desired rank
estimations explicitly.
<p>Note that the rank estimations cannot be aggregated in a meaningful way with
the Prometheus query language (i.e. you cannot average or add them). If you
need aggregatable quantiles (e.g. you want the 99th percentile latency of all
queries served across all instances of a service), consider the Histogram
metric type. See the Prometheus documentation for more details.
<p>To create Summary instances, use NewSummary.

			<pre>type Summary interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>

    <span class="comment">// Observe adds a single observation to the summary. Observations are</span>
    <span class="comment">// usually positive or zero. Negative observations are accepted but</span>
    <span class="comment">// prevent current versions of Prometheus from properly detecting</span>
    <span class="comment">// counter resets in the sum of observations. See</span>
    <span class="comment">// https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations</span>
    <span class="comment">// for details.</span>
    Observe(<a href="../../../../builtin/index.html#float64">float64</a>)
}</pre>

			

			

			<div id="example_Summary" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">temps := prometheus.NewSummary(prometheus.SummaryOpts{
    Name:       &#34;pond_temperature_celsius&#34;,
    Help:       &#34;The temperature of the frog pond.&#34;,
    Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
})

<span class="comment">// Simulate some observations.</span>
for i := 0; i &lt; 1000; i++ {
    temps.Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)
}

<span class="comment">// Just for demonstration, let&#39;s check the state of the summary by</span>
<span class="comment">// (ab)using its Write method (which is usually only used by Prometheus</span>
<span class="comment">// internally).</span>
metric := &amp;dto.Metric{}
temps.Write(metric)
fmt.Println(proto.MarshalTextString(metric))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">summary: &lt;
  sample_count: 1000
  sample_sum: 29969.50000000001
  quantile: &lt;
    quantile: 0.5
    value: 31.1
  &gt;
  quantile: &lt;
    quantile: 0.9
    value: 41.3
  &gt;
  quantile: &lt;
    quantile: 0.99
    value: 41.9
  &gt;
&gt;
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewSummary">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=7659:7700#L168">NewSummary</a>
					<a class="permalink" href="index.html#NewSummary">&#xb6;</a>
					
					
				</h3>
				<pre>func NewSummary(opts <a href="index.html#SummaryOpts">SummaryOpts</a>) <a href="index.html#Summary">Summary</a></pre>
				<p>NewSummary creates a new Summary based on the provided SummaryOpts.

				
				
			

			
		
			
			
			<h2 id="SummaryOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=3307:6153#L77">SummaryOpts</a>
				<a class="permalink" href="index.html#SummaryOpts">&#xb6;</a>
				
				
			</h2>
			<p>SummaryOpts bundles the options for creating a Summary metric. It is
mandatory to set Name to a non-empty string. While all other fields are
optional and can safely be left at their zero value, it is recommended to set
a help string and to explicitly set the Objectives field to the desired value
as the default value will change in the upcoming v1.0.0 of the library.

			<pre>type SummaryOpts struct {
<span id="SummaryOpts.Namespace"></span>    <span class="comment">// Namespace, Subsystem, and Name are components of the fully-qualified</span>
    <span class="comment">// name of the Summary (created by joining these components with</span>
    <span class="comment">// &#34;_&#34;). Only Name is mandatory, the others merely help structuring the</span>
    <span class="comment">// name. Note that the fully-qualified name of the Summary must be a</span>
    <span class="comment">// valid Prometheus metric name.</span>
    Namespace <a href="../../../../builtin/index.html#string">string</a>
<span id="SummaryOpts.Subsystem"></span>    Subsystem <a href="../../../../builtin/index.html#string">string</a>
<span id="SummaryOpts.Name"></span>    Name      <a href="../../../../builtin/index.html#string">string</a>

<span id="SummaryOpts.Help"></span>    <span class="comment">// Help provides information about this Summary.</span>
    <span class="comment">//</span>
    <span class="comment">// Metrics with the same fully-qualified name must have the same Help</span>
    <span class="comment">// string.</span>
    Help <a href="../../../../builtin/index.html#string">string</a>

<span id="SummaryOpts.ConstLabels"></span>    <span class="comment">// ConstLabels are used to attach fixed labels to this metric. Metrics</span>
    <span class="comment">// with the same fully-qualified name must have the same label names in</span>
    <span class="comment">// their ConstLabels.</span>
    <span class="comment">//</span>
    <span class="comment">// Due to the way a Summary is represented in the Prometheus text format</span>
    <span class="comment">// and how it is handled by the Prometheus server internally, “quantile”</span>
    <span class="comment">// is an illegal label name. Construction of a Summary or SummaryVec</span>
    <span class="comment">// will panic if this label name is used in ConstLabels.</span>
    <span class="comment">//</span>
    <span class="comment">// ConstLabels are only used rarely. In particular, do not use them to</span>
    <span class="comment">// attach the same labels to all your metrics. Those use cases are</span>
    <span class="comment">// better covered by target labels set by the scraping Prometheus</span>
    <span class="comment">// server, or by one specific metric (e.g. a build_info or a</span>
    <span class="comment">// machine_role metric). See also</span>
    <span class="comment">// https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels</span>
    ConstLabels <a href="index.html#Labels">Labels</a>

<span id="SummaryOpts.Objectives"></span>    <span class="comment">// Objectives defines the quantile rank estimates with their respective</span>
    <span class="comment">// absolute error. If Objectives[q] = e, then the value reported for q</span>
    <span class="comment">// will be the φ-quantile value for some φ between q-e and q+e.  The</span>
    <span class="comment">// default value is an empty map, resulting in a summary without</span>
    <span class="comment">// quantiles.</span>
    Objectives map[<a href="../../../../builtin/index.html#float64">float64</a>]<a href="../../../../builtin/index.html#float64">float64</a>

<span id="SummaryOpts.MaxAge"></span>    <span class="comment">// MaxAge defines the duration for which an observation stays relevant</span>
    <span class="comment">// for the summary. Only applies to pre-calculated quantiles, does not</span>
    <span class="comment">// apply to _sum and _count. Must be positive. The default value is</span>
    <span class="comment">// DefMaxAge.</span>
    MaxAge <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Duration">Duration</a>

<span id="SummaryOpts.AgeBuckets"></span>    <span class="comment">// AgeBuckets is the number of buckets used to exclude observations that</span>
    <span class="comment">// are older than MaxAge from the summary. A higher number has a</span>
    <span class="comment">// resource penalty, so only increase it if the higher resolution is</span>
    <span class="comment">// really required. For very high observation rates, you might want to</span>
    <span class="comment">// reduce the number of age buckets. With only one age bucket, you will</span>
    <span class="comment">// effectively see a complete reset of the summary each time MaxAge has</span>
    <span class="comment">// passed. The default value is DefAgeBuckets.</span>
    AgeBuckets <a href="../../../../builtin/index.html#uint32">uint32</a>

<span id="SummaryOpts.BufCap"></span>    <span class="comment">// BufCap defines the default sample stream buffer size.  The default</span>
    <span class="comment">// value of DefBufCap should suffice for most uses. If there is a need</span>
    <span class="comment">// to increase the value, a multiple of 500 is recommended (because that</span>
    <span class="comment">// is the internal buffer size of the underlying package</span>
    <span class="comment">// &#34;github.com/bmizerany/perks/quantile&#34;).</span>
    BufCap <a href="../../../../builtin/index.html#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="SummaryVec">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=17441:17479#L523">SummaryVec</a>
				<a class="permalink" href="index.html#SummaryVec">&#xb6;</a>
				
				
			</h2>
			<p>SummaryVec is a Collector that bundles a set of Summaries that all share the
same Desc, but have different values for their variable labels. This is used
if you want to count the same thing partitioned by various dimensions
(e.g. HTTP request latencies, partitioned by status code and method). Create
instances with NewSummaryVec.

			<pre>type SummaryVec struct {
    *<a href="index.html#MetricVec">MetricVec</a>
}
</pre>

			

			

			<div id="example_SummaryVec" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">temps := prometheus.NewSummaryVec(
    prometheus.SummaryOpts{
        Name:       &#34;pond_temperature_celsius&#34;,
        Help:       &#34;The temperature of the frog pond.&#34;,
        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
    },
    []string{&#34;species&#34;},
)

<span class="comment">// Simulate some observations.</span>
for i := 0; i &lt; 1000; i++ {
    temps.WithLabelValues(&#34;litoria-caerulea&#34;).Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)
    temps.WithLabelValues(&#34;lithobates-catesbeianus&#34;).Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)
}

<span class="comment">// Create a Summary without any observations.</span>
temps.WithLabelValues(&#34;leiopelma-hochstetteri&#34;)

<span class="comment">// Just for demonstration, let&#39;s check the state of the summary vector</span>
<span class="comment">// by registering it with a custom registry and then let it collect the</span>
<span class="comment">// metrics.</span>
reg := prometheus.NewRegistry()
reg.MustRegister(temps)

metricFamilies, err := reg.Gather()
if err != nil || len(metricFamilies) != 1 {
    panic(&#34;unexpected behavior of custom test registry&#34;)
}
fmt.Println(proto.MarshalTextString(metricFamilies[0]))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">name: &#34;pond_temperature_celsius&#34;
help: &#34;The temperature of the frog pond.&#34;
type: SUMMARY
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;leiopelma-hochstetteri&#34;
  &gt;
  summary: &lt;
    sample_count: 0
    sample_sum: 0
    quantile: &lt;
      quantile: 0.5
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: nan
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: nan
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;lithobates-catesbeianus&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 31956.100000000017
    quantile: &lt;
      quantile: 0.5
      value: 32.4
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.4
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
metric: &lt;
  label: &lt;
    name: &#34;species&#34;
    value: &#34;litoria-caerulea&#34;
  &gt;
  summary: &lt;
    sample_count: 1000
    sample_sum: 29969.50000000001
    quantile: &lt;
      quantile: 0.5
      value: 31.1
    &gt;
    quantile: &lt;
      quantile: 0.9
      value: 41.3
    &gt;
    quantile: &lt;
      quantile: 0.99
      value: 41.9
    &gt;
  &gt;
&gt;
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewSummaryVec">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=17837:17906#L533">NewSummaryVec</a>
					<a class="permalink" href="index.html#NewSummaryVec">&#xb6;</a>
					
					
				</h3>
				<pre>func NewSummaryVec(opts <a href="index.html#SummaryOpts">SummaryOpts</a>, labelNames []<a href="../../../../builtin/index.html#string">string</a>) *<a href="index.html#SummaryVec">SummaryVec</a></pre>
				<p>NewSummaryVec creates a new SummaryVec based on the provided SummaryOpts and
partitioned by the given label names.
<p>Due to the way a Summary is represented in the Prometheus text format and how
it is handled by the Prometheus server internally, “quantile” is an illegal
label name. NewSummaryVec will panic if this label name is used.

				
				
			

			
				
				<h3 id="SummaryVec.CurryWith">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=22679:22745#L650">CurryWith</a>
					<a class="permalink" href="index.html#SummaryVec.CurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) CurryWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#ObserverVec">ObserverVec</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>CurryWith returns a vector curried with the provided labels, i.e. the
returned vector has those labels pre-set for all labeled operations performed
on it. The cardinality of the curried vector is reduced accordingly. The
order of the remaining labels stays the same (just with the curried labels
taken out of the sequence – which is relevant for the
(GetMetric)WithLabelValues methods). It is possible to curry a curried
vector, but only with labels not yet used for currying before.
<p>The metrics contained in the SummaryVec are shared between the curried and
uncurried vectors. They are just accessed differently. Curried and uncurried
vectors behave identically in terms of collection. Only one must be
registered with a given registry (usually the uncurried version). The Reset
method deletes all metrics, even if called on a curried vector.

				
				
				
			
				
				<h3 id="SummaryVec.GetMetricWith">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=20847:20914#L604">GetMetricWith</a>
					<a class="permalink" href="index.html#SummaryVec.GetMetricWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) GetMetricWith(labels <a href="index.html#Labels">Labels</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWith returns the Summary for the given Labels map (the label names
must match those of the variable labels in Desc). If that label map is
accessed for the first time, a new Summary is created. Implications of
creating a Summary without using it and keeping the Summary for later use are
the same as for GetMetricWithLabelValues.
<p>An error is returned if the number and names of the Labels are inconsistent
with those of the variable labels in Desc (minus any curried labels).
<p>This method is used for the same purpose as
GetMetricWithLabelValues(...string). See there for pros and cons of the two
methods.

				
				
				
			
				
				<h3 id="SummaryVec.GetMetricWithLabelValues">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=19981:20059#L584">GetMetricWithLabelValues</a>
					<a class="permalink" href="index.html#SummaryVec.GetMetricWithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) GetMetricWithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) (<a href="index.html#Observer">Observer</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>GetMetricWithLabelValues returns the Summary for the given slice of label
values (same order as the variable labels in Desc). If that combination of
label values is accessed for the first time, a new Summary is created.
<p>It is possible to call this method without using the returned Summary to only
create the new Summary but leave it at its starting value, a Summary without
any observations.
<p>Keeping the Summary for later use is possible (and should be considered if
performance is critical), but keep in mind that Reset, DeleteLabelValues and
Delete can be used to delete the Summary from the SummaryVec. In that case,
the Summary will still exist, but it will not be exported anymore, even if a
Summary with the same label values is created later. See also the CounterVec
example.
<p>An error is returned if the number of label values is not the same as the
number of variable labels in Desc (minus any curried labels).
<p>Note that for more than one label value, this method is prone to mistakes
caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
an alternative to avoid that type of mistake. For higher label numbers, the
latter has a much more readable (albeit more verbose) syntax, but it comes
with a performance overhead (for creating and processing the Labels map).
See also the GaugeVec example.

				
				
				
			
				
				<h3 id="SummaryVec.MustCurryWith">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=22958:23019#L660">MustCurryWith</a>
					<a class="permalink" href="index.html#SummaryVec.MustCurryWith">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) MustCurryWith(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#ObserverVec">ObserverVec</a></pre>
				<p>MustCurryWith works as CurryWith but panics where CurryWith would have
returned an error.

				
				
				
			
				
				<h3 id="SummaryVec.With">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=21661:21710#L629">With</a>
					<a class="permalink" href="index.html#SummaryVec.With">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) With(labels <a href="index.html#Labels">Labels</a>) <a href="index.html#Observer">Observer</a></pre>
				<p>With works as GetMetricWith, but panics where GetMetricWithLabels would have
returned an error. Not returning an error allows shortcuts like
<pre>myVec.With(prometheus.Labels{&quot;code&quot;: &quot;404&quot;, &quot;method&quot;: &quot;GET&quot;}).Observe(42.21)
</pre>

				
				
				
			
				
				<h3 id="SummaryVec.WithLabelValues">func (*SummaryVec) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=21276:21336#L617">WithLabelValues</a>
					<a class="permalink" href="index.html#SummaryVec.WithLabelValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#SummaryVec">SummaryVec</a>) WithLabelValues(lvs ...<a href="../../../../builtin/index.html#string">string</a>) <a href="index.html#Observer">Observer</a></pre>
				<p>WithLabelValues works as GetMetricWithLabelValues, but panics where
GetMetricWithLabelValues would have returned an error. Not returning an
error allows shortcuts like
<pre>myVec.WithLabelValues(&quot;404&quot;, &quot;GET&quot;).Observe(42.21)
</pre>

				
				
				
			
		
			
			
			<h2 id="SummaryVecOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/summary.go?s=6370:6633#L143">SummaryVecOpts</a>
				<a class="permalink" href="index.html#SummaryVecOpts">&#xb6;</a>
				
				
			</h2>
			<p>SummaryVecOpts bundles the options to create a SummaryVec metric.
It is mandatory to set SummaryOpts, see there for mandatory fields. VariableLabels
is optional and can safely be left to its default value.

			<pre>type SummaryVecOpts struct {
    <a href="index.html#SummaryOpts">SummaryOpts</a>

<span id="SummaryVecOpts.VariableLabels"></span>    <span class="comment">// VariableLabels are used to partition the metric vector by the given set</span>
    <span class="comment">// of labels. Each label value will be constrained with the optional Contraint</span>
    <span class="comment">// function, if provided.</span>
    VariableLabels <a href="index.html#ConstrainableLabels">ConstrainableLabels</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Timer">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/timer.go?s=714:774#L10">Timer</a>
				<a class="permalink" href="index.html#Timer">&#xb6;</a>
				
				
			</h2>
			<p>Timer is a helper type to time functions. Use NewTimer to create new
instances.

			<pre>type Timer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Timer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package prometheus_test

import (
    &#34;math/rand&#34;
    &#34;time&#34;

    &#34;github.com/prometheus/client_golang/prometheus&#34;
)

var requestDuration = prometheus.NewHistogram(prometheus.HistogramOpts{
    Name:    &#34;example_request_duration_seconds&#34;,
    Help:    &#34;Histogram for the runtime of a simple example function.&#34;,
    Buckets: prometheus.LinearBuckets(0.01, 0.01, 10),
})

func ExampleTimer() {
    <span class="comment">// timer times this example function. It uses a Histogram, but a Summary</span>
    <span class="comment">// would also work, as both implement Observer. Check out</span>
    <span class="comment">// https://prometheus.io/docs/practices/histograms/ for differences.</span>
    timer := prometheus.NewTimer(requestDuration)
    defer timer.ObserveDuration()

    <span class="comment">// Do something here that takes time.</span>
    time.Sleep(time.Duration(rand.NormFloat64()*10000+50000) * time.Microsecond)
}
</pre>
			
		
	</div>
</div>
<div id="example_Timer_complex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Complex)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Complex)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package prometheus_test

import (
    &#34;net/http&#34;

    &#34;github.com/prometheus/client_golang/prometheus&#34;
)

<span class="comment">// apiRequestDuration tracks the duration separate for each HTTP status</span>
<span class="comment">// class (1xx, 2xx, ...). This creates a fair amount of time series on</span>
<span class="comment">// the Prometheus server. Usually, you would track the duration of</span>
<span class="comment">// serving HTTP request without partitioning by outcome. Do something</span>
<span class="comment">// like this only if needed. Also note how only status classes are</span>
<span class="comment">// tracked, not every single status code. The latter would create an</span>
<span class="comment">// even larger amount of time series. Request counters partitioned by</span>
<span class="comment">// status code are usually OK as each counter only creates one time</span>
<span class="comment">// series. Histograms are way more expensive, so partition with care and</span>
<span class="comment">// only where you really need separate latency tracking. Partitioning by</span>
<span class="comment">// status class is only an example. In concrete cases, other partitions</span>
<span class="comment">// might make more sense.</span>
var apiRequestDuration = prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;api_request_duration_seconds&#34;,
        Help:    &#34;Histogram for the request duration of the public API, partitioned by status class.&#34;,
        Buckets: prometheus.ExponentialBuckets(0.1, 1.5, 5),
    },
    []string{&#34;status_class&#34;},
)

func handler(w http.ResponseWriter, r *http.Request) {
    status := http.StatusOK
    <span class="comment">// The ObserverFunc gets called by the deferred ObserveDuration and</span>
    <span class="comment">// decides which Histogram&#39;s Observe method is called.</span>
    timer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) {
        switch {
        case status &gt;= 500: <span class="comment">// Server error.</span>
            apiRequestDuration.WithLabelValues(&#34;5xx&#34;).Observe(v)
        case status &gt;= 400: <span class="comment">// Client error.</span>
            apiRequestDuration.WithLabelValues(&#34;4xx&#34;).Observe(v)
        case status &gt;= 300: <span class="comment">// Redirection.</span>
            apiRequestDuration.WithLabelValues(&#34;3xx&#34;).Observe(v)
        case status &gt;= 200: <span class="comment">// Success.</span>
            apiRequestDuration.WithLabelValues(&#34;2xx&#34;).Observe(v)
        default: <span class="comment">// Informational.</span>
            apiRequestDuration.WithLabelValues(&#34;1xx&#34;).Observe(v)
        }
    }))
    defer timer.ObserveDuration()

    <span class="comment">// Handle the request. Set status accordingly.</span>
    <span class="comment">// ...</span>
}

func ExampleTimer_complex() {
    http.HandleFunc(&#34;/api&#34;, handler)
}
</pre>
			
		
	</div>
</div>
<div id="example_Timer_gauge" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Gauge)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Gauge)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package prometheus_test

import (
    &#34;os&#34;

    &#34;github.com/prometheus/client_golang/prometheus&#34;
)

<span class="comment">// If a function is called rarely (i.e. not more often than scrapes</span>
<span class="comment">// happen) or ideally only once (like in a batch job), it can make sense</span>
<span class="comment">// to use a Gauge for timing the function call. For timing a batch job</span>
<span class="comment">// and pushing the result to a Pushgateway, see also the comprehensive</span>
<span class="comment">// example in the push package.</span>
var funcDuration = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: &#34;example_function_duration_seconds&#34;,
    Help: &#34;Duration of the last call of an example function.&#34;,
})

func run() error {
    <span class="comment">// The Set method of the Gauge is used to observe the duration.</span>
    timer := prometheus.NewTimer(prometheus.ObserverFunc(funcDuration.Set))
    defer timer.ObserveDuration()

    <span class="comment">// Do something. Return errors as encountered. The use of &#39;defer&#39; above</span>
    <span class="comment">// makes sure the function is still timed properly.</span>
    return nil
}

func ExampleTimer_gauge() {
    if err := run(); err != nil {
        os.Exit(1)
    }
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewTimer">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/timer.go?s=1349:1381#L34">NewTimer</a>
					<a class="permalink" href="index.html#NewTimer">&#xb6;</a>
					
					
				</h3>
				<pre>func NewTimer(o <a href="index.html#Observer">Observer</a>) *<a href="index.html#Timer">Timer</a></pre>
				<p>NewTimer creates a new Timer. The provided Observer is used to observe a
duration in seconds. If the Observer implements ExemplarObserver, passing exemplar
later on will be also supported.
Timer is usually used to time a function call in the
following way:
<pre>func TimeMe() {
    timer := NewTimer(myHistogram)
    defer timer.ObserveDuration()
    // Do actual work.
}
</pre>
<p>or
<pre>func TimeMeWithExemplar() {
	    timer := NewTimer(myHistogram)
	    defer timer.ObserveDurationWithExemplar(exemplar)
	    // Do actual work.
	}
</pre>

				
				
			

			
				
				<h3 id="Timer.ObserveDuration">func (*Timer) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/timer.go?s=1870:1917#L49">ObserveDuration</a>
					<a class="permalink" href="index.html#Timer.ObserveDuration">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Timer">Timer</a>) ObserveDuration() <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Duration">Duration</a></pre>
				<p>ObserveDuration records the duration passed since the Timer was created with
NewTimer. It calls the Observe method of the Observer provided during
construction with the duration in seconds as an argument. The observed
duration is also returned. ObserveDuration is usually called with a defer
statement.
<p>Note that this method is only guaranteed to never observe negative durations
if used with Go1.9+.

				
				
				
			
				
				<h3 id="Timer.ObserveDurationWithExemplar">func (*Timer) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/timer.go?s=2215:2289#L60">ObserveDurationWithExemplar</a>
					<a class="permalink" href="index.html#Timer.ObserveDurationWithExemplar">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#Timer">Timer</a>) ObserveDurationWithExemplar(exemplar <a href="index.html#Labels">Labels</a>) <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Duration">Duration</a></pre>
				<p>ObserveDurationWithExemplar is like ObserveDuration, but it will also
observe exemplar with the duration unless exemplar is nil or provided Observer can&apos;t
be casted to ExemplarObserver.

				
				
				
			
		
			
			
			<h2 id="TransactionalGatherer">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=34266:35691#L1027">TransactionalGatherer</a>
				<a class="permalink" href="index.html#TransactionalGatherer">&#xb6;</a>
				
				
			</h2>
			<p>TransactionalGatherer represents transactional gatherer that can be triggered to notify gatherer that memory
used by metric family is no longer used by a caller. This allows implementations with cache.

			<pre>type TransactionalGatherer interface {
    <span class="comment">// Gather returns metrics in a lexicographically sorted slice</span>
    <span class="comment">// of uniquely named MetricFamily protobufs. Gather ensures that the</span>
    <span class="comment">// returned slice is valid and self-consistent so that it can be used</span>
    <span class="comment">// for valid exposition. As an exception to the strict consistency</span>
    <span class="comment">// requirements described for metric.Desc, Gather will tolerate</span>
    <span class="comment">// different sets of label names for metrics of the same metric family.</span>
    <span class="comment">//</span>
    <span class="comment">// Even if an error occurs, Gather attempts to gather as many metrics as</span>
    <span class="comment">// possible. Hence, if a non-nil error is returned, the returned</span>
    <span class="comment">// MetricFamily slice could be nil (in case of a fatal error that</span>
    <span class="comment">// prevented any meaningful metric collection) or contain a number of</span>
    <span class="comment">// MetricFamily protobufs, some of which might be incomplete, and some</span>
    <span class="comment">// might be missing altogether. The returned error (which might be a</span>
    <span class="comment">// MultiError) explains the details. Note that this is mostly useful for</span>
    <span class="comment">// debugging purposes. If the gathered protobufs are to be used for</span>
    <span class="comment">// exposition in actual monitoring, it is almost always better to not</span>
    <span class="comment">// expose an incomplete result and instead disregard the returned</span>
    <span class="comment">// MetricFamily protobufs in case the returned error is non-nil.</span>
    <span class="comment">//</span>
    <span class="comment">// Important: done is expected to be triggered (even if the error occurs!)</span>
    <span class="comment">// once caller does not need returned slice of dto.MetricFamily.</span>
    Gather() (_ []*<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricFamily">MetricFamily</a>, done func(), err <a href="../../../../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="ToTransactionalGatherer">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/registry.go?s=35789:35851#L1053">ToTransactionalGatherer</a>
					<a class="permalink" href="index.html#ToTransactionalGatherer">&#xb6;</a>
					
					
				</h3>
				<pre>func ToTransactionalGatherer(g <a href="index.html#Gatherer">Gatherer</a>) <a href="index.html#TransactionalGatherer">TransactionalGatherer</a></pre>
				<p>ToTransactionalGatherer transforms Gatherer to transactional one with noop as done function.

				
				
			

			
		
			
			
			<h2 id="UnconstrainedLabels">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/labels.go?s=2697:2730#L83">UnconstrainedLabels</a>
				<a class="permalink" href="index.html#UnconstrainedLabels">&#xb6;</a>
				
				
			</h2>
			<p>UnconstrainedLabels represents collection of label without any constraint on
their value. Thus, it is simply a collection of label names.
<pre>UnconstrainedLabels([]string{ &quot;A&quot;, &quot;B&quot; })
</pre>
<p>is equivalent to
<pre>ConstrainedLabels {
  { Name: &quot;A&quot; },
  { Name: &quot;B&quot; },
}
</pre>

			<pre>type UnconstrainedLabels []<a href="../../../../builtin/index.html#string">string</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="UntypedFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/untyped.go?s=917:966#L14">UntypedFunc</a>
				<a class="permalink" href="index.html#UntypedFunc">&#xb6;</a>
				
				
			</h2>
			<p>UntypedFunc works like GaugeFunc but the collected metric is of type
&quot;Untyped&quot;. UntypedFunc is useful to mirror an external metric of unknown
type.
<p>To create UntypedFunc instances, use NewUntypedFunc.

			<pre>type UntypedFunc interface {
    <a href="index.html#Metric">Metric</a>
    <a href="index.html#Collector">Collector</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewUntypedFunc">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/untyped.go?s=1393:1467#L25">NewUntypedFunc</a>
					<a class="permalink" href="index.html#NewUntypedFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewUntypedFunc(opts <a href="index.html#UntypedOpts">UntypedOpts</a>, function func() <a href="../../../../builtin/index.html#float64">float64</a>) <a href="index.html#UntypedFunc">UntypedFunc</a></pre>
				<p>NewUntypedFunc creates a new UntypedFunc based on the provided
UntypedOpts. The value reported is determined by calling the given function
from within the Write method. Take into account that metric collection may
happen concurrently. If that results in concurrent calls to Write, like in
the case where an UntypedFunc is directly registered with Prometheus, the
provided function must be concurrency-safe.

				
				
			

			
		
			
			
			<h2 id="UntypedOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/untyped.go?s=678:699#L7">UntypedOpts</a>
				<a class="permalink" href="index.html#UntypedOpts">&#xb6;</a>
				
				
			</h2>
			<p>UntypedOpts is an alias for Opts. See there for doc comments.

			<pre>type UntypedOpts <a href="index.html#Opts">Opts</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ValueType">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go?s=938:956#L20">ValueType</a>
				<a class="permalink" href="index.html#ValueType">&#xb6;</a>
				
				
			</h2>
			<p>ValueType is an enumeration of metric types that represent a simple value.

			<pre>type ValueType <a href="../../../../builtin/index.html#int">int</a></pre>

			
				<p>Possible values for the ValueType enum. Use UntypedValue to mark a metric
with an unknown type.

				<pre>const (
    <span id="CounterValue">CounterValue</span> <a href="index.html#ValueType">ValueType</a>
    <span id="GaugeValue">GaugeValue</span>
    <span id="UntypedValue">UntypedValue</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="ValueType.ToDTO">func (ValueType) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/value.go?s=1414:1456#L37">ToDTO</a>
					<a class="permalink" href="index.html#ValueType.ToDTO">&#xb6;</a>
					
					
				</h3>
				<pre>func (v <a href="index.html#ValueType">ValueType</a>) ToDTO() *<a href="../../client_model/go/index.html">dto</a>.<a href="../../client_model/go/index.html#MetricType">MetricType</a></pre>
				
				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="collectors/index.html">collectors</a>
					</td>
				
					<td class="pkg-synopsis">
						Package collectors provides implementations of prometheus.Collector to conveniently collect process and Go-related metrics.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="graphite/index.html">graphite</a>
					</td>
				
					<td class="pkg-synopsis">
						Package graphite provides a bridge to push Prometheus metrics to a Graphite server.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="promauto/index.html">promauto</a>
					</td>
				
					<td class="pkg-synopsis">
						Package promauto provides alternative constructors for the fundamental Prometheus metric types and their …Vec and …Func variants.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="promhttp/index.html">promhttp</a>
					</td>
				
					<td class="pkg-synopsis">
						Package promhttp provides tooling around HTTP servers and clients.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="push/index.html">push</a>
					</td>
				
					<td class="pkg-synopsis">
						Package push provides functions to push metrics to a Pushgateway.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="testutil/index.html">testutil</a>
					</td>
				
					<td class="pkg-synopsis">
						Package testutil provides helpers to test code using the prometheus package of client_golang.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="testutil/promlint/index.html">promlint</a>
					</td>
				
					<td class="pkg-synopsis">
						Package promlint provides a linter for Prometheus metrics.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
