<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>promhttp - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package promhttp
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/prometheus/client_golang/prometheus/promhttp"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package promhttp provides tooling around HTTP servers and clients.
<p>First, the package allows the creation of http.Handler instances to expose
Prometheus metrics via HTTP. promhttp.Handler acts on the
prometheus.DefaultGatherer. With HandlerFor, you can create a handler for a
custom registry or anything that implements the Gatherer interface. It also
allows the creation of handlers that act differently on errors or allow to
log errors.
<p>Second, the package provides tooling to instrument instances of http.Handler
via middleware. Middleware wrappers follow the naming scheme
InstrumentHandlerX, where X describes the intended use of the middleware.
See each function&apos;s doc comment for specific details.
<p>Finally, the package allows for an http.RoundTripper to be instrumented via
middleware. Middleware wrappers follow the naming scheme
InstrumentRoundTripperX, where X describes the intended use of the
middleware. See each function&apos;s doc comment for specific details.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#Handler">func Handler() http.Handler</a></dd>
			
				
				<dd><a href="index.html#HandlerFor">func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler</a></dd>
			
				
				<dd><a href="index.html#HandlerForTransactional">func HandlerForTransactional(reg prometheus.TransactionalGatherer, opts HandlerOpts) http.Handler</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerCounter">func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler, opts ...Option) http.HandlerFunc</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerDuration">func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerInFlight">func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerRequestSize">func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerResponseSize">func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.Handler</a></dd>
			
				
				<dd><a href="index.html#InstrumentHandlerTimeToWriteHeader">func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc</a></dd>
			
				
				<dd><a href="index.html#InstrumentMetricHandler">func InstrumentMetricHandler(reg prometheus.Registerer, handler http.Handler) http.Handler</a></dd>
			
			
				
				<dd><a href="index.html#HandlerErrorHandling">type HandlerErrorHandling</a></dd>
				
				
			
				
				<dd><a href="index.html#HandlerOpts">type HandlerOpts</a></dd>
				
				
			
				
				<dd><a href="index.html#InstrumentTrace">type InstrumentTrace</a></dd>
				
				
			
				
				<dd><a href="index.html#LabelValueFromCtx">type LabelValueFromCtx</a></dd>
				
				
			
				
				<dd><a href="index.html#Logger">type Logger</a></dd>
				
				
			
				
				<dd><a href="index.html#Option">type Option</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WithExemplarFromContext">func WithExemplarFromContext(getExemplarFn func(requestCtx context.Context) prometheus.Labels) Option</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WithExtraMethods">func WithExtraMethods(methods ...string) Option</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WithLabelFromCtx">func WithLabelFromCtx(name string, valueFn LabelValueFromCtx) Option</a></dd>
				
				
			
				
				<dd><a href="index.html#RoundTripperFunc">type RoundTripperFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#InstrumentRoundTripperCounter">func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.RoundTripper, opts ...Option) RoundTripperFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#InstrumentRoundTripperDuration">func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundTripper, opts ...Option) RoundTripperFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#InstrumentRoundTripperInFlight">func InstrumentRoundTripperInFlight(gauge prometheus.Gauge, next http.RoundTripper) RoundTripperFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#InstrumentRoundTripperTrace">func InstrumentRoundTripperTrace(it *InstrumentTrace, next http.RoundTripper) RoundTripperFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RoundTripperFunc.RoundTrip">func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_InstrumentHandlerDuration">InstrumentHandlerDuration</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_InstrumentRoundTripperDuration">InstrumentRoundTripperDuration</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/delegator.go">delegator.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go">http.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go">instrument_client.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go">instrument_server.go</a>
			
				<a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go">option.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="Handler">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=2891:2918#L65">Handler</a>
				<a class="permalink" href="index.html#Handler">&#xb6;</a>
				
				
			</h2>
			<pre>func Handler() <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>Handler returns an http.Handler for the prometheus.DefaultGatherer, using
default HandlerOpts, i.e. it reports the first error as an HTTP error, it has
no error logging, and it applies compression if requested by the client.
<p>The returned http.Handler is already instrumented using the
InstrumentMetricHandler function and the prometheus.DefaultRegisterer. If you
create multiple http.Handlers by separate calls of the Handler function, the
metrics used for instrumentation will be shared between them, providing
global scrape counts.
<p>This function is meant to cover the bulk of basic use cases. If you are doing
anything that requires more customization (including using a non-default
Gatherer, different instrumentation, and non-default HandlerOpts), use the
HandlerFor function. See there for details.

			
			

		
			
			
			<h2 id="HandlerFor">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=3479:3550#L77">HandlerFor</a>
				<a class="permalink" href="index.html#HandlerFor">&#xb6;</a>
				
				
			</h2>
			<pre>func HandlerFor(reg <a href="../index.html">prometheus</a>.<a href="../index.html#Gatherer">Gatherer</a>, opts <a href="index.html#HandlerOpts">HandlerOpts</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>HandlerFor returns an uninstrumented http.Handler for the provided
Gatherer. The behavior of the Handler is defined by the provided
HandlerOpts. Thus, HandlerFor is useful to create http.Handlers for custom
Gatherers, with non-default HandlerOpts, and/or with custom (or no)
instrumentation. Use the InstrumentMetricHandler function to apply the same
kind of instrumentation as it is used by the Handler function.

			
			

		
			
			
			<h2 id="HandlerForTransactional">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=3849:3946#L84">HandlerForTransactional</a>
				<a class="permalink" href="index.html#HandlerForTransactional">&#xb6;</a>
				
				
			</h2>
			<pre>func HandlerForTransactional(reg <a href="../index.html">prometheus</a>.<a href="../index.html#TransactionalGatherer">TransactionalGatherer</a>, opts <a href="index.html#HandlerOpts">HandlerOpts</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>HandlerForTransactional is like HandlerFor, but it uses transactional gather, which
can safely change in-place returned *dto.MetricFamily before call to `Gather` and after
call to `done` of that `Gather`.

			
			

		
			
			
			<h2 id="InstrumentHandlerCounter">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=4906:5019#L105">InstrumentHandlerCounter</a>
				<a class="permalink" href="index.html#InstrumentHandlerCounter">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerCounter(counter *<a href="../index.html">prometheus</a>.<a href="../index.html#CounterVec">CounterVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>, opts ...<a href="index.html#Option">Option</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#HandlerFunc">HandlerFunc</a></pre>
			<p>InstrumentHandlerCounter is a middleware that wraps the provided http.Handler
to observe the request result with the provided CounterVec. The CounterVec
must have valid metric and label names and must have zero, one, or two
non-const non-curried labels. For those, the only allowed label names are
&quot;code&quot; and &quot;method&quot;. The function panics otherwise. For the &quot;method&quot;
label a predefined default label value set is used to filter given values.
Values besides predefined values will count as `unknown` method.
`WithExtraMethods` can be used to add more methods to the set. Partitioning of the
CounterVec happens by HTTP status code and/or HTTP method if the respective
instance label names are present in the CounterVec. For unpartitioned
counting, use a CounterVec with zero labels.
<p>If the wrapped Handler does not set a status code, a status code of 200 is assumed.
<p>If the wrapped Handler panics, the Counter is not incremented.
<p>See the example for InstrumentHandlerDuration for example usage.

			
			

		
			
			
			<h2 id="InstrumentHandlerDuration">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=2679:2789#L54">InstrumentHandlerDuration</a>
				<a class="permalink" href="index.html#InstrumentHandlerDuration">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerDuration(obs <a href="../index.html">prometheus</a>.<a href="../index.html#ObserverVec">ObserverVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>, opts ...<a href="index.html#Option">Option</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#HandlerFunc">HandlerFunc</a></pre>
			<p>InstrumentHandlerDuration is a middleware that wraps the provided
http.Handler to observe the request duration with the provided ObserverVec.
The ObserverVec must have valid metric and label names and must have zero,
one, or two non-const non-curried labels. For those, the only allowed label
names are &quot;code&quot; and &quot;method&quot;. The function panics otherwise. For the &quot;method&quot;
label a predefined default label value set is used to filter given values.
Values besides predefined values will count as `unknown` method.
`WithExtraMethods` can be used to add more methods to the set. The Observe
method of the Observer in the ObserverVec is called with the request duration
in seconds. Partitioning happens by HTTP status code and/or HTTP method if
the respective instance label names are present in the ObserverVec. For
unpartitioned observations, use an ObserverVec with zero labels. Note that
partitioning of Histograms is expensive and should be used judiciously.
<p>If the wrapped Handler does not set a status code, a status code of 200 is assumed.
<p>If the wrapped Handler panics, no values are reported.
<p>Note that this method is only guaranteed to never observe negative durations
if used with Go1.9+.

			<div id="example_InstrumentHandlerDuration" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
inFlightGauge := prometheus.NewGauge(prometheus.GaugeOpts{
    Name: &#34;in_flight_requests&#34;,
    Help: &#34;A gauge of requests currently being served by the wrapped handler.&#34;,
})

counter := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Name: &#34;api_requests_total&#34;,
        Help: &#34;A counter for requests to the wrapped handler.&#34;,
    },
    []string{&#34;code&#34;, &#34;method&#34;},
)

<span class="comment">// duration is partitioned by the HTTP method and handler. It uses custom</span>
<span class="comment">// buckets based on the expected request duration.</span>
duration := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;request_duration_seconds&#34;,
        Help:    &#34;A histogram of latencies for requests.&#34;,
        Buckets: []float64{.25, .5, 1, 2.5, 5, 10},
    },
    []string{&#34;handler&#34;, &#34;method&#34;},
)

<span class="comment">// responseSize has no labels, making it a zero-dimensional</span>
<span class="comment">// ObserverVec.</span>
responseSize := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;response_size_bytes&#34;,
        Help:    &#34;A histogram of response sizes for requests.&#34;,
        Buckets: []float64{200, 500, 900, 1500},
    },
    []string{},
)

<span class="comment">// Create the handlers that will be wrapped by the middleware.</span>
pushHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(&#34;Push&#34;))
})
pullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(&#34;Pull&#34;))
})

<span class="comment">// Register all of the metrics in the standard registry.</span>
prometheus.MustRegister(inFlightGauge, counter, duration, responseSize)

<span class="comment">// Instrument the handlers with all the metrics, injecting the &#34;handler&#34;</span>
<span class="comment">// label by currying.</span>
pushChain := InstrumentHandlerInFlight(inFlightGauge,
    InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{&#34;handler&#34;: &#34;push&#34;}),
        InstrumentHandlerCounter(counter,
            InstrumentHandlerResponseSize(responseSize, pushHandler),
        ),
    ),
)
pullChain := InstrumentHandlerInFlight(inFlightGauge,
    InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{&#34;handler&#34;: &#34;pull&#34;}),
        InstrumentHandlerCounter(counter,
            InstrumentHandlerResponseSize(responseSize, pullHandler),
        ),
    ),
)

http.Handle(&#34;/metrics&#34;, Handler())
http.Handle(&#34;/push&#34;, pushChain)
http.Handle(&#34;/pull&#34;, pullChain)

if err := http.ListenAndServe(&#34;:3000&#34;, nil); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="InstrumentHandlerInFlight">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=1210:1292#L26">InstrumentHandlerInFlight</a>
				<a class="permalink" href="index.html#InstrumentHandlerInFlight">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerInFlight(g <a href="../index.html">prometheus</a>.<a href="../index.html#Gauge">Gauge</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>InstrumentHandlerInFlight is a middleware that wraps the provided
http.Handler. It sets the provided prometheus.Gauge to the number of
requests currently handled by the wrapped http.Handler.
<p>See the example for InstrumentHandlerDuration for example usage.

			
			

		
			
			
			<h2 id="InstrumentHandlerRequestSize">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=9329:9442#L201">InstrumentHandlerRequestSize</a>
				<a class="permalink" href="index.html#InstrumentHandlerRequestSize">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerRequestSize(obs <a href="../index.html">prometheus</a>.<a href="../index.html#ObserverVec">ObserverVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>, opts ...<a href="index.html#Option">Option</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#HandlerFunc">HandlerFunc</a></pre>
			<p>InstrumentHandlerRequestSize is a middleware that wraps the provided
http.Handler to observe the request size with the provided ObserverVec. The
ObserverVec must have valid metric and label names and must have zero, one,
or two non-const non-curried labels. For those, the only allowed label names
are &quot;code&quot; and &quot;method&quot;. The function panics otherwise. For the &quot;method&quot;
label a predefined default label value set is used to filter given values.
Values besides predefined values will count as `unknown` method.
`WithExtraMethods` can be used to add more methods to the set. The Observe
method of the Observer in the ObserverVec is called with the request size in
bytes. Partitioning happens by HTTP status code and/or HTTP method if the
respective instance label names are present in the ObserverVec. For
unpartitioned observations, use an ObserverVec with zero labels. Note that
partitioning of Histograms is expensive and should be used judiciously.
<p>If the wrapped Handler does not set a status code, a status code of 200 is assumed.
<p>If the wrapped Handler panics, no values are reported.
<p>See the example for InstrumentHandlerDuration for example usage.

			
			

		
			
			
			<h2 id="InstrumentHandlerResponseSize">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=11754:11864#L255">InstrumentHandlerResponseSize</a>
				<a class="permalink" href="index.html#InstrumentHandlerResponseSize">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerResponseSize(obs <a href="../index.html">prometheus</a>.<a href="../index.html#ObserverVec">ObserverVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>, opts ...<a href="index.html#Option">Option</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>InstrumentHandlerResponseSize is a middleware that wraps the provided
http.Handler to observe the response size with the provided ObserverVec. The
ObserverVec must have valid metric and label names and must have zero, one,
or two non-const non-curried labels. For those, the only allowed label names
are &quot;code&quot; and &quot;method&quot;. The function panics otherwise. For the &quot;method&quot;
label a predefined default label value set is used to filter given values.
Values besides predefined values will count as `unknown` method.
`WithExtraMethods` can be used to add more methods to the set. The Observe
method of the Observer in the ObserverVec is called with the response size in
bytes. Partitioning happens by HTTP status code and/or HTTP method if the
respective instance label names are present in the ObserverVec. For
unpartitioned observations, use an ObserverVec with zero labels. Note that
partitioning of Histograms is expensive and should be used judiciously.
<p>If the wrapped Handler does not set a status code, a status code of 200 is assumed.
<p>If the wrapped Handler panics, no values are reported.
<p>See the example for InstrumentHandlerDuration for example usage.

			
			

		
			
			
			<h2 id="InstrumentHandlerTimeToWriteHeader">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_server.go?s=7316:7435#L160">InstrumentHandlerTimeToWriteHeader</a>
				<a class="permalink" href="index.html#InstrumentHandlerTimeToWriteHeader">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentHandlerTimeToWriteHeader(obs <a href="../index.html">prometheus</a>.<a href="../index.html#ObserverVec">ObserverVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>, opts ...<a href="index.html#Option">Option</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#HandlerFunc">HandlerFunc</a></pre>
			<p>InstrumentHandlerTimeToWriteHeader is a middleware that wraps the provided
http.Handler to observe with the provided ObserverVec the request duration
until the response headers are written. The ObserverVec must have valid
metric and label names and must have zero, one, or two non-const non-curried
labels. For those, the only allowed label names are &quot;code&quot; and &quot;method&quot;. The
function panics otherwise. For the &quot;method&quot; label a predefined default label
value set is used to filter given values. Values besides predefined values
will count as `unknown` method.`WithExtraMethods` can be used to add more
methods to the set. The Observe method of the Observer in the
ObserverVec is called with the request duration in seconds. Partitioning
happens by HTTP status code and/or HTTP method if the respective instance
label names are present in the ObserverVec. For unpartitioned observations,
use an ObserverVec with zero labels. Note that partitioning of Histograms is
expensive and should be used judiciously.
<p>If the wrapped Handler panics before calling WriteHeader, no value is
reported.
<p>Note that this method is only guaranteed to never observe negative durations
if used with Go1.9+.
<p>See the example for InstrumentHandlerDuration for example usage.

			
			

		
			
			
			<h2 id="InstrumentMetricHandler">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=8473:8563#L232">InstrumentMetricHandler</a>
				<a class="permalink" href="index.html#InstrumentMetricHandler">&#xb6;</a>
				
				
			</h2>
			<pre>func InstrumentMetricHandler(reg <a href="../index.html">prometheus</a>.<a href="../index.html#Registerer">Registerer</a>, handler <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a>) <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Handler">Handler</a></pre>
			<p>InstrumentMetricHandler is usually used with an http.Handler returned by the
HandlerFor function. It instruments the provided http.Handler with two
metrics: A counter vector &quot;promhttp_metric_handler_requests_total&quot; to count
scrapes partitioned by HTTP status code, and a gauge
&quot;promhttp_metric_handler_requests_in_flight&quot; to track the number of
simultaneous scrapes. This function idempotently registers collectors for
both metrics with the provided Registerer. It panics if the registration
fails. The provided metrics are useful to see how many scrapes hit the
monitored target (which could be from different Prometheus servers or other
scrapers), and how often they overlap (which would result in more than one
scrape in flight at the same time). Note that the scrapes-in-flight gauge
will contain the scrape by which it is exposed, while the scrape counter will
only get incremented after the scrape is complete (as only then the status
code is known). For tracking scrape durations, use the
&quot;scrape_duration_seconds&quot; gauge created by the Prometheus server upon each
scrape.

			
			

		
		
			
			
			<h2 id="HandlerErrorHandling">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=9626:9655#L271">HandlerErrorHandling</a>
				<a class="permalink" href="index.html#HandlerErrorHandling">&#xb6;</a>
				
				
			</h2>
			<p>HandlerErrorHandling defines how a Handler serving metrics will handle
errors.

			<pre>type HandlerErrorHandling <a href="../../../../../builtin/index.html#int">int</a></pre>

			
				<p>These constants cause handlers serving metrics to behave as described if
errors are encountered.

				<pre>const (
    <span class="comment">// Serve an HTTP status code 500 upon the first error</span>
    <span class="comment">// encountered. Report the error message in the body. Note that HTTP</span>
    <span class="comment">// errors cannot be served anymore once the beginning of a regular</span>
    <span class="comment">// payload has been sent. Thus, in the (unlikely) case that encoding the</span>
    <span class="comment">// payload into the negotiated wire format fails, serving the response</span>
    <span class="comment">// will simply be aborted. Set an ErrorLog in HandlerOpts to detect</span>
    <span class="comment">// those errors.</span>
    <span id="HTTPErrorOnError">HTTPErrorOnError</span> <a href="index.html#HandlerErrorHandling">HandlerErrorHandling</a> = <a href="../../../../../builtin/index.html#iota">iota</a>
    <span class="comment">// Ignore errors and try to serve as many metrics as possible.  However,</span>
    <span class="comment">// if no metrics can be served, serve an HTTP status code 500 and the</span>
    <span class="comment">// last error message in the body. Only use this in deliberate &#34;best</span>
    <span class="comment">// effort&#34; metrics collection scenarios. In this case, it is highly</span>
    <span class="comment">// recommended to provide other means of detecting errors: By setting an</span>
    <span class="comment">// ErrorLog in HandlerOpts, the errors are logged. By providing a</span>
    <span class="comment">// Registry in HandlerOpts, the exposed metrics include an error counter</span>
    <span class="comment">// &#34;promhttp_metric_handler_errors_total&#34;, which can be used for</span>
    <span class="comment">// alerts.</span>
    <span id="ContinueOnError">ContinueOnError</span>
    <span class="comment">// Panic upon the first error encountered (useful for &#34;crash only&#34; apps).</span>
    <span id="PanicOnError">PanicOnError</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="HandlerOpts">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=11342:14428#L307">HandlerOpts</a>
				<a class="permalink" href="index.html#HandlerOpts">&#xb6;</a>
				
				
			</h2>
			<p>HandlerOpts specifies options how to serve metrics via an http.Handler. The
zero value of HandlerOpts is a reasonable default.

			<pre>type HandlerOpts struct {
<span id="HandlerOpts.ErrorLog"></span>    <span class="comment">// ErrorLog specifies an optional Logger for errors collecting and</span>
    <span class="comment">// serving metrics. If nil, errors are not logged at all. Note that the</span>
    <span class="comment">// type of a reported error is often prometheus.MultiError, which</span>
    <span class="comment">// formats into a multi-line error string. If you want to avoid the</span>
    <span class="comment">// latter, create a Logger implementation that detects a</span>
    <span class="comment">// prometheus.MultiError and formats the contained errors into one line.</span>
    ErrorLog <a href="index.html#Logger">Logger</a>
<span id="HandlerOpts.ErrorHandling"></span>    <span class="comment">// ErrorHandling defines how errors are handled. Note that errors are</span>
    <span class="comment">// logged regardless of the configured ErrorHandling provided ErrorLog</span>
    <span class="comment">// is not nil.</span>
    ErrorHandling <a href="index.html#HandlerErrorHandling">HandlerErrorHandling</a>
    <span class="comment">// If Registry is not nil, it is used to register a metric</span>
    <span class="comment">// &#34;promhttp_metric_handler_errors_total&#34;, partitioned by &#34;cause&#34;. A</span>
    <span class="comment">// failed registration causes a panic. Note that this error counter is</span>
    <span class="comment">// different from the instrumentation you get from the various</span>
    <span class="comment">// InstrumentHandler... helpers. It counts errors that don&#39;t necessarily</span>
    <span class="comment">// result in a non-2xx HTTP status code. There are two typical cases:</span>
    <span class="comment">// (1) Encoding errors that only happen after streaming of the HTTP body</span>
    <span class="comment">// has already started (and the status code 200 has been sent). This</span>
    <span class="comment">// should only happen with custom collectors. (2) Collection errors with</span>
    <span class="comment">// no effect on the HTTP status code because ErrorHandling is set to</span>
    <span class="comment">// ContinueOnError.</span>
<span id="HandlerOpts.Registry"></span>    Registry <a href="../index.html">prometheus</a>.<a href="../index.html#Registerer">Registerer</a>
    <span class="comment">// If DisableCompression is true, the handler will never compress the</span>
    <span class="comment">// response, even if requested by the client.</span>
<span id="HandlerOpts.DisableCompression"></span>    DisableCompression <a href="../../../../../builtin/index.html#bool">bool</a>
    <span class="comment">// The number of concurrent HTTP requests is limited to</span>
<span id="HandlerOpts.MaxRequestsInFlight"></span>    <span class="comment">// MaxRequestsInFlight. Additional requests are responded to with 503</span>
    <span class="comment">// Service Unavailable and a suitable message in the body. If</span>
    <span class="comment">// MaxRequestsInFlight is 0 or negative, no limit is applied.</span>
    MaxRequestsInFlight <a href="../../../../../builtin/index.html#int">int</a>
    <span class="comment">// If handling a request takes longer than Timeout, it is responded to</span>
    <span class="comment">// with 503 ServiceUnavailable and a suitable Message. No timeout is</span>
    <span class="comment">// applied if Timeout is 0 or negative. Note that with the current</span>
    <span class="comment">// implementation, reaching the timeout simply ends the HTTP requests as</span>
    <span class="comment">// described above (and even that only if sending of the body hasn&#39;t</span>
    <span class="comment">// started yet), while the bulk work of gathering all the metrics keeps</span>
    <span class="comment">// running in the background (with the eventual result to be thrown</span>
    <span class="comment">// away). Until the implementation is improved, it is recommended to</span>
    <span class="comment">// implement a separate timeout in potentially slow Collectors.</span>
<span id="HandlerOpts.Timeout"></span>    Timeout <a href="../../../../../time/index.html">time</a>.<a href="../../../../../time/index.html#Duration">Duration</a>
    <span class="comment">// If true, the experimental OpenMetrics encoding is added to the</span>
    <span class="comment">// possible options during content negotiation. Note that Prometheus</span>
    <span class="comment">// 2.5.0+ will negotiate OpenMetrics as first priority. OpenMetrics is</span>
    <span class="comment">// the only way to transmit exemplars. However, the move to OpenMetrics</span>
    <span class="comment">// is not completely transparent. Most notably, the values of &#34;quantile&#34;</span>
    <span class="comment">// labels of Summaries and &#34;le&#34; labels of Histograms are formatted with</span>
    <span class="comment">// a trailing &#34;.0&#34; if they would otherwise look like integer numbers</span>
    <span class="comment">// (which changes the identity of the resulting series on the Prometheus</span>
    <span class="comment">// server).</span>
<span id="HandlerOpts.EnableOpenMetrics"></span>    EnableOpenMetrics <a href="../../../../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="InstrumentTrace">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=5983:6482#L126">InstrumentTrace</a>
				<a class="permalink" href="index.html#InstrumentTrace">&#xb6;</a>
				
				
			</h2>
			<p>InstrumentTrace is used to offer flexibility in instrumenting the available
httptrace.ClientTrace hook functions. Each function is passed a float64
representing the time in seconds since the start of the http request. A user
may choose to use separately buckets Histograms, or implement custom
instance labels on a per function basis.

			<pre>type InstrumentTrace struct {
<span id="InstrumentTrace.GotConn"></span>    GotConn              func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.PutIdleConn"></span>    PutIdleConn          func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.GotFirstResponseByte"></span>    GotFirstResponseByte func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.Got100Continue"></span>    Got100Continue       func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.DNSStart"></span>    DNSStart             func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.DNSDone"></span>    DNSDone              func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.ConnectStart"></span>    ConnectStart         func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.ConnectDone"></span>    ConnectDone          func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.TLSHandshakeStart"></span>    TLSHandshakeStart    func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.TLSHandshakeDone"></span>    TLSHandshakeDone     func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.WroteHeaders"></span>    WroteHeaders         func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.Wait100Continue"></span>    Wait100Continue      func(<a href="../../../../../builtin/index.html#float64">float64</a>)
<span id="InstrumentTrace.WroteRequest"></span>    WroteRequest         func(<a href="../../../../../builtin/index.html#float64">float64</a>)
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="LabelValueFromCtx">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go?s=954:1009#L19">LabelValueFromCtx</a>
				<a class="permalink" href="index.html#LabelValueFromCtx">&#xb6;</a>
				
				
			</h2>
			<p>LabelValueFromCtx are used to compute the label value from request context.
Context can be filled with values from request through middleware.

			<pre>type LabelValueFromCtx func(ctx <a href="../../../../../context/index.html">context</a>.<a href="../../../../../context/index.html#Context">Context</a>) <a href="../../../../../builtin/index.html#string">string</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Logger">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/http.go?s=11155:11207#L301">Logger</a>
				<a class="permalink" href="index.html#Logger">&#xb6;</a>
				
				
			</h2>
			<p>Logger is the minimal interface HandlerOpts needs for logging. Note that
log.Logger from the standard library implements this interface, and it is
easy to implement by custom loggers, if they don&apos;t do so already anyway.

			<pre>type Logger interface {
    Println(v ...interface{})
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Option">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go?s=761:803#L13">Option</a>
				<a class="permalink" href="index.html#Option">&#xb6;</a>
				
				
			</h2>
			<p>Option are used to configure both handler (middleware) or round tripper.

			<pre>type Option interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="WithExemplarFromContext">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go?s=2333:2434#L62">WithExemplarFromContext</a>
					<a class="permalink" href="index.html#WithExemplarFromContext">&#xb6;</a>
					
					
				</h3>
				<pre>func WithExemplarFromContext(getExemplarFn func(requestCtx <a href="../../../../../context/index.html">context</a>.<a href="../../../../../context/index.html#Context">Context</a>) <a href="../index.html">prometheus</a>.<a href="../index.html#Labels">Labels</a>) <a href="index.html#Option">Option</a></pre>
				<p>WithExemplarFromContext adds allows to put a hook to all counter and histogram metrics.
If the hook function returns non-nil labels, exemplars will be added for that request, otherwise metric
will get instrumented without exemplar.

				
				
			
				
				<h3 id="WithExtraMethods">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go?s=1965:2012#L53">WithExtraMethods</a>
					<a class="permalink" href="index.html#WithExtraMethods">&#xb6;</a>
					
					
				</h3>
				<pre>func WithExtraMethods(methods ...<a href="../../../../../builtin/index.html#string">string</a>) <a href="index.html#Option">Option</a></pre>
				<p>WithExtraMethods adds additional HTTP methods to the list of allowed methods.
See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a> for the default list.
<p>See the example for ExampleInstrumentHandlerWithExtraMethods for example usage.

				
				
			
				
				<h3 id="WithLabelFromCtx">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/option.go?s=2689:2757#L70">WithLabelFromCtx</a>
					<a class="permalink" href="index.html#WithLabelFromCtx">&#xb6;</a>
					
					
				</h3>
				<pre>func WithLabelFromCtx(name <a href="../../../../../builtin/index.html#string">string</a>, valueFn <a href="index.html#LabelValueFromCtx">LabelValueFromCtx</a>) <a href="index.html#Option">Option</a></pre>
				<p>WithLabelFromCtx registers a label for dynamic resolution with access to context.
See the example for ExampleInstrumentHandlerWithLabelResolver for example usage

				
				
			

			
		
			
			
			<h2 id="RoundTripperFunc">type <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=939:1008#L18">RoundTripperFunc</a>
				<a class="permalink" href="index.html#RoundTripperFunc">&#xb6;</a>
				
				
			</h2>
			<p>The RoundTripperFunc type is an adapter to allow the use of ordinary
functions as RoundTrippers. If f is a function with the appropriate
signature, RountTripperFunc(f) is a RoundTripper that calls f.

			<pre>type RoundTripperFunc func(req *<a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Request">Request</a>) (*<a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Response">Response</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>

			

			

			
			
			

			
				
				<h3 id="InstrumentRoundTripperCounter">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=2742:2865#L55">InstrumentRoundTripperCounter</a>
					<a class="permalink" href="index.html#InstrumentRoundTripperCounter">&#xb6;</a>
					
					
				</h3>
				<pre>func InstrumentRoundTripperCounter(counter *<a href="../index.html">prometheus</a>.<a href="../index.html#CounterVec">CounterVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#RoundTripper">RoundTripper</a>, opts ...<a href="index.html#Option">Option</a>) <a href="index.html#RoundTripperFunc">RoundTripperFunc</a></pre>
				<p>InstrumentRoundTripperCounter is a middleware that wraps the provided
http.RoundTripper to observe the request result with the provided CounterVec.
The CounterVec must have zero, one, or two non-const non-curried labels. For
those, the only allowed label names are &quot;code&quot; and &quot;method&quot;. The function
panics otherwise. For the &quot;method&quot; label a predefined default label value set
is used to filter given values. Values besides predefined values will count
as `unknown` method.`WithExtraMethods` can be used to add more
methods to the set. Partitioning of the CounterVec happens by HTTP status code
and/or HTTP method if the respective instance label names are present in the
CounterVec. For unpartitioned counting, use a CounterVec with zero labels.
<p>If the wrapped RoundTripper panics or returns a non-nil error, the Counter
is not incremented.
<p>Use with WithExemplarFromContext to instrument the exemplars on the counter of requests.
<p>See the example for ExampleInstrumentRoundTripperDuration for example usage.

				
				
			
				
				<h3 id="InstrumentRoundTripperDuration">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=4797:4917#L98">InstrumentRoundTripperDuration</a>
					<a class="permalink" href="index.html#InstrumentRoundTripperDuration">&#xb6;</a>
					
					
				</h3>
				<pre>func InstrumentRoundTripperDuration(obs <a href="../index.html">prometheus</a>.<a href="../index.html#ObserverVec">ObserverVec</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#RoundTripper">RoundTripper</a>, opts ...<a href="index.html#Option">Option</a>) <a href="index.html#RoundTripperFunc">RoundTripperFunc</a></pre>
				<p>InstrumentRoundTripperDuration is a middleware that wraps the provided
http.RoundTripper to observe the request duration with the provided
ObserverVec.  The ObserverVec must have zero, one, or two non-const
non-curried labels. For those, the only allowed label names are &quot;code&quot; and
&quot;method&quot;. The function panics otherwise. For the &quot;method&quot; label a predefined
default label value set is used to filter given values. Values besides
predefined values will count as `unknown` method. `WithExtraMethods`
can be used to add more methods to the set. The Observe method of the Observer
in the ObserverVec is called with the request duration in
seconds. Partitioning happens by HTTP status code and/or HTTP method if the
respective instance label names are present in the ObserverVec. For
unpartitioned observations, use an ObserverVec with zero labels. Note that
partitioning of Histograms is expensive and should be used judiciously.
<p>If the wrapped RoundTripper panics or returns a non-nil error, no values are
reported.
<p>Use with WithExemplarFromContext to instrument the exemplars on the duration histograms.
<p>Note that this method is only guaranteed to never observe negative durations
if used with Go1.9+.

				<div id="example_InstrumentRoundTripperDuration" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
client := http.DefaultClient
client.Timeout = 1 * time.Second

inFlightGauge := prometheus.NewGauge(prometheus.GaugeOpts{
    Name: &#34;client_in_flight_requests&#34;,
    Help: &#34;A gauge of in-flight requests for the wrapped client.&#34;,
})

counter := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Name: &#34;client_api_requests_total&#34;,
        Help: &#34;A counter for requests from the wrapped client.&#34;,
    },
    []string{&#34;code&#34;, &#34;method&#34;},
)

<span class="comment">// dnsLatencyVec uses custom buckets based on expected dns durations.</span>
<span class="comment">// It has an instance label &#34;event&#34;, which is set in the</span>
<span class="comment">// DNSStart and DNSDonehook functions defined in the</span>
<span class="comment">// InstrumentTrace struct below.</span>
dnsLatencyVec := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;dns_duration_seconds&#34;,
        Help:    &#34;Trace dns latency histogram.&#34;,
        Buckets: []float64{.005, .01, .025, .05},
    },
    []string{&#34;event&#34;},
)

<span class="comment">// tlsLatencyVec uses custom buckets based on expected tls durations.</span>
<span class="comment">// It has an instance label &#34;event&#34;, which is set in the</span>
<span class="comment">// TLSHandshakeStart and TLSHandshakeDone hook functions defined in the</span>
<span class="comment">// InstrumentTrace struct below.</span>
tlsLatencyVec := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;tls_duration_seconds&#34;,
        Help:    &#34;Trace tls latency histogram.&#34;,
        Buckets: []float64{.05, .1, .25, .5},
    },
    []string{&#34;event&#34;},
)

<span class="comment">// histVec has no labels, making it a zero-dimensional ObserverVec.</span>
histVec := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    &#34;request_duration_seconds&#34;,
        Help:    &#34;A histogram of request latencies.&#34;,
        Buckets: prometheus.DefBuckets,
    },
    []string{},
)

<span class="comment">// Register all of the metrics in the standard registry.</span>
prometheus.MustRegister(counter, tlsLatencyVec, dnsLatencyVec, histVec, inFlightGauge)

<span class="comment">// Define functions for the available httptrace.ClientTrace hook</span>
<span class="comment">// functions that we want to instrument.</span>
trace := &amp;InstrumentTrace{
    DNSStart: func(t float64) {
        dnsLatencyVec.WithLabelValues(&#34;dns_start&#34;).Observe(t)
    },
    DNSDone: func(t float64) {
        dnsLatencyVec.WithLabelValues(&#34;dns_done&#34;).Observe(t)
    },
    TLSHandshakeStart: func(t float64) {
        tlsLatencyVec.WithLabelValues(&#34;tls_handshake_start&#34;).Observe(t)
    },
    TLSHandshakeDone: func(t float64) {
        tlsLatencyVec.WithLabelValues(&#34;tls_handshake_done&#34;).Observe(t)
    },
}

<span class="comment">// Wrap the default RoundTripper with middleware.</span>
roundTripper := InstrumentRoundTripperInFlight(inFlightGauge,
    InstrumentRoundTripperCounter(counter,
        InstrumentRoundTripperTrace(trace,
            InstrumentRoundTripperDuration(histVec, http.DefaultTransport),
        ),
    ),
)

<span class="comment">// Set the RoundTripper on our client.</span>
client.Transport = roundTripper

resp, err := client.Get(&#34;http://google.com&#34;)
if err != nil {
    log.Printf(&#34;error: %v&#34;, err)
}
defer resp.Body.Close()
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="InstrumentRoundTripperInFlight">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=1457:1557#L30">InstrumentRoundTripperInFlight</a>
					<a class="permalink" href="index.html#InstrumentRoundTripperInFlight">&#xb6;</a>
					
					
				</h3>
				<pre>func InstrumentRoundTripperInFlight(gauge <a href="../index.html">prometheus</a>.<a href="../index.html#Gauge">Gauge</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#RoundTripper">RoundTripper</a>) <a href="index.html#RoundTripperFunc">RoundTripperFunc</a></pre>
				<p>InstrumentRoundTripperInFlight is a middleware that wraps the provided
http.RoundTripper. It sets the provided prometheus.Gauge to the number of
requests currently handled by the wrapped http.RoundTripper.
<p>See the example for ExampleInstrumentRoundTripperDuration for example usage.

				
				
			
				
				<h3 id="InstrumentRoundTripperTrace">func <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=7248:7342#L155">InstrumentRoundTripperTrace</a>
					<a class="permalink" href="index.html#InstrumentRoundTripperTrace">&#xb6;</a>
					
					
				</h3>
				<pre>func InstrumentRoundTripperTrace(it *<a href="index.html#InstrumentTrace">InstrumentTrace</a>, next <a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#RoundTripper">RoundTripper</a>) <a href="index.html#RoundTripperFunc">RoundTripperFunc</a></pre>
				<p>InstrumentRoundTripperTrace is a middleware that wraps the provided
RoundTripper and reports times to hook functions provided in the
InstrumentTrace struct. Hook functions that are not present in the provided
InstrumentTrace struct are ignored. Times reported to the hook functions are
time since the start of the request. Only with Go1.9+, those times are
guaranteed to never be negative. (Earlier Go versions are not using a
monotonic clock.) Note that partitioning of Histograms is expensive and
should be used judiciously.
<p>For hook functions that receive an error as an argument, no observations are
made in the event of a non-nil error value.
<p>See the example for ExampleInstrumentRoundTripperDuration for example usage.

				
				
			

			
				
				<h3 id="RoundTripperFunc.RoundTrip">func (RoundTripperFunc) <a href="http://localhost:6060/src/github.com/prometheus/client_golang/prometheus/promhttp/instrument_client.go?s=1062:1139#L21">RoundTrip</a>
					<a class="permalink" href="index.html#RoundTripperFunc.RoundTrip">&#xb6;</a>
					
					
				</h3>
				<pre>func (rt <a href="index.html#RoundTripperFunc">RoundTripperFunc</a>) RoundTrip(r *<a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Request">Request</a>) (*<a href="../../../../../net/http/index.html">http</a>.<a href="../../../../../net/http/index.html#Response">Response</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>RoundTrip implements the RoundTripper interface.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
