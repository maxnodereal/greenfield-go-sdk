<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>merkle - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package merkle
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cometbft/cometbft/crypto/merkle"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package merkle computes a deterministic minimal height Merkle tree hash.
If the number of items is not a power of two, some leaves
will be at different levels. Tries to keep both sides of
the tree the same size, but the left may be one greater.
<p>Use this for short deterministic trees, such as the validator list.
For larger datasets, use IAVLTree.
<p>Be aware that the current implementation by itself does not prevent
second pre-image attacks. Hence, use this library with caution.
Otherwise you might run into similar issues as, e.g., in early Bitcoin:
<a href="https://bitcointalk.org/?topic=102395">https://bitcointalk.org/?topic=102395</a>
<pre>              *
             / \
           /     \
         /         \
       /             \
      *               *
     / \             / \
    /   \           /   \
   /     \         /     \
  *       *       *       h6
 / \     / \     / \
h0  h1  h2  h3  h4  h5
</pre>
<p>TODO(ismail): add 2nd pre-image protection or clarify further on how we use this and why this secure.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#HashFromByteSlices">func HashFromByteSlices(items [][]byte) []byte</a></dd>
			
				
				<dd><a href="index.html#HashFromByteSlicesIterative">func HashFromByteSlicesIterative(input [][]byte) []byte</a></dd>
			
				
				<dd><a href="index.html#KeyPathToKeys">func KeyPathToKeys(path string) (keys [][]byte, err error)</a></dd>
			
			
				
				<dd><a href="index.html#Key">type Key</a></dd>
				
				
			
				
				<dd><a href="index.html#KeyPath">type KeyPath</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#KeyPath.AppendKey">func (pth KeyPath) AppendKey(key []byte, enc keyEncoding) KeyPath</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#KeyPath.String">func (pth KeyPath) String() string</a></dd>
				
			
				
				<dd><a href="index.html#OpDecoder">type OpDecoder</a></dd>
				
				
			
				
				<dd><a href="index.html#Proof">type Proof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofFromProto">func ProofFromProto(pb *cmtcrypto.Proof) (*Proof, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofsFromByteSlices">func ProofsFromByteSlices(items [][]byte) (rootHash []byte, proofs []*Proof)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.ComputeRootHash">func (sp *Proof) ComputeRootHash() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.String">func (sp *Proof) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.StringIndented">func (sp *Proof) StringIndented(indent string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.ToProto">func (sp *Proof) ToProto() *cmtcrypto.Proof</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.ValidateBasic">func (sp *Proof) ValidateBasic() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Proof.Verify">func (sp *Proof) Verify(rootHash []byte, leaf []byte) error</a></dd>
				
			
				
				<dd><a href="index.html#ProofNode">type ProofNode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofNode.FlattenAunts">func (spn *ProofNode) FlattenAunts() [][]byte</a></dd>
				
			
				
				<dd><a href="index.html#ProofOperator">type ProofOperator</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueOpDecoder">func ValueOpDecoder(pop cmtcrypto.ProofOp) (ProofOperator, error)</a></dd>
				
				
			
				
				<dd><a href="index.html#ProofOperators">type ProofOperators</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofOperators.Verify">func (poz ProofOperators) Verify(root []byte, keypath string, args [][]byte) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofOperators.VerifyValue">func (poz ProofOperators) VerifyValue(root []byte, keypath string, value []byte) (err error)</a></dd>
				
			
				
				<dd><a href="index.html#ProofRuntime">type ProofRuntime</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DefaultProofRuntime">func DefaultProofRuntime() (prt *ProofRuntime)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewProofRuntime">func NewProofRuntime() *ProofRuntime</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.Decode">func (prt *ProofRuntime) Decode(pop cmtcrypto.ProofOp) (ProofOperator, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.DecodeProof">func (prt *ProofRuntime) DecodeProof(proof *cmtcrypto.ProofOps) (ProofOperators, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.RegisterOpDecoder">func (prt *ProofRuntime) RegisterOpDecoder(typ string, dec OpDecoder)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.Verify">func (prt *ProofRuntime) Verify(proof *cmtcrypto.ProofOps, root []byte, keypath string, args [][]byte) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.VerifyAbsence">func (prt *ProofRuntime) VerifyAbsence(proof *cmtcrypto.ProofOps, root []byte, keypath string) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ProofRuntime.VerifyValue">func (prt *ProofRuntime) VerifyValue(proof *cmtcrypto.ProofOps, root []byte, keypath string, value []byte) (err error)</a></dd>
				
			
				
				<dd><a href="index.html#Tree">type Tree</a></dd>
				
				
			
				
				<dd><a href="index.html#ValueOp">type ValueOp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewValueOp">func NewValueOp(key []byte, proof *Proof) ValueOp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueOp.GetKey">func (op ValueOp) GetKey() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueOp.ProofOp">func (op ValueOp) ProofOp() cmtcrypto.ProofOp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueOp.Run">func (op ValueOp) Run(args [][]byte) ([][]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ValueOp.String">func (op ValueOp) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/hash.go">hash.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go">proof.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go">proof_key_path.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go">proof_op.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go">proof_value.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/tree.go">tree.go</a>
			
				<a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/types.go">types.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span id="KeyEncodingURL">KeyEncodingURL</span> keyEncoding = <a href="../../../../../builtin/index.html#iota">iota</a>
    <span id="KeyEncodingHex">KeyEncodingHex</span>
    <span id="KeyEncodingMax">KeyEncodingMax</span> <span class="comment">// Number of known encodings. Used for testing</span>
)</pre>
			
				
				<pre>const (
    <span class="comment">// MaxAunts is the maximum number of aunts that can be included in a Proof.</span>
    <span class="comment">// This corresponds to a tree of size 2^100, which should be sufficient for all conceivable purposes.</span>
    <span class="comment">// This maximum helps prevent Denial-of-Service attacks by limitting the size of the proofs.</span>
    <span id="MaxAunts">MaxAunts</span> = 100
)</pre>
			
				
				<pre>const <span id="ProofOpValue">ProofOpValue</span> = &#34;simple:v&#34;</pre>
			
		
		
		
			
			
			<h2 id="HashFromByteSlices">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/tree.go?s=170:216#L1">HashFromByteSlices</a>
				<a class="permalink" href="index.html#HashFromByteSlices">&#xb6;</a>
				
				
			</h2>
			<pre>func HashFromByteSlices(items [][]<a href="../../../../../builtin/index.html#byte">byte</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
			<p>HashFromByteSlices computes a Merkle tree where the leaves are the byte slice,
in the provided order. It follows RFC-6962.

			
			

		
			
			
			<h2 id="HashFromByteSlicesIterative">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/tree.go?s=2441:2496#L52">HashFromByteSlicesIterative</a>
				<a class="permalink" href="index.html#HashFromByteSlicesIterative">&#xb6;</a>
				
				
			</h2>
			<pre>func HashFromByteSlicesIterative(input [][]<a href="../../../../../builtin/index.html#byte">byte</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
			<p>HashFromByteSliceIterative is an iterative alternative to
HashFromByteSlice motivated by potential performance improvements.
(#2611) had suggested that an iterative version of
HashFromByteSlice would be faster, presumably because
we can envision some overhead accumulating from stack
frames and function calls. Additionally, a recursive algorithm risks
hitting the stack limit and causing a stack overflow should the tree
be too large.
<p>Provided here is an iterative alternative, a test to assert
correctness and a benchmark. On the performance side, there appears to
be no overall difference:
<p>BenchmarkHashAlternatives/recursive-4                20000 77677 ns/op
BenchmarkHashAlternatives/iterative-4                20000 76802 ns/op
<p>On the surface it might seem that the additional overhead is due to
the different allocation patterns of the implementations. The recursive
version uses a single [][]byte slices which it then re-slices at each level of the tree.
The iterative version reproduces [][]byte once within the function and
then rewrites sub-slices of that array at each level of the tree.
<p>Experimenting by modifying the code to simply calculate the
hash and not store the result show little to no difference in performance.
<p>These preliminary results suggest:
<ol>
<li>The performance of the HashFromByteSlice is pretty good
<li>Go has low overhead for recursive functions
<li>The performance of the HashFromByteSlice routine is dominated
by the actual hashing of data
</ol>
<p>Although this work is in no way exhaustive, point #3 suggests that
optimization of this routine would need to take an alternative
approach to make significant improvements on the current performance.
<p>Finally, considering that the recursive implementation is easier to
read, it might not be worthwhile to switch to a less intuitive
implementation for so little benefit.

			
			

		
			
			
			<h2 id="KeyPathToKeys">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go?s=2238:2296#L77">KeyPathToKeys</a>
				<a class="permalink" href="index.html#KeyPathToKeys">&#xb6;</a>
				
				
			</h2>
			<pre>func KeyPathToKeys(path <a href="../../../../../builtin/index.html#string">string</a>) (keys [][]<a href="../../../../../builtin/index.html#byte">byte</a>, err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>Decode a path to a list of keys. Path must begin with `/`.
Each key must use a known encoding.

			
			

		
		
			
			
			<h2 id="Key">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go?s=1650:1700#L49">Key</a>
				<a class="permalink" href="index.html#Key">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Key struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="KeyPath">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go?s=1702:1720#L54">KeyPath</a>
				<a class="permalink" href="index.html#KeyPath">&#xb6;</a>
				
				
			</h2>
			
			<pre>type KeyPath []<a href="index.html#Key">Key</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="KeyPath.AppendKey">func (KeyPath) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go?s=1722:1787#L56">AppendKey</a>
					<a class="permalink" href="index.html#KeyPath.AppendKey">&#xb6;</a>
					
					
				</h3>
				<pre>func (pth <a href="index.html#KeyPath">KeyPath</a>) AppendKey(key []<a href="../../../../../builtin/index.html#byte">byte</a>, enc keyEncoding) <a href="index.html#KeyPath">KeyPath</a></pre>
				
				
				
				
			
				
				<h3 id="KeyPath.String">func (KeyPath) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_key_path.go?s=1828:1862#L60">String</a>
					<a class="permalink" href="index.html#KeyPath.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (pth <a href="index.html#KeyPath">KeyPath</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="OpDecoder">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2185:2246#L64">OpDecoder</a>
				<a class="permalink" href="index.html#OpDecoder">&#xb6;</a>
				
				
			</h2>
			
			<pre>type OpDecoder func(<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOp">ProofOp</a>) (<a href="index.html#ProofOperator">ProofOperator</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Proof">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=809:1107#L16">Proof</a>
				<a class="permalink" href="index.html#Proof">&#xb6;</a>
				
				
			</h2>
			<p>Proof represents a Merkle proof.
NOTE: The convention for proofs is to include leaf hashes but to
exclude the root hash.
This convention is implemented across IAVL range proofs as well.
Keep this consistent unless there&apos;s a very good reason to change
everything.  This also affects the generalized proof system as
well.

			<pre>type Proof struct {
<span id="Proof.Total"></span>    Total    <a href="../../../../../builtin/index.html#int64">int64</a>    `json:&#34;total&#34;`     <span class="comment">// Total number of items.</span>
<span id="Proof.Index"></span>    Index    <a href="../../../../../builtin/index.html#int64">int64</a>    `json:&#34;index&#34;`     <span class="comment">// Index of item to prove.</span>
<span id="Proof.LeafHash"></span>    LeafHash []<a href="../../../../../builtin/index.html#byte">byte</a>   `json:&#34;leaf_hash&#34;` <span class="comment">// Hash of item value.</span>
<span id="Proof.Aunts"></span>    Aunts    [][]<a href="../../../../../builtin/index.html#byte">byte</a> `json:&#34;aunts&#34;`     <span class="comment">// Hashes from leaf&#39;s sibling to a root&#39;s child.</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ProofFromProto">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=4209:4265#L138">ProofFromProto</a>
					<a class="permalink" href="index.html#ProofFromProto">&#xb6;</a>
					
					
				</h3>
				<pre>func ProofFromProto(pb *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#Proof">Proof</a>) (*<a href="index.html#Proof">Proof</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="ProofsFromByteSlices">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=1215:1291#L25">ProofsFromByteSlices</a>
					<a class="permalink" href="index.html#ProofsFromByteSlices">&#xb6;</a>
					
					
				</h3>
				<pre>func ProofsFromByteSlices(items [][]<a href="../../../../../builtin/index.html#byte">byte</a>) (rootHash []<a href="../../../../../builtin/index.html#byte">byte</a>, proofs []*<a href="index.html#Proof">Proof</a>)</pre>
				<p>ProofsFromByteSlices computes inclusion proof for given items.
proofs[0] is the proof for items[0].

				
				
			

			
				
				<h3 id="Proof.ComputeRootHash">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=2460:2501#L67">ComputeRootHash</a>
					<a class="permalink" href="index.html#Proof.ComputeRootHash">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) ComputeRootHash() []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>Compute the root hash given a leaf hash.  Panics in case of errors.

				
				
				
			
				
				<h3 id="Proof.String">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=2927:2959#L87">String</a>
					<a class="permalink" href="index.html#Proof.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				<p>String implements the stringer interface for Proof.
It is a wrapper around StringIndented.

				
				
				
			
				
				<h3 id="Proof.StringIndented">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=3069:3122#L92">StringIndented</a>
					<a class="permalink" href="index.html#Proof.StringIndented">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) StringIndented(indent <a href="../../../../../builtin/index.html#string">string</a>) <a href="../../../../../builtin/index.html#string">string</a></pre>
				<p>StringIndented generates a canonical string representation of a Proof.

				
				
				
			
				
				<h3 id="Proof.ToProto">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=3997:4040#L124">ToProto</a>
					<a class="permalink" href="index.html#Proof.ToProto">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) ToProto() *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#Proof">Proof</a></pre>
				
				
				
				
			
				
				<h3 id="Proof.ValidateBasic">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=3390:3428#L103">ValidateBasic</a>
					<a class="permalink" href="index.html#Proof.ValidateBasic">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) ValidateBasic() <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>ValidateBasic performs basic validation.
NOTE: it expects the LeafHash and the elements of Aunts to be of size tmhash.Size,
and it expects at most MaxAunts elements in Aunts.

				
				
				
			
				
				<h3 id="Proof.Verify">func (*Proof) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=1684:1743#L42">Verify</a>
					<a class="permalink" href="index.html#Proof.Verify">&#xb6;</a>
					
					
				</h3>
				<pre>func (sp *<a href="index.html#Proof">Proof</a>) Verify(rootHash []<a href="../../../../../builtin/index.html#byte">byte</a>, leaf []<a href="../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>Verify that the Proof proves the root hash.
Check sp.Index/sp.Total manually if needed

				
				
				
			
		
			
			
			<h2 id="ProofNode">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=6040:6235#L194">ProofNode</a>
				<a class="permalink" href="index.html#ProofNode">&#xb6;</a>
				
				
			</h2>
			<p>ProofNode is a helper structure to construct merkle proof.
The node and the tree is thrown away afterwards.
Exactly one of node.Left and node.Right is nil, unless node is the root, in which case both are nil.
node.Parent.Hash = hash(node.Hash, node.Right.Hash) or
hash(node.Left.Hash, node.Hash), depending on whether node is a left/right child.

			<pre>type ProofNode struct {
<span id="ProofNode.Hash"></span>    Hash   []<a href="../../../../../builtin/index.html#byte">byte</a>
<span id="ProofNode.Parent"></span>    Parent *<a href="index.html#ProofNode">ProofNode</a>
<span id="ProofNode.Left"></span>    Left   *<a href="index.html#ProofNode">ProofNode</a> <span class="comment">// Left sibling  (only one of Left,Right is set)</span>
<span id="ProofNode.Right"></span>    Right  *<a href="index.html#ProofNode">ProofNode</a> <span class="comment">// Right sibling (only one of Left,Right is set)</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ProofNode.FlattenAunts">func (*ProofNode) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof.go?s=6357:6402#L203">FlattenAunts</a>
					<a class="permalink" href="index.html#ProofNode.FlattenAunts">&#xb6;</a>
					
					
				</h3>
				<pre>func (spn *<a href="index.html#ProofNode">ProofNode</a>) FlattenAunts() [][]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>FlattenAunts will return the inner hashes for the item corresponding to the leaf,
starting from a leaf ProofNode.

				
				
				
			
		
			
			
			<h2 id="ProofOperator">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=675:786#L11">ProofOperator</a>
				<a class="permalink" href="index.html#ProofOperator">&#xb6;</a>
				
				
			</h2>
			<p>ProofOperator is a layer for calculating intermediate Merkle roots
when a series of Merkle trees are chained together.
Run() takes leaf values from a tree and returns the Merkle
root for the corresponding tree. It takes and returns a list of bytes
to allow multiple leaves to be part of a single proof, for instance in a range proof.
ProofOp() encodes the ProofOperator in a generic way so it can later be
decoded with OpDecoder.

			<pre>type ProofOperator interface {
    Run([][]<a href="../../../../../builtin/index.html#byte">byte</a>) ([][]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)
    GetKey() []<a href="../../../../../builtin/index.html#byte">byte</a>
    ProofOp() <a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOp">ProofOp</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="ValueOpDecoder">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=900:965#L30">ValueOpDecoder</a>
					<a class="permalink" href="index.html#ValueOpDecoder">&#xb6;</a>
					
					
				</h3>
				<pre>func ValueOpDecoder(pop <a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOp">ProofOp</a>) (<a href="index.html#ProofOperator">ProofOperator</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
			

			
		
			
			
			<h2 id="ProofOperators">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=1058:1093#L23">ProofOperators</a>
				<a class="permalink" href="index.html#ProofOperators">&#xb6;</a>
				
				
			</h2>
			<p>ProofOperators is a slice of ProofOperator(s).
Each operator will be applied to the input value sequentially
and the last Merkle root will be verified with already known data

			<pre>type ProofOperators []<a href="index.html#ProofOperator">ProofOperator</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="ProofOperators.Verify">func (ProofOperators) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=1244:1332#L29">Verify</a>
					<a class="permalink" href="index.html#ProofOperators.Verify">&#xb6;</a>
					
					
				</h3>
				<pre>func (poz <a href="index.html#ProofOperators">ProofOperators</a>) Verify(root []<a href="../../../../../builtin/index.html#byte">byte</a>, keypath <a href="../../../../../builtin/index.html#string">string</a>, args [][]<a href="../../../../../builtin/index.html#byte">byte</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ProofOperators.VerifyValue">func (ProofOperators) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=1095:1187#L25">VerifyValue</a>
					<a class="permalink" href="index.html#ProofOperators.VerifyValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (poz <a href="index.html#ProofOperators">ProofOperators</a>) VerifyValue(root []<a href="../../../../../builtin/index.html#byte">byte</a>, keypath <a href="../../../../../builtin/index.html#string">string</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="ProofRuntime">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2248:2307#L66">ProofRuntime</a>
				<a class="permalink" href="index.html#ProofRuntime">&#xb6;</a>
				
				
			</h2>
			
			<pre>type ProofRuntime struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DefaultProofRuntime">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=4038:4084#L125">DefaultProofRuntime</a>
					<a class="permalink" href="index.html#DefaultProofRuntime">&#xb6;</a>
					
					
				</h3>
				<pre>func DefaultProofRuntime() (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>)</pre>
				<p>DefaultProofRuntime only knows about value proofs.
To use e.g. IAVL proofs, register op-decoders as
defined in the IAVL package.

				
				
			
				
				<h3 id="NewProofRuntime">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2309:2345#L70">NewProofRuntime</a>
					<a class="permalink" href="index.html#NewProofRuntime">&#xb6;</a>
					
					
				</h3>
				<pre>func NewProofRuntime() *<a href="index.html#ProofRuntime">ProofRuntime</a></pre>
				
				
				
			

			
				
				<h3 id="ProofRuntime.Decode">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2603:2680#L84">Decode</a>
					<a class="permalink" href="index.html#ProofRuntime.Decode">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) Decode(pop <a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOp">ProofOp</a>) (<a href="index.html#ProofOperator">ProofOperator</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ProofRuntime.DecodeProof">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2831:2918#L92">DecodeProof</a>
					<a class="permalink" href="index.html#ProofRuntime.DecodeProof">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) DecodeProof(proof *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOps">ProofOps</a>) (<a href="index.html#ProofOperators">ProofOperators</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ProofRuntime.RegisterOpDecoder">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=2417:2486#L76">RegisterOpDecoder</a>
					<a class="permalink" href="index.html#ProofRuntime.RegisterOpDecoder">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) RegisterOpDecoder(typ <a href="../../../../../builtin/index.html#string">string</a>, dec <a href="index.html#OpDecoder">OpDecoder</a>)</pre>
				
				
				
				
			
				
				<h3 id="ProofRuntime.Verify">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=3637:3751#L114">Verify</a>
					<a class="permalink" href="index.html#ProofRuntime.Verify">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) Verify(proof *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOps">ProofOps</a>, root []<a href="../../../../../builtin/index.html#byte">byte</a>, keypath <a href="../../../../../builtin/index.html#string">string</a>, args [][]<a href="../../../../../builtin/index.html#byte">byte</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ProofRuntime.VerifyAbsence">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=3479:3585#L110">VerifyAbsence</a>
					<a class="permalink" href="index.html#ProofRuntime.VerifyAbsence">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) VerifyAbsence(proof *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOps">ProofOps</a>, root []<a href="../../../../../builtin/index.html#byte">byte</a>, keypath <a href="../../../../../builtin/index.html#string">string</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>TODO In the long run we&apos;ll need a method of classifcation of ops,
whether existence or absence or perhaps a third?

				
				
				
			
				
				<h3 id="ProofRuntime.VerifyValue">func (*ProofRuntime) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_op.go?s=3176:3294#L104">VerifyValue</a>
					<a class="permalink" href="index.html#ProofRuntime.VerifyValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prt *<a href="index.html#ProofRuntime">ProofRuntime</a>) VerifyValue(proof *<a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOps">ProofOps</a>, root []<a href="../../../../../builtin/index.html#byte">byte</a>, keypath <a href="../../../../../builtin/index.html#string">string</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Tree">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/types.go?s=89:781#L1">Tree</a>
				<a class="permalink" href="index.html#Tree">&#xb6;</a>
				
				
			</h2>
			<p>Tree is a Merkle tree interface.

			<pre>type Tree interface {
    Size() (size <a href="../../../../../builtin/index.html#int">int</a>)
    Height() (height <a href="../../../../../builtin/index.html#int8">int8</a>)
    Has(key []<a href="../../../../../builtin/index.html#byte">byte</a>) (has <a href="../../../../../builtin/index.html#bool">bool</a>)
    Proof(key []<a href="../../../../../builtin/index.html#byte">byte</a>) (value []<a href="../../../../../builtin/index.html#byte">byte</a>, proof []<a href="../../../../../builtin/index.html#byte">byte</a>, exists <a href="../../../../../builtin/index.html#bool">bool</a>) <span class="comment">// TODO make it return an index</span>
    Get(key []<a href="../../../../../builtin/index.html#byte">byte</a>) (index <a href="../../../../../builtin/index.html#int">int</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>, exists <a href="../../../../../builtin/index.html#bool">bool</a>)
    GetByIndex(index <a href="../../../../../builtin/index.html#int">int</a>) (key []<a href="../../../../../builtin/index.html#byte">byte</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>)
    Set(key []<a href="../../../../../builtin/index.html#byte">byte</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>) (updated <a href="../../../../../builtin/index.html#bool">bool</a>)
    Remove(key []<a href="../../../../../builtin/index.html#byte">byte</a>) (value []<a href="../../../../../builtin/index.html#byte">byte</a>, removed <a href="../../../../../builtin/index.html#bool">bool</a>)
    HashWithCount() (hash []<a href="../../../../../builtin/index.html#byte">byte</a>, count <a href="../../../../../builtin/index.html#int">int</a>)
    Hash() (hash []<a href="../../../../../builtin/index.html#byte">byte</a>)
    Save() (hash []<a href="../../../../../builtin/index.html#byte">byte</a>)
    Load(hash []<a href="../../../../../builtin/index.html#byte">byte</a>)
    Copy() <a href="index.html#Tree">Tree</a>
    Iterate(func(key []<a href="../../../../../builtin/index.html#byte">byte</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>) (stop <a href="../../../../../builtin/index.html#bool">bool</a>)) (stopped <a href="../../../../../builtin/index.html#bool">bool</a>)
    IterateRange(start []<a href="../../../../../builtin/index.html#byte">byte</a>, end []<a href="../../../../../builtin/index.html#byte">byte</a>, ascending <a href="../../../../../builtin/index.html#bool">bool</a>, fx func(key []<a href="../../../../../builtin/index.html#byte">byte</a>, value []<a href="../../../../../builtin/index.html#byte">byte</a>) (stop <a href="../../../../../builtin/index.html#bool">bool</a>)) (stopped <a href="../../../../../builtin/index.html#bool">bool</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ValueOp">type <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=637:760#L13">ValueOp</a>
				<a class="permalink" href="index.html#ValueOp">&#xb6;</a>
				
				
			</h2>
			<p>ValueOp takes a key and a single value as argument and
produces the root hash.  The corresponding tree structure is
the SimpleMap tree.  SimpleMap takes a Hasher, and currently
CometBFT uses tmhash.  SimpleValueOp should support
the hash function as used in tmhash.  TODO support
additional hash functions here as options/args to this
operator.
<p>If the produced root hash matches the expected hash, the
proof is good.

			<pre>type ValueOp struct {

    <span class="comment">// To encode in ProofOp.Data</span>
<span id="ValueOp.Proof"></span>    Proof *<a href="index.html#Proof">Proof</a> `json:&#34;proof&#34;`
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewValueOp">func <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=795:844#L23">NewValueOp</a>
					<a class="permalink" href="index.html#NewValueOp">&#xb6;</a>
					
					
				</h3>
				<pre>func NewValueOp(key []<a href="../../../../../builtin/index.html#byte">byte</a>, proof *<a href="index.html#Proof">Proof</a>) <a href="index.html#ValueOp">ValueOp</a></pre>
				
				
				
			

			
				
				<h3 id="ValueOp.GetKey">func (ValueOp) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=2509:2542#L95">GetKey</a>
					<a class="permalink" href="index.html#ValueOp.GetKey">&#xb6;</a>
					
					
				</h3>
				<pre>func (op <a href="index.html#ValueOp">ValueOp</a>) GetKey() []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				
				
				
				
			
				
				<h3 id="ValueOp.ProofOp">func (ValueOp) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=1420:1465#L47">ProofOp</a>
					<a class="permalink" href="index.html#ValueOp.ProofOp">&#xb6;</a>
					
					
				</h3>
				<pre>func (op <a href="index.html#ValueOp">ValueOp</a>) ProofOp() <a href="../../proto/tendermint/crypto/index.html">cmtcrypto</a>.<a href="../../proto/tendermint/crypto/index.html#ProofOp">ProofOp</a></pre>
				
				
				
				
			
				
				<h3 id="ValueOp.Run">func (ValueOp) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=1777:1831#L67">Run</a>
					<a class="permalink" href="index.html#ValueOp.Run">&#xb6;</a>
					
					
				</h3>
				<pre>func (op <a href="index.html#ValueOp">ValueOp</a>) Run(args [][]<a href="../../../../../builtin/index.html#byte">byte</a>) ([][]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="ValueOp.String">func (ValueOp) <a href="http://localhost:6060/src/github.com/cometbft/cometbft/crypto/merkle/proof_value.go?s=1690:1723#L63">String</a>
					<a class="permalink" href="index.html#ValueOp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (op <a href="index.html#ValueOp">ValueOp</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
