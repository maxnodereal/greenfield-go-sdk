<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ssz - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ssz
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/prysmaticlabs/prysm/encoding/ssz"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package ssz defines HashTreeRoot utility functions.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#BitlistRoot">func BitlistRoot(hasher HashFn, bfield bitfield.Bitfield, maxCapacity uint64) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#BitwiseMerkleize">func BitwiseMerkleize(hasher HashFn, chunks [][]byte, count, limit uint64) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#BitwiseMerkleizeArrays">func BitwiseMerkleizeArrays(hasher HashFn, chunks [][32]byte, count, limit uint64) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#ByteArrayRootWithLimit">func ByteArrayRootWithLimit(roots [][]byte, limit uint64) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#CheckpointRoot">func CheckpointRoot(hasher HashFn, checkpoint *ethpb.Checkpoint) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#ConstructProof">func ConstructProof(hasher Hasher, count, limit uint64, leaf func(i uint64) []byte, index uint64) (branch [][32]byte)</a></dd>
			
				
				<dd><a href="index.html#DeepEqual">func DeepEqual(x, y interface{}) bool</a></dd>
			
				
				<dd><a href="index.html#Depth">func Depth(v uint64) (out uint8)</a></dd>
			
				
				<dd><a href="index.html#ForkRoot">func ForkRoot(fork *ethpb.Fork) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#IsProto">func IsProto(item interface{}) bool</a></dd>
			
				
				<dd><a href="index.html#Merkleize">func Merkleize(hasher Hasher, count, limit uint64, leaf func(i uint64) []byte) (out [32]byte)</a></dd>
			
				
				<dd><a href="index.html#MixInLength">func MixInLength(root [32]byte, length []byte) [32]byte</a></dd>
			
				
				<dd><a href="index.html#Pack">func Pack(serializedItems [][]byte) ([][]byte, error)</a></dd>
			
				
				<dd><a href="index.html#PackByChunk">func PackByChunk(serializedItems [][]byte) ([][bytesPerChunk]byte, error)</a></dd>
			
				
				<dd><a href="index.html#PackChunks">func PackChunks(bytes []byte) ([][]byte, error)</a></dd>
			
				
				<dd><a href="index.html#SlashingsRoot">func SlashingsRoot(slashings []uint64) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#TransactionsRoot">func TransactionsRoot(txs [][]byte) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#Uint64Root">func Uint64Root(val uint64) [32]byte</a></dd>
			
			
				
				<dd><a href="index.html#HashFn">type HashFn</a></dd>
				
				
			
				
				<dd><a href="index.html#Hasher">type Hasher</a></dd>
				
				
			
				
				<dd><a href="index.html#HasherFunc">type HasherFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewHasherFunc">func NewHasherFunc(h HashFn) *HasherFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HasherFunc.Combi">func (h *HasherFunc) Combi(a, b [32]byte) [32]byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HasherFunc.Hash">func (h *HasherFunc) Hash(a []byte) [32]byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#HasherFunc.MixIn">func (h *HasherFunc) MixIn(a [32]byte, i uint64) [32]byte</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/deep_equal.go">deep_equal.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go">hashers.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go">helpers.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go">htrutils.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/merkleize.go">merkleize.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="BitlistRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=360:455#L7">BitlistRoot</a>
				<a class="permalink" href="index.html#BitlistRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func BitlistRoot(hasher <a href="index.html#HashFn">HashFn</a>, bfield bitfield.<a href="index.html#Bitfield">Bitfield</a>, maxCapacity <a href="../../../../../builtin/index.html#uint64">uint64</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BitlistRoot returns the mix in length of a bitwise Merkleized bitfield.

			
			

		
			
			
			<h2 id="BitwiseMerkleize">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=1471:1563#L39">BitwiseMerkleize</a>
				<a class="permalink" href="index.html#BitwiseMerkleize">&#xb6;</a>
				
				
			</h2>
			<pre>func BitwiseMerkleize(hasher <a href="index.html#HashFn">HashFn</a>, chunks [][]<a href="../../../../../builtin/index.html#byte">byte</a>, count, limit <a href="../../../../../builtin/index.html#uint64">uint64</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BitwiseMerkleize - given ordered BYTES_PER_CHUNK-byte chunks, if necessary utilize
zero chunks so that the number of chunks is a power of two, Merkleize the chunks,
and return the root.
Note that merkleize on a single chunk is simply that chunk, i.e. the identity
when the number of chunks is one.

			
			

		
			
			
			<h2 id="BitwiseMerkleizeArrays">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=1909:2009#L51">BitwiseMerkleizeArrays</a>
				<a class="permalink" href="index.html#BitwiseMerkleizeArrays">&#xb6;</a>
				
				
			</h2>
			<pre>func BitwiseMerkleizeArrays(hasher <a href="index.html#HashFn">HashFn</a>, chunks [][32]<a href="../../../../../builtin/index.html#byte">byte</a>, count, limit <a href="../../../../../builtin/index.html#uint64">uint64</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BitwiseMerkleizeArrays is used when a set of 32-byte root chunks are provided.

			
			

		
			
			
			<h2 id="ByteArrayRootWithLimit">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=2122:2197#L51">ByteArrayRootWithLimit</a>
				<a class="permalink" href="index.html#ByteArrayRootWithLimit">&#xb6;</a>
				
				
			</h2>
			<pre>func ByteArrayRootWithLimit(roots [][]<a href="../../../../../builtin/index.html#byte">byte</a>, limit <a href="../../../../../builtin/index.html#uint64">uint64</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ByteArrayRootWithLimit computes the HashTreeRoot Merkleization of
a list of [32]byte roots according to the Ethereum Simple Serialize
specification.

			
			

		
			
			
			<h2 id="CheckpointRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=1468:1550#L35">CheckpointRoot</a>
				<a class="permalink" href="index.html#CheckpointRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func CheckpointRoot(hasher <a href="index.html#HashFn">HashFn</a>, checkpoint *<a href="../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../proto/prysm/v1alpha1/index.html#Checkpoint">Checkpoint</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>CheckpointRoot computes the HashTreeRoot Merkleization of
a InitWithReset struct value according to the Ethereum
Simple Serialize specification.

			
			

		
			
			
			<h2 id="ConstructProof">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/merkleize.go?s=3037:3154#L126">ConstructProof</a>
				<a class="permalink" href="index.html#ConstructProof">&#xb6;</a>
				
				
			</h2>
			<pre>func ConstructProof(hasher <a href="index.html#Hasher">Hasher</a>, count, limit <a href="../../../../../builtin/index.html#uint64">uint64</a>, leaf func(i <a href="../../../../../builtin/index.html#uint64">uint64</a>) []<a href="../../../../../builtin/index.html#byte">byte</a>, index <a href="../../../../../builtin/index.html#uint64">uint64</a>) (branch [][32]<a href="../../../../../builtin/index.html#byte">byte</a>)</pre>
			<p>ConstructProof builds a merkle-branch of the given depth, at the given index (at that depth),
for a list of leafs of a balanced binary tree.

			
			

		
			
			
			<h2 id="DeepEqual">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/deep_equal.go?s=9447:9484#L287">DeepEqual</a>
				<a class="permalink" href="index.html#DeepEqual">&#xb6;</a>
				
				
			</h2>
			<pre>func DeepEqual(x, y interface{}) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
			<p>DeepEqual reports whether two SSZ-able values x and y are “deeply equal,” defined as follows:
Two values of identical type are deeply equal if one of the following cases applies:
<p>Values of distinct types are never deeply equal.
<p>Array values are deeply equal when their corresponding elements are deeply equal.
<p>Struct values are deeply equal if their corresponding fields,
both exported and unexported, are deeply equal.
<p>Interface values are deeply equal if they hold deeply equal concrete values.
<p>Pointer values are deeply equal if they are equal using Go&apos;s == operator
or if they point to deeply equal values.
<p>Slice values are deeply equal when all of the following are true:
they are both nil, one is nil and the other is empty or vice-versa,
they have the same length, and either they point to the same initial entry of the same array
(that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal.
<p>Other values - numbers, bools, strings, and channels - are deeply equal
if they are equal using Go&apos;s == operator.
<p>In general DeepEqual is a recursive relaxation of Go&apos;s == operator.
However, this idea is impossible to implement without some inconsistency.
Specifically, it is possible for a value to be unequal to itself,
either because it is of func type (uncomparable in general)
or because it is a floating-point NaN value (not equal to itself in floating-point comparison),
or because it is an array, struct, or interface containing
such a value.
<p>On the other hand, pointer values are always equal to themselves,
even if they point at or contain such problematic values,
because they compare equal using Go&apos;s == operator, and that
is a sufficient condition to be deeply equal, regardless of content.
DeepEqual has been defined so that the same short-cut applies
to slices and maps: if x and y are the same slice or the same map,
they are deeply equal regardless of content.
<p>As DeepEqual traverses the data values it may find a cycle. The
second and subsequent times that DeepEqual compares two pointer
values that have been compared before, it treats the values as
equal rather than examining the values to which they point.
This ensures that DeepEqual terminates.
<p>Credits go to the Go team as this is an extension of the official Go source code&apos;s
reflect.DeepEqual function to handle special SSZ edge cases.

			
			

		
			
			
			<h2 id="Depth">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/merkleize.go?s=601:633#L22">Depth</a>
				<a class="permalink" href="index.html#Depth">&#xb6;</a>
				
				
			</h2>
			<pre>func Depth(v <a href="../../../../../builtin/index.html#uint64">uint64</a>) (out <a href="../../../../../builtin/index.html#uint8">uint8</a>)</pre>
			<p>Depth retrieves the appropriate depth for the provided trie size.

			
			

		
			
			
			<h2 id="ForkRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=740:789#L17">ForkRoot</a>
				<a class="permalink" href="index.html#ForkRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func ForkRoot(fork *<a href="../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../proto/prysm/v1alpha1/index.html#Fork">Fork</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ForkRoot computes the HashTreeRoot Merkleization of
a Fork struct value according to the Ethereum
Simple Serialize specification.

			
			

		
			
			
			<h2 id="IsProto">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/deep_equal.go?s=9837:9872#L303">IsProto</a>
				<a class="permalink" href="index.html#IsProto">&#xb6;</a>
				
				
			</h2>
			<pre>func IsProto(item interface{}) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="Merkleize">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/merkleize.go?s=1350:1443#L60">Merkleize</a>
				<a class="permalink" href="index.html#Merkleize">&#xb6;</a>
				
				
			</h2>
			<pre>func Merkleize(hasher <a href="index.html#Hasher">Hasher</a>, count, limit <a href="../../../../../builtin/index.html#uint64">uint64</a>, leaf func(i <a href="../../../../../builtin/index.html#uint64">uint64</a>) []<a href="../../../../../builtin/index.html#byte">byte</a>) (out [32]<a href="../../../../../builtin/index.html#byte">byte</a>)</pre>
			<p>Merkleize with log(N) space allocation

			
			

		
			
			
			<h2 id="MixInLength">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=5596:5651#L155">MixInLength</a>
				<a class="permalink" href="index.html#MixInLength">&#xb6;</a>
				
				
			</h2>
			<pre>func MixInLength(root [32]<a href="../../../../../builtin/index.html#byte">byte</a>, length []<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
			<p>MixInLength appends hash length to root

			
			

		
			
			
			<h2 id="Pack">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=2340:2393#L63">Pack</a>
				<a class="permalink" href="index.html#Pack">&#xb6;</a>
				
				
			</h2>
			<pre>func Pack(serializedItems [][]<a href="../../../../../builtin/index.html#byte">byte</a>) ([][]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>Pack a given byte array&apos;s final chunk with zeroes if needed.

			
			

		
			
			
			<h2 id="PackByChunk">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/helpers.go?s=3838:3911#L108">PackByChunk</a>
				<a class="permalink" href="index.html#PackByChunk">&#xb6;</a>
				
				
			</h2>
			<pre>func PackByChunk(serializedItems [][]<a href="../../../../../builtin/index.html#byte">byte</a>) ([][bytesPerChunk]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>PackByChunk a given byte array&apos;s final chunk with zeroes if needed.

			
			

		
			
			
			<h2 id="PackChunks">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=5467:5514#L134">PackChunks</a>
				<a class="permalink" href="index.html#PackChunks">&#xb6;</a>
				
				
			</h2>
			<pre>func PackChunks(bytes []<a href="../../../../../builtin/index.html#byte">byte</a>) ([][]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>PackChunks a given byte array into chunks. It&apos;ll pad the last chunk with zero bytes if
it does not have length bytes per chunk.

			
			

		
			
			
			<h2 id="SlashingsRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=2913:2969#L70">SlashingsRoot</a>
				<a class="permalink" href="index.html#SlashingsRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func SlashingsRoot(slashings []<a href="../../../../../builtin/index.html#uint64">uint64</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>SlashingsRoot computes the HashTreeRoot Merkleization of
a list of uint64 slashing values according to the Ethereum
Simple Serialize specification.

			
			

		
			
			
			<h2 id="TransactionsRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=3715:3768#L87">TransactionsRoot</a>
				<a class="permalink" href="index.html#TransactionsRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func TransactionsRoot(txs [][]<a href="../../../../../builtin/index.html#byte">byte</a>) ([32]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>TransactionsRoot computes the HTR for the Transactions&apos; property of the ExecutionPayload
The code was largely copy/pasted from the code generated to compute the HTR of the entire
ExecutionPayload.

			
			

		
			
			
			<h2 id="Uint64Root">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/htrutils.go?s=447:483#L7">Uint64Root</a>
				<a class="permalink" href="index.html#Uint64Root">&#xb6;</a>
				
				
			</h2>
			<pre>func Uint64Root(val <a href="../../../../../builtin/index.html#uint64">uint64</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
			<p>Uint64Root computes the HashTreeRoot Merkleization of
a simple uint64 value according to the Ethereum
Simple Serialize specification.

			
			

		
		
			
			
			<h2 id="HashFn">type <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=89:128#L1">HashFn</a>
				<a class="permalink" href="index.html#HashFn">&#xb6;</a>
				
				
			</h2>
			<p>HashFn is the generic hash function signature.

			<pre>type HashFn func(input []<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Hasher">type <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=239:367#L1">Hasher</a>
				<a class="permalink" href="index.html#Hasher">&#xb6;</a>
				
				
			</h2>
			<p>Hasher describes an interface through which we can
perform hash operations on byte arrays,indices,etc.

			<pre>type Hasher interface {
    Hash(a []<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a>
    Combi(a [32]<a href="../../../../../builtin/index.html#byte">byte</a>, b [32]<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a>
    MixIn(a [32]<a href="../../../../../builtin/index.html#byte">byte</a>, i <a href="../../../../../builtin/index.html#uint64">uint64</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="HasherFunc">type <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=478:540#L8">HasherFunc</a>
				<a class="permalink" href="index.html#HasherFunc">&#xb6;</a>
				
				
			</h2>
			<p>HasherFunc defines a structure to hold a hash function and can be used for multiple rounds of
hashing.

			<pre>type HasherFunc struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewHasherFunc">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=632:672#L15">NewHasherFunc</a>
					<a class="permalink" href="index.html#NewHasherFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func NewHasherFunc(h <a href="index.html#HashFn">HashFn</a>) *<a href="index.html#HasherFunc">HasherFunc</a></pre>
				<p>NewHasherFunc is the constructor for the object
that fulfills the Hasher interface.

				
				
			

			
				
				<h3 id="HasherFunc.Combi">func (*HasherFunc) <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=925:975#L29">Combi</a>
					<a class="permalink" href="index.html#HasherFunc.Combi">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#HasherFunc">HasherFunc</a>) Combi(a, b [32]<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>Combi appends the two inputs and hashes them.

				
				
				
			
				
				<h3 id="HasherFunc.Hash">func (*HasherFunc) <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=804:848#L24">Hash</a>
					<a class="permalink" href="index.html#HasherFunc.Hash">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#HasherFunc">HasherFunc</a>) Hash(a []<a href="../../../../../builtin/index.html#byte">byte</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>Hash utilizes the provided hash function for
the object.

				
				
				
			
				
				<h3 id="HasherFunc.MixIn">func (*HasherFunc) <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/encoding/ssz/hashers.go?s=1117:1174#L36">MixIn</a>
					<a class="permalink" href="index.html#HasherFunc.MixIn">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#HasherFunc">HasherFunc</a>) MixIn(a [32]<a href="../../../../../builtin/index.html#byte">byte</a>, i <a href="../../../../../builtin/index.html#uint64">uint64</a>) [32]<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>MixIn works like Combi, but using an integer as the second input.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
