<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>blocks - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package blocks
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/prysmaticlabs/prysm/beacon-chain/core/blocks"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package blocks contains block processing libraries according to
the Ethereum beacon chain spec.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#ActivateValidatorWithEffectiveBalance">func ActivateValidatorWithEffectiveBalance(beaconState state.BeaconState, deposits []*ethpb.Deposit) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#AreEth1DataEqual">func AreEth1DataEqual(a, b *ethpb.Eth1Data) bool</a></dd>
			
				
				<dd><a href="index.html#AttestationSignatureBatch">func AttestationSignatureBatch(ctx context.Context, beaconState state.ReadOnlyBeaconState, atts []*ethpb.Attestation) (*bls.SignatureBatch, error)</a></dd>
			
				
				<dd><a href="index.html#BatchVerifyDepositsSignatures">func BatchVerifyDepositsSignatures(ctx context.Context, deposits []*ethpb.Deposit) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#BlockSignatureBatch">func BlockSignatureBatch(beaconState state.ReadOnlyBeaconState, proposerIndex types.ValidatorIndex, sig []byte, rootFunc func() ([32]byte, error)) (*bls.SignatureBatch, error)</a></dd>
			
				
				<dd><a href="index.html#Eth1DataHasEnoughSupport">func Eth1DataHasEnoughSupport(beaconState state.ReadOnlyBeaconState, data *ethpb.Eth1Data) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#ExecutionEnabled">func ExecutionEnabled(st state.BeaconState, blk block.BeaconBlockBody) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#IsMergeBlock">func IsMergeBlock(st state.BeaconState, blk block.BeaconBlockBody) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#IsSlashableAttestationData">func IsSlashableAttestationData(data1, data2 *ethpb.AttestationData) bool</a></dd>
			
				
				<dd><a href="index.html#MergeComplete">func MergeComplete(st state.BeaconState) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#NewGenesisBlock">func NewGenesisBlock(stateRoot []byte) *ethpb.SignedBeaconBlock</a></dd>
			
				
				<dd><a href="index.html#PayloadToHeader">func PayloadToHeader(payload *ethpb.ExecutionPayload) (*ethpb.ExecutionPayloadHeader, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessAttestationNoVerifySignature">func ProcessAttestationNoVerifySignature(ctx context.Context, beaconState state.BeaconState, att *ethpb.Attestation) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessAttestationsNoVerifySignature">func ProcessAttestationsNoVerifySignature(ctx context.Context, beaconState state.BeaconState, b block.SignedBeaconBlock) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessAttesterSlashing">func ProcessAttesterSlashing(ctx context.Context, beaconState state.BeaconState, slashing *ethpb.AttesterSlashing, slashFunc slashValidatorFunc) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessAttesterSlashings">func ProcessAttesterSlashings(ctx context.Context, beaconState state.BeaconState, slashings []*ethpb.AttesterSlashing, slashFunc slashValidatorFunc) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessBlockHeader">func ProcessBlockHeader(ctx context.Context, beaconState state.BeaconState, block block.SignedBeaconBlock) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessBlockHeaderNoVerify">func ProcessBlockHeaderNoVerify(ctx context.Context, beaconState state.BeaconState, slot types.Slot, proposerIndex types.ValidatorIndex, parentRoot, bodyRoot []byte) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessDeposit">func ProcessDeposit(beaconState state.BeaconState, deposit *ethpb.Deposit, verifySignature bool) (state.BeaconState, bool, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessDeposits">func ProcessDeposits(ctx context.Context, beaconState state.BeaconState, deposits []*ethpb.Deposit) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessEth1DataInBlock">func ProcessEth1DataInBlock(_ context.Context, beaconState state.BeaconState, eth1Data *ethpb.Eth1Data) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessPayload">func ProcessPayload(st state.BeaconState, payload *ethpb.ExecutionPayload) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessPreGenesisDeposits">func ProcessPreGenesisDeposits(ctx context.Context, beaconState state.BeaconState, deposits []*ethpb.Deposit) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessProposerSlashing">func ProcessProposerSlashing(ctx context.Context, beaconState state.BeaconState, slashing *ethpb.ProposerSlashing, slashFunc slashValidatorFunc) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessProposerSlashings">func ProcessProposerSlashings(ctx context.Context, beaconState state.BeaconState, slashings []*ethpb.ProposerSlashing, slashFunc slashValidatorFunc) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessRandao">func ProcessRandao(ctx context.Context, beaconState state.BeaconState, b block.SignedBeaconBlock) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessRandaoNoVerify">func ProcessRandaoNoVerify(beaconState state.BeaconState, randaoReveal []byte) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#ProcessVoluntaryExits">func ProcessVoluntaryExits(ctx context.Context, beaconState state.BeaconState, exits []*ethpb.SignedVoluntaryExit) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#RandaoSignatureBatch">func RandaoSignatureBatch(ctx context.Context, beaconState state.ReadOnlyBeaconState, reveal []byte) (*bls.SignatureBatch, error)</a></dd>
			
				
				<dd><a href="index.html#SlashableAttesterIndices">func SlashableAttesterIndices(slashing *ethpb.AttesterSlashing) []uint64</a></dd>
			
				
				<dd><a href="index.html#ValidatePayload">func ValidatePayload(st state.BeaconState, payload *ethpb.ExecutionPayload) error</a></dd>
			
				
				<dd><a href="index.html#ValidatePayloadWhenMergeCompletes">func ValidatePayloadWhenMergeCompletes(st state.BeaconState, payload *ethpb.ExecutionPayload) error</a></dd>
			
				
				<dd><a href="index.html#VerifyAttestationNoVerifySignature">func VerifyAttestationNoVerifySignature(ctx context.Context, beaconState state.ReadOnlyBeaconState, att *ethpb.Attestation) error</a></dd>
			
				
				<dd><a href="index.html#VerifyAttestationSignature">func VerifyAttestationSignature(ctx context.Context, beaconState state.ReadOnlyBeaconState, att *ethpb.Attestation) error</a></dd>
			
				
				<dd><a href="index.html#VerifyAttesterSlashing">func VerifyAttesterSlashing(ctx context.Context, beaconState state.ReadOnlyBeaconState, slashing *ethpb.AttesterSlashing) error</a></dd>
			
				
				<dd><a href="index.html#VerifyBlockHeaderSignature">func VerifyBlockHeaderSignature(beaconState state.BeaconState, header *ethpb.SignedBeaconBlockHeader) error</a></dd>
			
				
				<dd><a href="index.html#VerifyBlockSignature">func VerifyBlockSignature(beaconState state.ReadOnlyBeaconState, proposerIndex types.ValidatorIndex, sig []byte, rootFunc func() ([32]byte, error)) error</a></dd>
			
				
				<dd><a href="index.html#VerifyBlockSignatureUsingCurrentFork">func VerifyBlockSignatureUsingCurrentFork(beaconState state.ReadOnlyBeaconState, blk block.SignedBeaconBlock) error</a></dd>
			
				
				<dd><a href="index.html#VerifyExitAndSignature">func VerifyExitAndSignature(validator state.ReadOnlyValidator, currentSlot types.Slot, fork *ethpb.Fork, signed *ethpb.SignedVoluntaryExit, genesisRoot []byte) error</a></dd>
			
				
				<dd><a href="index.html#VerifyIndexedAttestation">func VerifyIndexedAttestation(ctx context.Context, beaconState state.ReadOnlyBeaconState, indexedAtt *ethpb.IndexedAttestation) error</a></dd>
			
				
				<dd><a href="index.html#VerifyProposerSlashing">func VerifyProposerSlashing(beaconState state.ReadOnlyBeaconState, slashing *ethpb.ProposerSlashing) error</a></dd>
			
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go">attestation.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go">attester_slashing.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go">deposit.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/eth1_data.go">eth1_data.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/exit.go">exit.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/genesis.go">genesis.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/header.go">header.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/log.go">log.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go">payload.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/proposer_slashing.go">proposer_slashing.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/randao.go">randao.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go">signature.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>ValidatorAlreadyExitedMsg defines a message saying that a validator has already exited.

				<pre>var <span id="ValidatorAlreadyExitedMsg">ValidatorAlreadyExitedMsg</span> = &#34;has already submitted an exit, which will take place at epoch&#34;</pre>
			
				<p>ValidatorCannotExitYetMsg defines a message saying that a validator cannot exit
because it has not been active long enough.

				<pre>var <span id="ValidatorCannotExitYetMsg">ValidatorCannotExitYetMsg</span> = &#34;validator has not been active long enough to exit&#34;</pre>
			
		
		
			
			
			<h2 id="ActivateValidatorWithEffectiveBalance">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go?s=1288:1415#L29">ActivateValidatorWithEffectiveBalance</a>
				<a class="permalink" href="index.html#ActivateValidatorWithEffectiveBalance">&#xb6;</a>
				
				
			</h2>
			<pre>func ActivateValidatorWithEffectiveBalance(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, deposits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ActivateValidatorWithEffectiveBalance updates validator&apos;s effective balance, and if it&apos;s above MaxEffectiveBalance, validator becomes active in genesis.

			
			

		
			
			
			<h2 id="AreEth1DataEqual">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/eth1_data.go?s=1294:1342#L32">AreEth1DataEqual</a>
				<a class="permalink" href="index.html#AreEth1DataEqual">&#xb6;</a>
				
				
			</h2>
			<pre>func AreEth1DataEqual(a, b *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Eth1Data">Eth1Data</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>AreEth1DataEqual checks equality between two eth1 data objects.

			
			

		
			
			
			<h2 id="AttestationSignatureBatch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=7915:8061#L218">AttestationSignatureBatch</a>
				<a class="permalink" href="index.html#AttestationSignatureBatch">&#xb6;</a>
				
				
			</h2>
			<pre>func AttestationSignatureBatch(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, atts []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) (*<a href="../../../crypto/bls/index.html">bls</a>.<a href="../../../crypto/bls/index.html#SignatureBatch">SignatureBatch</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>AttestationSignatureBatch retrieves all the related attestation signature data such as the relevant public keys,
signatures and attestation signing data and collate it into a signature batch object.

			
			

		
			
			
			<h2 id="BatchVerifyDepositsSignatures">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go?s=3473:3569#L91">BatchVerifyDepositsSignatures</a>
				<a class="permalink" href="index.html#BatchVerifyDepositsSignatures">&#xb6;</a>
				
				
			</h2>
			<pre>func BatchVerifyDepositsSignatures(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, deposits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BatchVerifyDepositsSignatures batch verifies deposit signatures.

			
			

		
			
			
			<h2 id="BlockSignatureBatch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=4396:4574#L110">BlockSignatureBatch</a>
				<a class="permalink" href="index.html#BlockSignatureBatch">&#xb6;</a>
				
				
			</h2>
			<pre>func BlockSignatureBatch(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>,
    proposerIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
    sig []<a href="../../../../../../builtin/index.html#byte">byte</a>,
    rootFunc func() ([32]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)) (*<a href="../../../crypto/bls/index.html">bls</a>.<a href="../../../crypto/bls/index.html#SignatureBatch">SignatureBatch</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BlockSignatureBatch retrieves the block signature batch from the provided block and its corresponding state.

			
			

		
			
			
			<h2 id="Eth1DataHasEnoughSupport">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/eth1_data.go?s=1907:2011#L48">Eth1DataHasEnoughSupport</a>
				<a class="permalink" href="index.html#Eth1DataHasEnoughSupport">&#xb6;</a>
				
				
			</h2>
			<pre>func Eth1DataHasEnoughSupport(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, data *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Eth1Data">Eth1Data</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>Eth1DataHasEnoughSupport returns true when the given eth1data has more than 50% votes in the
eth1 voting period. A vote is cast by including eth1data in a block and part of state processing
appends eth1data to the state in the Eth1DataVotes list. Iterating through this list checks the
votes to see if they match the eth1data.

			
			

		
			
			
			<h2 id="ExecutionEnabled">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=2122:2206#L52">ExecutionEnabled</a>
				<a class="permalink" href="index.html#ExecutionEnabled">&#xb6;</a>
				
				
			</h2>
			<pre>func ExecutionEnabled(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, blk <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#BeaconBlockBody">BeaconBlockBody</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ExecutionEnabled returns true if the beacon chain can begin executing.
Meaning the payload header is beacon state is non-empty or the payload in block body is non-empty.
<p>Spec code:
def is_execution_enabled(state: BeaconState, body: BeaconBlockBody) -&gt; bool:
<pre>return is_merge_block(state, body) or is_merge_complete(state)
</pre>

			
			

		
			
			
			<h2 id="IsMergeBlock">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=1451:1531#L30">IsMergeBlock</a>
				<a class="permalink" href="index.html#IsMergeBlock">&#xb6;</a>
				
				
			</h2>
			<pre>func IsMergeBlock(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, blk <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#BeaconBlockBody">BeaconBlockBody</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IsMergeBlock returns true if the input block is the terminal merge block.
Meaning the header in beacon state is  `ExecutionPayloadHeader()` (i.e. empty).
And the input block has a non-empty header.
<p>Spec code:
def is_merge_block(state: BeaconState, body: BeaconBlockBody) -&gt; bool:
<pre>return not is_merge_complete(state) and body.execution_payload != ExecutionPayload()
</pre>

			
			

		
			
			
			<h2 id="IsSlashableAttestationData">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go?s=5508:5581#L135">IsSlashableAttestationData</a>
				<a class="permalink" href="index.html#IsSlashableAttestationData">&#xb6;</a>
				
				
			</h2>
			<pre>func IsSlashableAttestationData(data1, data2 *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttestationData">AttestationData</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsSlashableAttestationData verifies a slashing against the Casper Proof of Stake FFG rules.
<p>Spec pseudocode definition:
<pre>def is_slashable_attestation_data(data_1: AttestationData, data_2: AttestationData) -&gt; bool:
 &quot;&quot;&quot;
 Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.
 &quot;&quot;&quot;
 return (
     # Double vote
     (data_1 != data_2 and data_1.target.epoch == data_2.target.epoch) or
     # Surround vote
     (data_1.source.epoch &lt; data_2.source.epoch and data_2.target.epoch &lt; data_1.target.epoch)
 )
</pre>

			
			

		
			
			
			<h2 id="MergeComplete">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=885:939#L14">MergeComplete</a>
				<a class="permalink" href="index.html#MergeComplete">&#xb6;</a>
				
				
			</h2>
			<pre>func MergeComplete(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>MergeComplete returns true if the transition to merge has completed.
Meaning the payload header in beacon state is not `ExecutionPayloadHeader()` (i.e. not empty).
<p>Spec code:
def is_merge_complete(state: BeaconState) -&gt; bool:
<pre>return state.latest_execution_payload_header != ExecutionPayloadHeader()
</pre>

			
			

		
			
			
			<h2 id="NewGenesisBlock">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/genesis.go?s=444:507#L3">NewGenesisBlock</a>
				<a class="permalink" href="index.html#NewGenesisBlock">&#xb6;</a>
				
				
			</h2>
			<pre>func NewGenesisBlock(stateRoot []<a href="../../../../../../builtin/index.html#byte">byte</a>) *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#SignedBeaconBlock">SignedBeaconBlock</a></pre>
			<p>NewGenesisBlock returns the canonical, genesis block for the beacon chain protocol.

			
			

		
			
			
			<h2 id="PayloadToHeader">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=6124:6216#L168">PayloadToHeader</a>
				<a class="permalink" href="index.html#PayloadToHeader">&#xb6;</a>
				
				
			</h2>
			<pre>func PayloadToHeader(payload *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ExecutionPayload">ExecutionPayload</a>) (*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ExecutionPayloadHeader">ExecutionPayloadHeader</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>PayloadToHeader converts `payload` into execution payload header format.

			
			

		
			
			
			<h2 id="ProcessAttestationNoVerifySignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go?s=4319:4468#L118">ProcessAttestationNoVerifySignature</a>
				<a class="permalink" href="index.html#ProcessAttestationNoVerifySignature">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessAttestationNoVerifySignature(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    att *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessAttestationNoVerifySignature processes the attestation without verifying the attestation signature. This
method is used to validate attestations whose signatures have already been verified.

			
			

		
			
			
			<h2 id="ProcessAttestationsNoVerifySignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go?s=851:1004#L13">ProcessAttestationsNoVerifySignature</a>
				<a class="permalink" href="index.html#ProcessAttestationsNoVerifySignature">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessAttestationsNoVerifySignature(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    b <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#SignedBeaconBlock">SignedBeaconBlock</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessAttestationsNoVerifySignature applies processing operations to a block&apos;s inner attestation
records. The only difference would be that the attestation signature would not be verified.

			
			

		
			
			
			<h2 id="ProcessAttesterSlashing">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go?s=2079:2257#L46">ProcessAttesterSlashing</a>
				<a class="permalink" href="index.html#ProcessAttesterSlashing">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessAttesterSlashing(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    slashing *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttesterSlashing">AttesterSlashing</a>,
    slashFunc slashValidatorFunc,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessAttesterSlashing processes individual attester slashing.

			
			

		
			
			
			<h2 id="ProcessAttesterSlashings">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go?s=1618:1800#L29">ProcessAttesterSlashings</a>
				<a class="permalink" href="index.html#ProcessAttesterSlashings">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessAttesterSlashings(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    slashings []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttesterSlashing">AttesterSlashing</a>,
    slashFunc slashValidatorFunc,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessAttesterSlashings is one of the operations performed
on each processed beacon block to slash attesters based on
Casper FFG slashing conditions if any slashable events occurred.
<p>Spec pseudocode definition:
<pre>def process_attester_slashing(state: BeaconState, attester_slashing: AttesterSlashing) -&gt; None:
 attestation_1 = attester_slashing.attestation_1
 attestation_2 = attester_slashing.attestation_2
 assert is_slashable_attestation_data(attestation_1.data, attestation_2.data)
 assert is_valid_indexed_attestation(state, attestation_1)
 assert is_valid_indexed_attestation(state, attestation_2)

 slashed_any = False
 indices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)
 for index in sorted(indices):
     if is_slashable_validator(state.validators[index], get_current_epoch(state)):
         slash_validator(state, index)
         slashed_any = True
 assert slashed_any
</pre>

			
			

		
			
			
			<h2 id="ProcessBlockHeader">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/header.go?s=1475:1614#L31">ProcessBlockHeader</a>
				<a class="permalink" href="index.html#ProcessBlockHeader">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessBlockHeader(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    block <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#SignedBeaconBlock">SignedBeaconBlock</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessBlockHeader validates a block by its header.
<p>Spec pseudocode definition:
<pre>def process_block_header(state: BeaconState, block: BeaconBlock) -&gt; None:
  # Verify that the slots match
  assert block.slot == state.slot
  # Verify that the block is newer than latest block header
  assert block.slot &gt; state.latest_block_header.slot
  # Verify that proposer index is the correct index
  assert block.proposer_index == get_beacon_proposer_index(state)
  # Verify that the parent matches
  assert block.parent_root == hash_tree_root(state.latest_block_header)
  # Cache current block as the new latest block
  state.latest_block_header = BeaconBlockHeader(
      slot=block.slot,
      proposer_index=block.proposer_index,
      parent_root=block.parent_root,
      state_root=Bytes32(),  # Overwritten in the next process_slot call
      body_root=hash_tree_root(block.body),
  )

  # Verify proposer is not slashed
  proposer = state.validators[block.proposer_index]
  assert not proposer.slashed
</pre>

			
			

		
			
			
			<h2 id="ProcessBlockHeaderNoVerify">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/header.go?s=3482:3681#L84">ProcessBlockHeaderNoVerify</a>
				<a class="permalink" href="index.html#ProcessBlockHeaderNoVerify">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessBlockHeaderNoVerify(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    slot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>, proposerIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
    parentRoot, bodyRoot []<a href="../../../../../../builtin/index.html#byte">byte</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessBlockHeaderNoVerify validates a block by its header but skips proposer
signature verification.
<p>WARNING: This method does not verify proposer signature. This is used for proposer to compute state root
using a unsigned block.
<p>Spec pseudocode definition:
<pre>def process_block_header(state: BeaconState, block: BeaconBlock) -&gt; None:
  # Verify that the slots match
  assert block.slot == state.slot
  # Verify that the block is newer than latest block header
  assert block.slot &gt; state.latest_block_header.slot
  # Verify that proposer index is the correct index
  assert block.proposer_index == get_beacon_proposer_index(state)
  # Verify that the parent matches
  assert block.parent_root == hash_tree_root(state.latest_block_header)
  # Cache current block as the new latest block
  state.latest_block_header = BeaconBlockHeader(
      slot=block.slot,
      proposer_index=block.proposer_index,
      parent_root=block.parent_root,
      state_root=Bytes32(),  # Overwritten in the next process_slot call
      body_root=hash_tree_root(block.body),
  )

  # Verify proposer is not slashed
  proposer = state.validators[block.proposer_index]
  assert not proposer.slashed
</pre>

			
			

		
			
			
			<h2 id="ProcessDeposit">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go?s=5863:5992#L147">ProcessDeposit</a>
				<a class="permalink" href="index.html#ProcessDeposit">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessDeposit(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, deposit *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>, verifySignature <a href="../../../../../../builtin/index.html#bool">bool</a>) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessDeposit takes in a deposit object and inserts it
into the registry as a new validator or balance change.
Returns the resulting state, a boolean to indicate whether or not the deposit
resulted in a new validator entry into the beacon state, and any error.
<p>Spec pseudocode definition:
def process_deposit(state: BeaconState, deposit: Deposit) -&gt; None:
<pre># Verify the Merkle branch
assert is_valid_merkle_branch(
    leaf=hash_tree_root(deposit.data),
    branch=deposit.proof,
    depth=DEPOSIT_CONTRACT_TREE_DEPTH + 1,  # Add 1 for the List length mix-in
    index=state.eth1_deposit_index,
    root=state.eth1_data.deposit_root,
)

# Deposits must be processed in order
state.eth1_deposit_index += 1

pubkey = deposit.data.pubkey
amount = deposit.data.amount
validator_pubkeys = [v.pubkey for v in state.validators]
if pubkey not in validator_pubkeys:
    # Verify the deposit signature (proof of possession) which is not checked by the deposit contract
    deposit_message = DepositMessage(
        pubkey=deposit.data.pubkey,
        withdrawal_credentials=deposit.data.withdrawal_credentials,
        amount=deposit.data.amount,
    )
    domain = compute_domain(DOMAIN_DEPOSIT)  # Fork-agnostic domain since deposits are valid across forks
    signing_root = compute_signing_root(deposit_message, domain)
    if not bls.Verify(pubkey, signing_root, deposit.data.signature):
        return

    # Add validator and balance entries
    state.validators.append(get_validator_from_deposit(state, deposit))
    state.balances.append(amount)
else:
    # Increase balance by deposit amount
    index = ValidatorIndex(validator_pubkeys.index(pubkey))
    increase_balance(state, index, amount)
</pre>

			
			

		
			
			
			<h2 id="ProcessDeposits">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go?s=2623:2755#L66">ProcessDeposits</a>
				<a class="permalink" href="index.html#ProcessDeposits">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessDeposits(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    deposits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessDeposits is one of the operations performed on each processed
beacon block to verify queued validators from the Ethereum 1.0 Deposit Contract
into the beacon chain.
<p>Spec pseudocode definition:
<pre>For each deposit in block.body.deposits:
  process_deposit(state, deposit)
</pre>

			
			

		
			
			
			<h2 id="ProcessEth1DataInBlock">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/eth1_data.go?s=680:810#L12">ProcessEth1DataInBlock</a>
				<a class="permalink" href="index.html#ProcessEth1DataInBlock">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessEth1DataInBlock(_ <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, eth1Data *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Eth1Data">Eth1Data</a>) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessEth1DataInBlock is an operation performed on each
beacon block to ensure the ETH1 data votes are processed
into the beacon state.
<p>Official spec definition:
<pre>def process_eth1_data(state: BeaconState, body: BeaconBlockBody) -&gt; None:
 state.eth1_data_votes.append(body.eth1_data)
 if state.eth1_data_votes.count(body.eth1_data) * 2 &gt; EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH:
     state.eth1_data = body.eth1_data
</pre>

			
			

		
			
			
			<h2 id="ProcessPayload">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=5587:5688#L148">ProcessPayload</a>
				<a class="permalink" href="index.html#ProcessPayload">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessPayload(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, payload *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ExecutionPayload">ExecutionPayload</a>) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessPayload processes input execution payload using beacon state.
ValidatePayloadWhenMergeCompletes validates if payload is valid versus input beacon state.
These validation steps ONLY apply to post merge.
<p>Spec code:
def process_execution_payload(state: BeaconState, payload: ExecutionPayload, execution_engine: ExecutionEngine) -&gt; None:
<pre># Verify consistency of the parent hash with respect to the previous execution payload header
if is_merge_complete(state):
    assert payload.parent_hash == state.latest_execution_payload_header.block_hash
# Verify random
assert payload.random == get_randao_mix(state, get_current_epoch(state))
# Verify timestamp
assert payload.timestamp == compute_timestamp_at_slot(state, state.slot)
# Verify the execution payload is valid
assert execution_engine.execute_payload(payload)
# Cache execution payload header
state.latest_execution_payload_header = ExecutionPayloadHeader(
    parent_hash=payload.parent_hash,
    FeeRecipient=payload.FeeRecipient,
    state_root=payload.state_root,
    receipt_root=payload.receipt_root,
    logs_bloom=payload.logs_bloom,
    random=payload.random,
    block_number=payload.block_number,
    gas_limit=payload.gas_limit,
    gas_used=payload.gas_used,
    timestamp=payload.timestamp,
    extra_data=payload.extra_data,
    base_fee_per_gas=payload.base_fee_per_gas,
    block_hash=payload.block_hash,
    transactions_root=hash_tree_root(payload.transactions),
)
</pre>

			
			

		
			
			
			<h2 id="ProcessPreGenesisDeposits">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/deposit.go?s=681:823#L11">ProcessPreGenesisDeposits</a>
				<a class="permalink" href="index.html#ProcessPreGenesisDeposits">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessPreGenesisDeposits(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    deposits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessPreGenesisDeposits processes a deposit for the beacon state before chainstart.

			
			

		
			
			
			<h2 id="ProcessProposerSlashing">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/proposer_slashing.go?s=2549:2727#L54">ProcessProposerSlashing</a>
				<a class="permalink" href="index.html#ProcessProposerSlashing">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessProposerSlashing(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    slashing *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ProposerSlashing">ProposerSlashing</a>,
    slashFunc slashValidatorFunc,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessProposerSlashing processes individual proposer slashing.

			
			

		
			
			
			<h2 id="ProcessProposerSlashings">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/proposer_slashing.go?s=2088:2270#L37">ProcessProposerSlashings</a>
				<a class="permalink" href="index.html#ProcessProposerSlashings">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessProposerSlashings(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    slashings []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ProposerSlashing">ProposerSlashing</a>,
    slashFunc slashValidatorFunc,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessProposerSlashings is one of the operations performed
on each processed beacon block to slash proposers based on
slashing conditions if any slashable events occurred.
<p>Spec pseudocode definition:
<pre>def process_proposer_slashing(state: BeaconState, proposer_slashing: ProposerSlashing) -&gt; None:
 header_1 = proposer_slashing.signed_header_1.message
 header_2 = proposer_slashing.signed_header_2.message

 # Verify header slots match
 assert header_1.slot == header_2.slot
 # Verify header proposer indices match
 assert header_1.proposer_index == header_2.proposer_index
 # Verify the headers are different
 assert header_1 != header_2
 # Verify the proposer is slashable
 proposer = state.validators[header_1.proposer_index]
 assert is_slashable_validator(proposer, get_current_epoch(state))
 # Verify signatures
 for signed_header in (proposer_slashing.signed_header_1, proposer_slashing.signed_header_2):
     domain = get_domain(state, DOMAIN_BEACON_PROPOSER, compute_epoch_at_slot(signed_header.message.slot))
     signing_root = compute_signing_root(signed_header.message, domain)
     assert bls.Verify(proposer.pubkey, signing_root, signed_header.signature)

 slash_validator(state, header_1.proposer_index)
</pre>

			
			

		
			
			
			<h2 id="ProcessRandao">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/randao.go?s=1111:1241#L19">ProcessRandao</a>
				<a class="permalink" href="index.html#ProcessRandao">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessRandao(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    b <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#SignedBeaconBlock">SignedBeaconBlock</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessRandao checks the block proposer&apos;s
randao commitment and generates a new randao mix to update
in the beacon state&apos;s latest randao mixes slice.
<p>Spec pseudocode definition:
<pre>def process_randao(state: BeaconState, body: BeaconBlockBody) -&gt; None:
 epoch = get_current_epoch(state)
 # Verify RANDAO reveal
 proposer = state.validators[get_beacon_proposer_index(state)]
 signing_root = compute_signing_root(epoch, get_domain(state, DOMAIN_RANDAO))
 assert bls.Verify(proposer.pubkey, signing_root, body.randao_reveal)
 # Mix in RANDAO reveal
 mix = xor(get_randao_mix(state, epoch), hash(body.randao_reveal))
 state.randao_mixes[epoch % EPOCHS_PER_HISTORICAL_VECTOR] = mix
</pre>

			
			

		
			
			
			<h2 id="ProcessRandaoNoVerify">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/randao.go?s=2164:2274#L52">ProcessRandaoNoVerify</a>
				<a class="permalink" href="index.html#ProcessRandaoNoVerify">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessRandaoNoVerify(
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    randaoReveal []<a href="../../../../../../builtin/index.html#byte">byte</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessRandaoNoVerify generates a new randao mix to update
in the beacon state&apos;s latest randao mixes slice.
<p>Spec pseudocode definition:
<pre># Mix it in
state.latest_randao_mixes[get_current_epoch(state) % LATEST_RANDAO_MIXES_LENGTH] = (
    xor(get_randao_mix(state, get_current_epoch(state)),
        hash(body.randao_reveal))
)
</pre>

			
			

		
			
			
			<h2 id="ProcessVoluntaryExits">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/exit.go?s=2200:2347#L37">ProcessVoluntaryExits</a>
				<a class="permalink" href="index.html#ProcessVoluntaryExits">&#xb6;</a>
				
				
			</h2>
			<pre>func ProcessVoluntaryExits(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    exits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#SignedVoluntaryExit">SignedVoluntaryExit</a>,
) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ProcessVoluntaryExits is one of the operations performed
on each processed beacon block to determine which validators
should exit the state&apos;s validator registry.
<p>Spec pseudocode definition:
<pre>def process_voluntary_exit(state: BeaconState, signed_voluntary_exit: SignedVoluntaryExit) -&gt; None:
 voluntary_exit = signed_voluntary_exit.message
 validator = state.validators[voluntary_exit.validator_index]
 # Verify the validator is active
 assert is_active_validator(validator, get_current_epoch(state))
 # Verify exit has not been initiated
 assert validator.exit_epoch == FAR_FUTURE_EPOCH
 # Exits must specify an epoch when they become valid; they are not valid before then
 assert get_current_epoch(state) &gt;= voluntary_exit.epoch
 # Verify the validator has been active long enough
 assert get_current_epoch(state) &gt;= validator.activation_epoch + SHARD_COMMITTEE_PERIOD
 # Verify signature
 domain = get_domain(state, DOMAIN_VOLUNTARY_EXIT, voluntary_exit.epoch)
 signing_root = compute_signing_root(voluntary_exit, domain)
 assert bls.Verify(validator.pubkey, signing_root, signed_voluntary_exit.signature)
 # Initiate exit
 initiate_validator_exit(state, voluntary_exit.validator_index)
</pre>

			
			

		
			
			
			<h2 id="RandaoSignatureBatch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=5158:5293#L129">RandaoSignatureBatch</a>
				<a class="permalink" href="index.html#RandaoSignatureBatch">&#xb6;</a>
				
				
			</h2>
			<pre>func RandaoSignatureBatch(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>,
    reveal []<a href="../../../../../../builtin/index.html#byte">byte</a>,
) (*<a href="../../../crypto/bls/index.html">bls</a>.<a href="../../../crypto/bls/index.html#SignatureBatch">SignatureBatch</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>RandaoSignatureBatch retrieves the relevant randao specific signature batch object
from a block and its corresponding state.

			
			

		
			
			
			<h2 id="SlashableAttesterIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go?s=6175:6247#L148">SlashableAttesterIndices</a>
				<a class="permalink" href="index.html#SlashableAttesterIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func SlashableAttesterIndices(slashing *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttesterSlashing">AttesterSlashing</a>) []<a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>SlashableAttesterIndices returns the intersection of attester indices from both attestations in this slashing.

			
			

		
			
			
			<h2 id="ValidatePayload">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=3516:3597#L97">ValidatePayload</a>
				<a class="permalink" href="index.html#ValidatePayload">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidatePayload(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, payload *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ExecutionPayload">ExecutionPayload</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>ValidatePayload validates if payload is valid versus input beacon state.
These validation steps apply to both pre merge and post merge.
<p>Spec code:
<pre># Verify random
assert payload.random == get_randao_mix(state, get_current_epoch(state))
# Verify timestamp
assert payload.timestamp == compute_timestamp_at_slot(state, state.slot)
</pre>

			
			

		
			
			
			<h2 id="ValidatePayloadWhenMergeCompletes">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/payload.go?s=2746:2845#L70">ValidatePayloadWhenMergeCompletes</a>
				<a class="permalink" href="index.html#ValidatePayloadWhenMergeCompletes">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidatePayloadWhenMergeCompletes(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, payload *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ExecutionPayload">ExecutionPayload</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>ValidatePayloadWhenMergeCompletes validates if payload is valid versus input beacon state.
These validation steps ONLY apply to post merge.
<p>Spec code:
<pre># Verify consistency of the parent hash with respect to the previous execution payload header
if is_merge_complete(state):
    assert payload.parent_hash == state.latest_execution_payload_header.block_hash
</pre>

			
			

		
			
			
			<h2 id="VerifyAttestationNoVerifySignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go?s=1584:1719#L34">VerifyAttestationNoVerifySignature</a>
				<a class="permalink" href="index.html#VerifyAttestationNoVerifySignature">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyAttestationNoVerifySignature(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>,
    att *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>,
) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyAttestationNoVerifySignature verifies the attestation without verifying the attestation signature. This is
used before processing attestation with the beacon state.

			
			

		
			
			
			<h2 id="VerifyAttestationSignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go?s=5474:5595#L159">VerifyAttestationSignature</a>
				<a class="permalink" href="index.html#VerifyAttestationSignature">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyAttestationSignature(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, att *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyAttestationSignature converts and attestation into an indexed attestation and verifies
the signature in that attestation.

			
			

		
			
			
			<h2 id="VerifyAttesterSlashing">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attester_slashing.go?s=3981:4108#L96">VerifyAttesterSlashing</a>
				<a class="permalink" href="index.html#VerifyAttesterSlashing">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyAttesterSlashing(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, slashing *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttesterSlashing">AttesterSlashing</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyAttesterSlashing validates the attestation data in both attestations in the slashing object.

			
			

		
			
			
			<h2 id="VerifyBlockHeaderSignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=2810:2917#L74">VerifyBlockHeaderSignature</a>
				<a class="permalink" href="index.html#VerifyBlockHeaderSignature">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyBlockHeaderSignature(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, header *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#SignedBeaconBlockHeader">SignedBeaconBlockHeader</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyBlockHeaderSignature verifies the proposer signature of a beacon block header.

			
			

		
			
			
			<h2 id="VerifyBlockSignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=2120:2276#L56">VerifyBlockSignature</a>
				<a class="permalink" href="index.html#VerifyBlockSignature">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyBlockSignature(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>,
    proposerIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
    sig []<a href="../../../../../../builtin/index.html#byte">byte</a>,
    rootFunc func() ([32]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyBlockSignature verifies the proposer signature of a beacon block.

			
			

		
			
			
			<h2 id="VerifyBlockSignatureUsingCurrentFork">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/signature.go?s=3623:3738#L91">VerifyBlockSignatureUsingCurrentFork</a>
				<a class="permalink" href="index.html#VerifyBlockSignatureUsingCurrentFork">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyBlockSignatureUsingCurrentFork(beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, blk <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#SignedBeaconBlock">SignedBeaconBlock</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyBlockSignatureUsingCurrentFork verifies the proposer signature of a beacon block. This differs
from the above method by not using fork data from the state and instead retrieving it
via the respective epoch.

			
			

		
			
			
			<h2 id="VerifyExitAndSignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/exit.go?s=4175:4348#L81">VerifyExitAndSignature</a>
				<a class="permalink" href="index.html#VerifyExitAndSignature">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyExitAndSignature(
    validator <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidator">ReadOnlyValidator</a>,
    currentSlot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>,
    fork *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Fork">Fork</a>,
    signed *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#SignedVoluntaryExit">SignedVoluntaryExit</a>,
    genesisRoot []<a href="../../../../../../builtin/index.html#byte">byte</a>,
) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyExitAndSignature implements the spec defined validation for voluntary exits.
<p>Spec pseudocode definition:
<pre>def process_voluntary_exit(state: BeaconState, signed_voluntary_exit: SignedVoluntaryExit) -&gt; None:
 voluntary_exit = signed_voluntary_exit.message
 validator = state.validators[voluntary_exit.validator_index]
 # Verify the validator is active
 assert is_active_validator(validator, get_current_epoch(state))
 # Verify exit has not been initiated
 assert validator.exit_epoch == FAR_FUTURE_EPOCH
 # Exits must specify an epoch when they become valid; they are not valid before then
 assert get_current_epoch(state) &gt;= voluntary_exit.epoch
 # Verify the validator has been active long enough
 assert get_current_epoch(state) &gt;= validator.activation_epoch + SHARD_COMMITTEE_PERIOD
 # Verify signature
 domain = get_domain(state, DOMAIN_VOLUNTARY_EXIT, voluntary_exit.epoch)
 signing_root = compute_signing_root(voluntary_exit, domain)
 assert bls.Verify(validator.pubkey, signing_root, signed_voluntary_exit.signature)
 # Initiate exit
 initiate_validator_exit(state, voluntary_exit.validator_index)
</pre>

			
			

		
			
			
			<h2 id="VerifyIndexedAttestation">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/attestation.go?s=6896:7029#L190">VerifyIndexedAttestation</a>
				<a class="permalink" href="index.html#VerifyIndexedAttestation">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyIndexedAttestation(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, indexedAtt *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#IndexedAttestation">IndexedAttestation</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyIndexedAttestation determines the validity of an indexed attestation.
<p>Spec pseudocode definition:
<pre>def is_valid_indexed_attestation(state: BeaconState, indexed_attestation: IndexedAttestation) -&gt; bool:
  &quot;&quot;&quot;
  Check if ``indexed_attestation`` is not empty, has sorted and unique indices and has a valid aggregate signature.
  &quot;&quot;&quot;
  # Verify indices are sorted and unique
  indices = indexed_attestation.attesting_indices
  if len(indices) == 0 or not indices == sorted(set(indices)):
      return False
  # Verify aggregate signature
  pubkeys = [state.validators[i].pubkey for i in indices]
  domain = get_domain(state, DOMAIN_BEACON_ATTESTER, indexed_attestation.data.target.epoch)
  signing_root = compute_signing_root(indexed_attestation.data, domain)
  return bls.FastAggregateVerify(pubkeys, signing_root, indexed_attestation.signature)
</pre>

			
			

		
			
			
			<h2 id="VerifyProposerSlashing">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/blocks/proposer_slashing.go?s=3793:3904#L87">VerifyProposerSlashing</a>
				<a class="permalink" href="index.html#VerifyProposerSlashing">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyProposerSlashing(
    beaconState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>,
    slashing *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#ProposerSlashing">ProposerSlashing</a>,
) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyProposerSlashing verifies that the data provided from slashing is valid.

			
			

		
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
