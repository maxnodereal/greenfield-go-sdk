<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>helpers - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package helpers
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/prysmaticlabs/prysm/beacon-chain/core/helpers"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package helpers contains helper functions outlined in the Ethereum Beacon Chain spec, such as
computing committees, randao, rewards/penalties, and more.
<p>Package helpers contains helper functions outlined in the Ethereum Beacon Chain spec, such as
computing committees, randao, rewards/penalties, and more.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#ActivationExitEpoch">func ActivationExitEpoch(epoch types.Epoch) types.Epoch</a></dd>
			
				
				<dd><a href="index.html#ActiveValidatorCount">func ActiveValidatorCount(ctx context.Context, s state.ReadOnlyBeaconState, epoch types.Epoch) (uint64, error)</a></dd>
			
				
				<dd><a href="index.html#ActiveValidatorIndices">func ActiveValidatorIndices(ctx context.Context, s state.ReadOnlyBeaconState, epoch types.Epoch) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#AggregateSignature">func AggregateSignature(attestations []*ethpb.Attestation) (bls.Signature, error)</a></dd>
			
				
				<dd><a href="index.html#BeaconBlockIsNil">func BeaconBlockIsNil(b block.SignedBeaconBlock) error</a></dd>
			
				
				<dd><a href="index.html#BeaconCommittee">func BeaconCommittee(ctx context.Context, validatorIndices []types.ValidatorIndex, seed [32]byte, slot types.Slot, committeeIndex types.CommitteeIndex) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#BeaconCommitteeFromState">func BeaconCommitteeFromState(ctx context.Context, state state.ReadOnlyBeaconState, slot types.Slot, committeeIndex types.CommitteeIndex) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#BeaconProposerIndex">func BeaconProposerIndex(ctx context.Context, state state.ReadOnlyBeaconState) (types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#BlockRoot">func BlockRoot(state state.ReadOnlyBeaconState, epoch types.Epoch) ([]byte, error)</a></dd>
			
				
				<dd><a href="index.html#BlockRootAtSlot">func BlockRootAtSlot(state state.ReadOnlyBeaconState, slot types.Slot) ([]byte, error)</a></dd>
			
				
				<dd><a href="index.html#ClearCache">func ClearCache()</a></dd>
			
				
				<dd><a href="index.html#CommitteeAssignments">func CommitteeAssignments(ctx context.Context, state state.BeaconState, epoch types.Epoch) (map[types.ValidatorIndex]*CommitteeAssignmentContainer, map[types.ValidatorIndex][]types.Slot, error)</a></dd>
			
				
				<dd><a href="index.html#ComputeProposerIndex">func ComputeProposerIndex(bState state.ReadOnlyValidators, activeIndices []types.ValidatorIndex, seed [32]byte) (types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#ComputeShuffledIndex">func ComputeShuffledIndex(index types.ValidatorIndex, indexCount uint64, seed [32]byte, shuffle bool) (types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#ComputeSubnetForAttestation">func ComputeSubnetForAttestation(activeValCount uint64, att *ethpb.Attestation) uint64</a></dd>
			
				
				<dd><a href="index.html#ComputeSubnetFromCommitteeAndSlot">func ComputeSubnetFromCommitteeAndSlot(activeValCount uint64, comIdx types.CommitteeIndex, attSlot types.Slot) uint64</a></dd>
			
				
				<dd><a href="index.html#ComputeWeakSubjectivityPeriod">func ComputeWeakSubjectivityPeriod(ctx context.Context, st state.ReadOnlyBeaconState) (types.Epoch, error)</a></dd>
			
				
				<dd><a href="index.html#CurrentPeriodSyncSubcommitteeIndices">func CurrentPeriodSyncSubcommitteeIndices(st state.BeaconStateAltair, valIdx types.ValidatorIndex) ([]types.CommitteeIndex, error)</a></dd>
			
				
				<dd><a href="index.html#DecreaseBalance">func DecreaseBalance(state state.BeaconState, idx types.ValidatorIndex, delta uint64) error</a></dd>
			
				
				<dd><a href="index.html#DecreaseBalanceWithVal">func DecreaseBalanceWithVal(currBalance, delta uint64) uint64</a></dd>
			
				
				<dd><a href="index.html#FinalityDelay">func FinalityDelay(prevEpoch, finalizedEpoch types.Epoch) types.Epoch</a></dd>
			
				
				<dd><a href="index.html#IncreaseBalance">func IncreaseBalance(state state.BeaconState, idx types.ValidatorIndex, delta uint64) error</a></dd>
			
				
				<dd><a href="index.html#IncreaseBalanceWithVal">func IncreaseBalanceWithVal(currBalance, delta uint64) (uint64, error)</a></dd>
			
				
				<dd><a href="index.html#IsActiveValidator">func IsActiveValidator(validator *ethpb.Validator, epoch types.Epoch) bool</a></dd>
			
				
				<dd><a href="index.html#IsActiveValidatorUsingTrie">func IsActiveValidatorUsingTrie(validator state.ReadOnlyValidator, epoch types.Epoch) bool</a></dd>
			
				
				<dd><a href="index.html#IsAggregated">func IsAggregated(attestation *ethpb.Attestation) bool</a></dd>
			
				
				<dd><a href="index.html#IsAggregator">func IsAggregator(committeeCount uint64, slotSig []byte) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#IsCurrentPeriodSyncCommittee">func IsCurrentPeriodSyncCommittee(st state.BeaconStateAltair, valIdx types.ValidatorIndex) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#IsEligibleForActivation">func IsEligibleForActivation(state state.ReadOnlyCheckpoint, validator *ethpb.Validator) bool</a></dd>
			
				
				<dd><a href="index.html#IsEligibleForActivationQueue">func IsEligibleForActivationQueue(validator *ethpb.Validator) bool</a></dd>
			
				
				<dd><a href="index.html#IsEligibleForActivationQueueUsingTrie">func IsEligibleForActivationQueueUsingTrie(validator state.ReadOnlyValidator) bool</a></dd>
			
				
				<dd><a href="index.html#IsEligibleForActivationUsingTrie">func IsEligibleForActivationUsingTrie(state state.ReadOnlyCheckpoint, validator state.ReadOnlyValidator) bool</a></dd>
			
				
				<dd><a href="index.html#IsInInactivityLeak">func IsInInactivityLeak(prevEpoch, finalizedEpoch types.Epoch) bool</a></dd>
			
				
				<dd><a href="index.html#IsNextPeriodSyncCommittee">func IsNextPeriodSyncCommittee(st state.BeaconStateAltair, valIdx types.ValidatorIndex) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#IsSlashableValidator">func IsSlashableValidator(activationEpoch, withdrawableEpoch types.Epoch, slashed bool, epoch types.Epoch) bool</a></dd>
			
				
				<dd><a href="index.html#IsSlashableValidatorUsingTrie">func IsSlashableValidatorUsingTrie(val state.ReadOnlyValidator, epoch types.Epoch) bool</a></dd>
			
				
				<dd><a href="index.html#IsWithinWeakSubjectivityPeriod">func IsWithinWeakSubjectivityPeriod(ctx context.Context, currentEpoch types.Epoch, wsState state.ReadOnlyBeaconState, wsCheckpoint *eth.WeakSubjectivityCheckpoint) (bool, error)</a></dd>
			
				
				<dd><a href="index.html#LatestWeakSubjectivityEpoch">func LatestWeakSubjectivityEpoch(ctx context.Context, st state.ReadOnlyBeaconState) (types.Epoch, error)</a></dd>
			
				
				<dd><a href="index.html#NextPeriodSyncSubcommitteeIndices">func NextPeriodSyncSubcommitteeIndices(st state.BeaconStateAltair, valIdx types.ValidatorIndex) ([]types.CommitteeIndex, error)</a></dd>
			
				
				<dd><a href="index.html#ParseWeakSubjectivityInputString">func ParseWeakSubjectivityInputString(wsCheckpointString string) (*eth.Checkpoint, error)</a></dd>
			
				
				<dd><a href="index.html#RandaoMix">func RandaoMix(state state.ReadOnlyBeaconState, epoch types.Epoch) ([]byte, error)</a></dd>
			
				
				<dd><a href="index.html#Seed">func Seed(state state.ReadOnlyBeaconState, epoch types.Epoch, domain [bls.DomainByteLength]byte) ([32]byte, error)</a></dd>
			
				
				<dd><a href="index.html#ShuffleList">func ShuffleList(input []types.ValidatorIndex, seed [32]byte) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#ShuffledIndex">func ShuffledIndex(index types.ValidatorIndex, indexCount uint64, seed [32]byte) (types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#ShuffledIndices">func ShuffledIndices(s state.ReadOnlyBeaconState, epoch types.Epoch) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#SlotCommitteeCount">func SlotCommitteeCount(activeValidatorCount uint64) uint64</a></dd>
			
				
				<dd><a href="index.html#SplitIndices">func SplitIndices(l []uint64, n uint64) [][]uint64</a></dd>
			
				
				<dd><a href="index.html#StateRootAtSlot">func StateRootAtSlot(state state.ReadOnlyBeaconState, slot types.Slot) ([]byte, error)</a></dd>
			
				
				<dd><a href="index.html#TotalActiveBalance">func TotalActiveBalance(s state.ReadOnlyBeaconState) (uint64, error)</a></dd>
			
				
				<dd><a href="index.html#TotalBalance">func TotalBalance(state state.ReadOnlyValidators, indices []types.ValidatorIndex) uint64</a></dd>
			
				
				<dd><a href="index.html#UnShuffledIndex">func UnShuffledIndex(index types.ValidatorIndex, indexCount uint64, seed [32]byte) (types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#UnshuffleList">func UnshuffleList(input []types.ValidatorIndex, seed [32]byte) ([]types.ValidatorIndex, error)</a></dd>
			
				
				<dd><a href="index.html#UpdateCommitteeCache">func UpdateCommitteeCache(state state.ReadOnlyBeaconState, epoch types.Epoch) error</a></dd>
			
				
				<dd><a href="index.html#UpdateGenesisEth1Data">func UpdateGenesisEth1Data(state state.BeaconState, deposits []*ethpb.Deposit, eth1Data *ethpb.Eth1Data) (state.BeaconState, error)</a></dd>
			
				
				<dd><a href="index.html#UpdateProposerIndicesInCache">func UpdateProposerIndicesInCache(ctx context.Context, state state.ReadOnlyBeaconState) error</a></dd>
			
				
				<dd><a href="index.html#UpdateSyncCommitteeCache">func UpdateSyncCommitteeCache(st state.BeaconStateAltair) error</a></dd>
			
				
				<dd><a href="index.html#ValidateAttestationTime">func ValidateAttestationTime(attSlot types.Slot, genesisTime time.Time, clockDisparity time.Duration) error</a></dd>
			
				
				<dd><a href="index.html#ValidateNilAttestation">func ValidateNilAttestation(attestation *ethpb.Attestation) error</a></dd>
			
				
				<dd><a href="index.html#ValidateSlotTargetEpoch">func ValidateSlotTargetEpoch(data *ethpb.AttestationData) error</a></dd>
			
				
				<dd><a href="index.html#ValidatorChurnLimit">func ValidatorChurnLimit(activeValidatorCount uint64) (uint64, error)</a></dd>
			
				
				<dd><a href="index.html#VerifyAttestationBitfieldLengths">func VerifyAttestationBitfieldLengths(ctx context.Context, state state.ReadOnlyBeaconState, att *ethpb.Attestation) error</a></dd>
			
				
				<dd><a href="index.html#VerifyBitfieldLength">func VerifyBitfieldLength(bf bitfield.Bitfield, committeeSize uint64) error</a></dd>
			
				
				<dd><a href="index.html#VerifyCheckpointEpoch">func VerifyCheckpointEpoch(c *ethpb.Checkpoint, genesis time.Time) bool</a></dd>
			
			
				
				<dd><a href="index.html#CommitteeAssignmentContainer">type CommitteeAssignmentContainer</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go">attestation.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go">beacon_committee.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/block.go">block.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/genesis.go">genesis.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/randao.go">randao.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go">rewards_penalties.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go">shuffle.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go">sync_committee.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go">validators.go</a>
			
				<a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/weak_subjectivity.go">weak_subjectivity.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var <span id="CommitteeCacheInProgressHit">CommitteeCacheInProgressHit</span> = <a href="../../../../../prometheus/client_golang/prometheus/promauto/index.html">promauto</a>.<a href="../../../../../prometheus/client_golang/prometheus/promauto/index.html#NewCounter">NewCounter</a>(<a href="../../../../../prometheus/client_golang/prometheus/index.html">prometheus</a>.<a href="../../../../../prometheus/client_golang/prometheus/index.html#CounterOpts">CounterOpts</a>{
    <a href="../../../../../prometheus/client_golang/prometheus/index.html#CounterOpts.Name">Name</a>: &#34;committee_cache_in_progress_hit&#34;,
    <a href="../../../../../prometheus/client_golang/prometheus/index.html#CounterOpts.Help">Help</a>: &#34;The number of committee requests that are present in the cache.&#34;,
})</pre>
			
		
		
			
			
			<h2 id="ActivationExitEpoch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=6987:7042#L184">ActivationExitEpoch</a>
				<a class="permalink" href="index.html#ActivationExitEpoch">&#xb6;</a>
				
				
			</h2>
			<pre>func ActivationExitEpoch(epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a></pre>
			<p>ActivationExitEpoch takes in epoch number and returns when
the validator is eligible for activation and exit.
<p>Spec pseudocode definition:
<pre>def compute_activation_exit_epoch(epoch: Epoch) -&gt; Epoch:
  &quot;&quot;&quot;
  Return the epoch during which validator activations and exits initiated in ``epoch`` take effect.
  &quot;&quot;&quot;
  return Epoch(epoch + 1 + MAX_SEED_LOOKAHEAD)
</pre>

			
			

		
			
			
			<h2 id="ActiveValidatorCount">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=5203:5313#L128">ActiveValidatorCount</a>
				<a class="permalink" href="index.html#ActiveValidatorCount">&#xb6;</a>
				
				
			</h2>
			<pre>func ActiveValidatorCount(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, s <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) (<a href="../../../../../../builtin/index.html#uint64">uint64</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ActiveValidatorCount returns the number of active validators in the state
at the given epoch.

			
			

		
			
			
			<h2 id="ActiveValidatorIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=3561:3689#L76">ActiveValidatorIndices</a>
				<a class="permalink" href="index.html#ActiveValidatorIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func ActiveValidatorIndices(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, s <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ActiveValidatorIndices filters out active validators based on validator status
and returns their indices in a list.
<p>WARNING: This method allocates a new copy of the validator index set and is
considered to be very memory expensive. Avoid using this unless you really
need the active validator indices for some specific reason.
<p>Spec pseudocode definition:
<pre>def get_active_validator_indices(state: BeaconState, epoch: Epoch) -&gt; Sequence[ValidatorIndex]:
  &quot;&quot;&quot;
  Return the sequence of active validator indices at ``epoch``.
  &quot;&quot;&quot;
  return [ValidatorIndex(i) for i, v in enumerate(state.validators) if is_active_validator(v, epoch)]
</pre>

			
			

		
			
			
			<h2 id="AggregateSignature">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=2858:2939#L64">AggregateSignature</a>
				<a class="permalink" href="index.html#AggregateSignature">&#xb6;</a>
				
				
			</h2>
			<pre>func AggregateSignature(attestations []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) (<a href="../../../crypto/bls/index.html">bls</a>.<a href="../../../crypto/bls/index.html#Signature">Signature</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>AggregateSignature returns the aggregated signature of the input attestations.
<p>Spec pseudocode definition:
<pre>def get_aggregate_signature(attestations: Sequence[Attestation]) -&gt; BLSSignature:
 signatures = [attestation.signature for attestation in attestations]
 return bls.Aggregate(signatures)
</pre>

			
			

		
			
			
			<h2 id="BeaconBlockIsNil">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/block.go?s=530:584#L7">BeaconBlockIsNil</a>
				<a class="permalink" href="index.html#BeaconBlockIsNil">&#xb6;</a>
				
				
			</h2>
			<pre>func BeaconBlockIsNil(b <a href="../../../proto/prysm/v1alpha1/block/index.html">block</a>.<a href="../../../proto/prysm/v1alpha1/block/index.html#SignedBeaconBlock">SignedBeaconBlock</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>BeaconBlockIsNil checks if any composite field of input signed beacon block is nil.
Access to these nil fields will result in run time panic,
it is recommended to run these checks as first line of defense.

			
			

		
			
			
			<h2 id="BeaconCommittee">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=4713:4904#L106">BeaconCommittee</a>
				<a class="permalink" href="index.html#BeaconCommittee">&#xb6;</a>
				
				
			</h2>
			<pre>func BeaconCommittee(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    validatorIndices []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
    seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>,
    slot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>,
    committeeIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>,
) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BeaconCommittee returns the beacon committee of a given slot and committee index. The
validator indices and seed are provided as an argument rather than an imported implementation
from the spec definition. Having them as an argument allows for cheaper computation run time.
<p>Spec pseudocode definition:
<pre>def get_beacon_committee(state: BeaconState, slot: Slot, index: CommitteeIndex) -&gt; Sequence[ValidatorIndex]:
 &quot;&quot;&quot;
 Return the beacon committee at ``slot`` for ``index``.
 &quot;&quot;&quot;
 epoch = compute_epoch_at_slot(slot)
 committees_per_slot = get_committee_count_per_slot(state, epoch)
 return compute_committee(
     indices=get_active_validator_indices(state, epoch),
     seed=get_seed(state, epoch, DOMAIN_BEACON_ATTESTER),
     index=(slot % SLOTS_PER_EPOCH) * committees_per_slot + index,
     count=committees_per_slot * SLOTS_PER_EPOCH,
 )
</pre>

			
			

		
			
			
			<h2 id="BeaconCommitteeFromState">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=2996:3165#L66">BeaconCommitteeFromState</a>
				<a class="permalink" href="index.html#BeaconCommitteeFromState">&#xb6;</a>
				
				
			</h2>
			<pre>func BeaconCommitteeFromState(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, slot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>, committeeIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BeaconCommitteeFromState returns the crosslink committee of a given slot and committee index. This
is a spec implementation where state is used as an argument. In case of state retrieval
becomes expensive, consider using BeaconCommittee below.
<p>Spec pseudocode definition:
<pre>def get_beacon_committee(state: BeaconState, slot: Slot, index: CommitteeIndex) -&gt; Sequence[ValidatorIndex]:
 &quot;&quot;&quot;
 Return the beacon committee at ``slot`` for ``index``.
 &quot;&quot;&quot;
 epoch = compute_epoch_at_slot(slot)
 committees_per_slot = get_committee_count_per_slot(state, epoch)
 return compute_committee(
     indices=get_active_validator_indices(state, epoch),
     seed=get_seed(state, epoch, DOMAIN_BEACON_ATTESTER),
     index=(slot % SLOTS_PER_EPOCH) * committees_per_slot + index,
     count=committees_per_slot * SLOTS_PER_EPOCH,
 )
</pre>

			
			

		
			
			
			<h2 id="BeaconProposerIndex">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=8419:8527#L217">BeaconProposerIndex</a>
				<a class="permalink" href="index.html#BeaconProposerIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func BeaconProposerIndex(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BeaconProposerIndex returns proposer index of a current slot.
<p>Spec pseudocode definition:
<pre>def get_beacon_proposer_index(state: BeaconState) -&gt; ValidatorIndex:
  &quot;&quot;&quot;
  Return the beacon proposer index at the current slot.
  &quot;&quot;&quot;
  epoch = get_current_epoch(state)
  seed = hash(get_seed(state, epoch, DOMAIN_BEACON_PROPOSER) + uint_to_bytes(state.slot))
  indices = get_active_validator_indices(state, epoch)
  return compute_proposer_index(state, indices, seed)
</pre>

			
			

		
			
			
			<h2 id="BlockRoot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/block.go?s=2637:2719#L57">BlockRoot</a>
				<a class="permalink" href="index.html#BlockRoot">&#xb6;</a>
				
				
			</h2>
			<pre>func BlockRoot(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) ([]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BlockRoot returns the block root stored in the BeaconState for epoch start slot.
<p>Spec pseudocode definition:
<pre>def get_block_root(state: BeaconState, epoch: Epoch) -&gt; Root:
  &quot;&quot;&quot;
  Return the block root at the start of a recent ``epoch``.
  &quot;&quot;&quot;
  return get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch))
</pre>

			
			

		
			
			
			<h2 id="BlockRootAtSlot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/block.go?s=1329:1415#L30">BlockRootAtSlot</a>
				<a class="permalink" href="index.html#BlockRootAtSlot">&#xb6;</a>
				
				
			</h2>
			<pre>func BlockRootAtSlot(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, slot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>) ([]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>BlockRootAtSlot returns the block root stored in the BeaconState for a recent slot.
It returns an error if the requested block root is not within the slot range.
<p>Spec pseudocode definition:
<pre>def get_block_root_at_slot(state: BeaconState, slot: Slot) -&gt; Root:
  &quot;&quot;&quot;
  Return the block root at a recent ``slot``.
  &quot;&quot;&quot;
  assert slot &lt; state.slot &lt;= slot + SLOTS_PER_HISTORICAL_ROOT
  return state.block_roots[slot % SLOTS_PER_HISTORICAL_ROOT]
</pre>

			
			

		
			
			
			<h2 id="ClearCache">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=13506:13523#L356">ClearCache</a>
				<a class="permalink" href="index.html#ClearCache">&#xb6;</a>
				
				
			</h2>
			<pre>func ClearCache()</pre>
			<p>ClearCache clears the beacon committee cache and sync committee cache.

			
			

		
			
			
			<h2 id="CommitteeAssignments">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=6206:6405#L146">CommitteeAssignments</a>
				<a class="permalink" href="index.html#CommitteeAssignments">&#xb6;</a>
				
				
			</h2>
			<pre>func CommitteeAssignments(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>,
    state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>,
    epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>,
) (map[<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>]*<a href="index.html#CommitteeAssignmentContainer">CommitteeAssignmentContainer</a>, map[<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>][]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>CommitteeAssignments is a map of validator indices pointing to the appropriate committee
assignment for the given epoch.
<p>1. Determine the proposer validator index for each slot.
2. Compute all committees.
3. Determine the attesting slot for each committee.
4. Construct a map of validator indices pointing to the respective committees.

			
			

		
			
			
			<h2 id="ComputeProposerIndex">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=11150:11291#L282">ComputeProposerIndex</a>
				<a class="permalink" href="index.html#ComputeProposerIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func ComputeProposerIndex(bState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidators">ReadOnlyValidators</a>, activeIndices []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ComputeProposerIndex returns the index sampled by effective balance, which is used to calculate proposer.
<p>Spec pseudocode definition:
<pre>def compute_proposer_index(state: BeaconState, indices: Sequence[ValidatorIndex], seed: Bytes32) -&gt; ValidatorIndex:
  &quot;&quot;&quot;
  Return from ``indices`` a random index sampled by effective balance.
  &quot;&quot;&quot;
  assert len(indices) &gt; 0
  MAX_RANDOM_BYTE = 2**8 - 1
  i = uint64(0)
  total = uint64(len(indices))
  while True:
      candidate_index = indices[compute_shuffled_index(i % total, total, seed)]
      random_byte = hash(seed + uint_to_bytes(uint64(i // 32)))[i % 32]
      effective_balance = state.validators[candidate_index].effective_balance
      if effective_balance * MAX_RANDOM_BYTE &gt;= MAX_EFFECTIVE_BALANCE * random_byte:
          return candidate_index
      i += 1
</pre>

			
			

		
			
			
			<h2 id="ComputeShuffledIndex">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=2974:3105#L62">ComputeShuffledIndex</a>
				<a class="permalink" href="index.html#ComputeShuffledIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func ComputeShuffledIndex(index <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, indexCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>, shuffle <a href="../../../../../../builtin/index.html#bool">bool</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ComputeShuffledIndex returns the shuffled validator index corresponding to seed and index count.
Spec pseudocode definition:
<pre>def compute_shuffled_index(index: uint64, index_count: uint64, seed: Bytes32) -&gt; uint64:
 &quot;&quot;&quot;
 Return the shuffled index corresponding to ``seed`` (and ``index_count``).
 &quot;&quot;&quot;
 assert index &lt; index_count

 # Swap or not (https://link.springer.com/content/pdf/10.1007%2F978-3-642-32009-5_1.pdf)
 # See the &apos;generalized domain&apos; algorithm on page 3
 for current_round in range(SHUFFLE_ROUND_COUNT):
     pivot = bytes_to_uint64(hash(seed + uint_to_bytes(uint8(current_round)))[0:8]) % index_count
     flip = (pivot + index_count - index) % index_count
     position = max(index, flip)
     source = hash(
         seed
         + uint_to_bytes(uint8(current_round))
         + uint_to_bytes(uint32(position // 256))
     )
     byte = uint8(source[(position % 256) // 8])
     bit = (byte &gt;&gt; (position % 8)) % 2
     index = flip if bit else index

 return index
</pre>

			
			

		
			
			
			<h2 id="ComputeSubnetForAttestation">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=4237:4323#L96">ComputeSubnetForAttestation</a>
				<a class="permalink" href="index.html#ComputeSubnetForAttestation">&#xb6;</a>
				
				
			</h2>
			<pre>func ComputeSubnetForAttestation(activeValCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, att *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) <a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>ComputeSubnetForAttestation returns the subnet for which the provided attestation will be broadcasted to.
This differs from the spec definition by instead passing in the active validators indices in the attestation&apos;s
given epoch.
<p>Spec pseudocode definition:
def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -&gt; uint64:
<pre>&quot;&quot;&quot;
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
&quot;&quot;&quot;
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot * slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)
</pre>

			
			

		
			
			
			<h2 id="ComputeSubnetFromCommitteeAndSlot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=5201:5318#L113">ComputeSubnetFromCommitteeAndSlot</a>
				<a class="permalink" href="index.html#ComputeSubnetFromCommitteeAndSlot">&#xb6;</a>
				
				
			</h2>
			<pre>func ComputeSubnetFromCommitteeAndSlot(activeValCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, comIdx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>, attSlot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>) <a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>ComputeSubnetFromCommitteeAndSlot is a flattened version of ComputeSubnetForAttestation where we only pass in
the relevant fields from the attestation as function arguments.
<p>Spec pseudocode definition:
def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -&gt; uint64:
<pre>&quot;&quot;&quot;
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
&quot;&quot;&quot;
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot * slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)
</pre>

			
			

		
			
			
			<h2 id="ComputeWeakSubjectivityPeriod">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/weak_subjectivity.go?s=2201:2307#L47">ComputeWeakSubjectivityPeriod</a>
				<a class="permalink" href="index.html#ComputeWeakSubjectivityPeriod">&#xb6;</a>
				
				
			</h2>
			<pre>func ComputeWeakSubjectivityPeriod(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ComputeWeakSubjectivityPeriod returns weak subjectivity period for the active validator count and finalized epoch.
<p>Reference spec implementation:
<a href="https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/weak-subjectivity.md#calculating-the-weak-subjectivity-period">https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/weak-subjectivity.md#calculating-the-weak-subjectivity-period</a>
<p>def compute_weak_subjectivity_period(state: BeaconState) -&gt; uint64:
<pre>&quot;&quot;&quot;
Returns the weak subjectivity period for the current ``state``.
This computation takes into account the effect of:
    - validator set churn (bounded by ``get_validator_churn_limit()`` per epoch), and
    - validator balance top-ups (bounded by ``MAX_DEPOSITS * SLOTS_PER_EPOCH`` per epoch).
A detailed calculation can be found at:
https://github.com/runtimeverification/beacon-chain-verification/blob/master/weak-subjectivity/weak-subjectivity-analysis.pdf
&quot;&quot;&quot;
ws_period = MIN_VALIDATOR_WITHDRAWABILITY_DELAY
N = len(get_active_validator_indices(state, get_current_epoch(state)))
t = get_total_active_balance(state) // N // ETH_TO_GWEI
T = MAX_EFFECTIVE_BALANCE // ETH_TO_GWEI
delta = get_validator_churn_limit(state)
Delta = MAX_DEPOSITS * SLOTS_PER_EPOCH
D = SAFETY_DECAY

if T * (200 + 3 * D) &lt; t * (200 + 12 * D):
    epochs_for_validator_set_churn = (
        N * (t * (200 + 12 * D) - T * (200 + 3 * D)) // (600 * delta * (2 * t + T))
    )
    epochs_for_balance_top_ups = (
        N * (200 + 3 * D) // (600 * Delta)
    )
    ws_period += max(epochs_for_validator_set_churn, epochs_for_balance_top_ups)
else:
    ws_period += (
        3 * N * D * t // (200 * Delta * (T - t))
    )

return ws_period
</pre>

			
			

		
			
			
			<h2 id="CurrentPeriodSyncSubcommitteeIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go?s=2999:3133#L81">CurrentPeriodSyncSubcommitteeIndices</a>
				<a class="permalink" href="index.html#CurrentPeriodSyncSubcommitteeIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func CurrentPeriodSyncSubcommitteeIndices(
    st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconStateAltair">BeaconStateAltair</a>, valIdx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>CurrentPeriodSyncSubcommitteeIndices returns the subcommittee indices of the
current period sync committee for input validator.

			
			

		
			
			
			<h2 id="DecreaseBalance">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=4301:4392#L118">DecreaseBalance</a>
				<a class="permalink" href="index.html#DecreaseBalance">&#xb6;</a>
				
				
			</h2>
			<pre>func DecreaseBalance(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, idx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, delta <a href="../../../../../../builtin/index.html#uint64">uint64</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>DecreaseBalance decreases validator with the given &apos;index&apos; balance by &apos;delta&apos; in Gwei.
<p>Spec pseudocode definition:
<pre>def decrease_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:
  &quot;&quot;&quot;
  Decrease the validator balance at index ``index`` by ``delta``, with underflow protection.
  &quot;&quot;&quot;
  state.balances[index] = 0 if delta &gt; state.balances[index] else state.balances[index] - delta
</pre>

			
			

		
			
			
			<h2 id="DecreaseBalanceWithVal">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=5112:5173#L136">DecreaseBalanceWithVal</a>
				<a class="permalink" href="index.html#DecreaseBalanceWithVal">&#xb6;</a>
				
				
			</h2>
			<pre>func DecreaseBalanceWithVal(currBalance, delta <a href="../../../../../../builtin/index.html#uint64">uint64</a>) <a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>DecreaseBalanceWithVal decreases validator with the given &apos;index&apos; balance by &apos;delta&apos; in Gwei.
This method is flattened version of the spec method, taking in the raw balance and returning
the post balance.
<p>Spec pseudocode definition:
<pre>def decrease_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:
  &quot;&quot;&quot;
  Decrease the validator balance at index ``index`` by ``delta``, with underflow protection.
  &quot;&quot;&quot;
  state.balances[index] = 0 if delta &gt; state.balances[index] else state.balances[index] - delta
</pre>

			
			

		
			
			
			<h2 id="FinalityDelay">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=5868:5937#L157">FinalityDelay</a>
				<a class="permalink" href="index.html#FinalityDelay">&#xb6;</a>
				
				
			</h2>
			<pre>func FinalityDelay(prevEpoch, finalizedEpoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a></pre>
			<p>FinalityDelay returns the finality delay using the beacon state.
<p>Spec code:
def get_finality_delay(state: BeaconState) -&gt; uint64:
<pre>return get_previous_epoch(state) - state.finalized_checkpoint.epoch
</pre>

			
			

		
			
			
			<h2 id="IncreaseBalance">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=2974:3065#L84">IncreaseBalance</a>
				<a class="permalink" href="index.html#IncreaseBalance">&#xb6;</a>
				
				
			</h2>
			<pre>func IncreaseBalance(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, idx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, delta <a href="../../../../../../builtin/index.html#uint64">uint64</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>IncreaseBalance increases validator with the given &apos;index&apos; balance by &apos;delta&apos; in Gwei.
<p>Spec pseudocode definition:
<pre>def increase_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:
  &quot;&quot;&quot;
  Increase the validator balance at index ``index`` by ``delta``.
  &quot;&quot;&quot;
  state.balances[index] += delta
</pre>

			
			

		
			
			
			<h2 id="IncreaseBalanceWithVal">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=3751:3821#L106">IncreaseBalanceWithVal</a>
				<a class="permalink" href="index.html#IncreaseBalanceWithVal">&#xb6;</a>
				
				
			</h2>
			<pre>func IncreaseBalanceWithVal(currBalance, delta <a href="../../../../../../builtin/index.html#uint64">uint64</a>) (<a href="../../../../../../builtin/index.html#uint64">uint64</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IncreaseBalanceWithVal increases validator with the given &apos;index&apos; balance by &apos;delta&apos; in Gwei.
This method is flattened version of the spec method, taking in the raw balance and returning
the post balance.
<p>Spec pseudocode definition:
<pre>def increase_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:
  &quot;&quot;&quot;
  Increase the validator balance at index ``index`` by ``delta``.
  &quot;&quot;&quot;
  state.balances[index] += delta
</pre>

			
			

		
			
			
			<h2 id="IsActiveValidator">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=1209:1283#L26">IsActiveValidator</a>
				<a class="permalink" href="index.html#IsActiveValidator">&#xb6;</a>
				
				
			</h2>
			<pre>func IsActiveValidator(validator *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Validator">Validator</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsActiveValidator returns the boolean value on whether the validator
is active or not.
<p>Spec pseudocode definition:
<pre>def is_active_validator(validator: Validator, epoch: Epoch) -&gt; bool:
  &quot;&quot;&quot;
  Check if ``validator`` is active.
  &quot;&quot;&quot;
  return validator.activation_epoch &lt;= epoch &lt; validator.exit_epoch
</pre>

			
			

		
			
			
			<h2 id="IsActiveValidatorUsingTrie">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=1452:1542#L31">IsActiveValidatorUsingTrie</a>
				<a class="permalink" href="index.html#IsActiveValidatorUsingTrie">&#xb6;</a>
				
				
			</h2>
			<pre>func IsActiveValidatorUsingTrie(validator <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidator">ReadOnlyValidator</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsActiveValidatorUsingTrie checks if a read only validator is active.

			
			

		
			
			
			<h2 id="IsAggregated">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=3296:3350#L78">IsAggregated</a>
				<a class="permalink" href="index.html#IsAggregated">&#xb6;</a>
				
				
			</h2>
			<pre>func IsAggregated(attestation *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsAggregated returns true if the attestation is an aggregated attestation,
false otherwise.

			
			

		
			
			
			<h2 id="IsAggregator">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=2199:2269#L48">IsAggregator</a>
				<a class="permalink" href="index.html#IsAggregator">&#xb6;</a>
				
				
			</h2>
			<pre>func IsAggregator(committeeCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, slotSig []<a href="../../../../../../builtin/index.html#byte">byte</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IsAggregator returns true if the signature is from the input validator. The committee
count is provided as an argument rather than imported implementation from spec. Having
committee count as an argument allows cheaper computation at run time.
<p>Spec pseudocode definition:
<pre>def is_aggregator(state: BeaconState, slot: Slot, index: CommitteeIndex, slot_signature: BLSSignature) -&gt; bool:
 committee = get_beacon_committee(state, slot, index)
 modulo = max(1, len(committee) // TARGET_AGGREGATORS_PER_COMMITTEE)
 return bytes_to_uint64(hash(slot_signature)[0:8]) % modulo == 0
</pre>

			
			

		
			
			
			<h2 id="IsCurrentPeriodSyncCommittee">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go?s=984:1092#L17">IsCurrentPeriodSyncCommittee</a>
				<a class="permalink" href="index.html#IsCurrentPeriodSyncCommittee">&#xb6;</a>
				
				
			</h2>
			<pre>func IsCurrentPeriodSyncCommittee(
    st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconStateAltair">BeaconStateAltair</a>, valIdx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IsCurrentPeriodSyncCommittee returns true if the input validator index belongs in the current period sync committee
along with the sync committee root.
1. Checks if the public key exists in the sync committee cache
2. If 1 fails, checks if the public key exists in the input current sync committee object

			
			

		
			
			
			<h2 id="IsEligibleForActivation">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=14038:14131#L354">IsEligibleForActivation</a>
				<a class="permalink" href="index.html#IsEligibleForActivation">&#xb6;</a>
				
				
			</h2>
			<pre>func IsEligibleForActivation(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyCheckpoint">ReadOnlyCheckpoint</a>, validator *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Validator">Validator</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsEligibleForActivation checks if the validator is eligible for activation.
<p>Spec pseudocode definition:
<pre>def is_eligible_for_activation(state: BeaconState, validator: Validator) -&gt; bool:
  &quot;&quot;&quot;
  Check if ``validator`` is eligible for activation.
  &quot;&quot;&quot;
  return (
      # Placement in queue is finalized
      validator.activation_eligibility_epoch &lt;= state.finalized_checkpoint.epoch
      # Has not yet been activated
      and validator.activation_epoch == FAR_FUTURE_EPOCH
  )
</pre>

			
			

		
			
			
			<h2 id="IsEligibleForActivationQueue">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=12668:12734#L325">IsEligibleForActivationQueue</a>
				<a class="permalink" href="index.html#IsEligibleForActivationQueue">&#xb6;</a>
				
				
			</h2>
			<pre>func IsEligibleForActivationQueue(validator *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Validator">Validator</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsEligibleForActivationQueue checks if the validator is eligible to
be placed into the activation queue.
<p>Spec pseudocode definition:
<pre>def is_eligible_for_activation_queue(validator: Validator) -&gt; bool:
  &quot;&quot;&quot;
  Check if ``validator`` is eligible to be placed into the activation queue.
  &quot;&quot;&quot;
  return (
      validator.activation_eligibility_epoch == FAR_FUTURE_EPOCH
      and validator.effective_balance == MAX_EFFECTIVE_BALANCE
  )
</pre>

			
			

		
			
			
			<h2 id="IsEligibleForActivationQueueUsingTrie">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=12974:13056#L331">IsEligibleForActivationQueueUsingTrie</a>
				<a class="permalink" href="index.html#IsEligibleForActivationQueueUsingTrie">&#xb6;</a>
				
				
			</h2>
			<pre>func IsEligibleForActivationQueueUsingTrie(validator <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidator">ReadOnlyValidator</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsEligibleForActivationQueueUsingTrie checks if the read-only validator is eligible to
be placed into the activation queue.

			
			

		
			
			
			<h2 id="IsEligibleForActivationUsingTrie">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=14390:14499#L360">IsEligibleForActivationUsingTrie</a>
				<a class="permalink" href="index.html#IsEligibleForActivationUsingTrie">&#xb6;</a>
				
				
			</h2>
			<pre>func IsEligibleForActivationUsingTrie(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyCheckpoint">ReadOnlyCheckpoint</a>, validator <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidator">ReadOnlyValidator</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsEligibleForActivationUsingTrie checks if the validator is eligible for activation.

			
			

		
			
			
			<h2 id="IsInInactivityLeak">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=5477:5544#L148">IsInInactivityLeak</a>
				<a class="permalink" href="index.html#IsInInactivityLeak">&#xb6;</a>
				
				
			</h2>
			<pre>func IsInInactivityLeak(prevEpoch, finalizedEpoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsInInactivityLeak returns true if the state is experiencing inactivity leak.
<p>Spec code:
def is_in_inactivity_leak(state: BeaconState) -&gt; bool:
<pre>return get_finality_delay(state) &gt; MIN_EPOCHS_TO_INACTIVITY_PENALTY
</pre>

			
			

		
			
			
			<h2 id="IsNextPeriodSyncCommittee">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go?s=2203:2308#L54">IsNextPeriodSyncCommittee</a>
				<a class="permalink" href="index.html#IsNextPeriodSyncCommittee">&#xb6;</a>
				
				
			</h2>
			<pre>func IsNextPeriodSyncCommittee(
    st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconStateAltair">BeaconStateAltair</a>, valIdx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IsNextPeriodSyncCommittee returns true if the input validator index belongs in the next period sync committee
along with the sync period boundary root.
1. Checks if the public key exists in the sync committee cache
2. If 1 fails, checks if the public key exists in the input next sync committee object

			
			

		
			
			
			<h2 id="IsSlashableValidator">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=2159:2270#L48">IsSlashableValidator</a>
				<a class="permalink" href="index.html#IsSlashableValidator">&#xb6;</a>
				
				
			</h2>
			<pre>func IsSlashableValidator(activationEpoch, withdrawableEpoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>, slashed <a href="../../../../../../builtin/index.html#bool">bool</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsSlashableValidator returns the boolean value on whether the validator
is slashable or not.
<p>Spec pseudocode definition:
<pre>def is_slashable_validator(validator: Validator, epoch: Epoch) -&gt; bool:
&quot;&quot;&quot;
Check if ``validator`` is slashable.
&quot;&quot;&quot;
return (not validator.slashed) and (validator.activation_epoch &lt;= epoch &lt; validator.withdrawable_epoch)
</pre>

			
			

		
			
			
			<h2 id="IsSlashableValidatorUsingTrie">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=2439:2526#L53">IsSlashableValidatorUsingTrie</a>
				<a class="permalink" href="index.html#IsSlashableValidatorUsingTrie">&#xb6;</a>
				
				
			</h2>
			<pre>func IsSlashableValidatorUsingTrie(val <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidator">ReadOnlyValidator</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>IsSlashableValidatorUsingTrie checks if a read only validator is slashable.

			
			

		
			
			
			<h2 id="IsWithinWeakSubjectivityPeriod">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/weak_subjectivity.go?s=5107:5286#L114">IsWithinWeakSubjectivityPeriod</a>
				<a class="permalink" href="index.html#IsWithinWeakSubjectivityPeriod">&#xb6;</a>
				
				
			</h2>
			<pre>func IsWithinWeakSubjectivityPeriod(
    ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, currentEpoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>, wsState <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, wsCheckpoint *<a href="../../../proto/prysm/v1alpha1/index.html">eth</a>.<a href="../../../proto/prysm/v1alpha1/index.html#WeakSubjectivityCheckpoint">WeakSubjectivityCheckpoint</a>) (<a href="../../../../../../builtin/index.html#bool">bool</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>IsWithinWeakSubjectivityPeriod verifies if a given weak subjectivity checkpoint is not stale i.e.
the current node is so far beyond, that a given state and checkpoint are not for the latest weak
subjectivity point. Provided checkpoint still can be used to double-check that node&apos;s block root
at a given epoch matches that of the checkpoint.
<p>Reference implementation:
<a href="https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/weak-subjectivity.md#checking-for-stale-weak-subjectivity-checkpoint">https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/weak-subjectivity.md#checking-for-stale-weak-subjectivity-checkpoint</a>
<p>def is_within_weak_subjectivity_period(store: Store, ws_state: BeaconState, ws_checkpoint: Checkpoint) -&gt; bool:
<pre># Clients may choose to validate the input state against the input Weak Subjectivity Checkpoint
assert ws_state.latest_block_header.state_root == ws_checkpoint.root
assert compute_epoch_at_slot(ws_state.slot) == ws_checkpoint.epoch

ws_period = compute_weak_subjectivity_period(ws_state)
ws_state_epoch = compute_epoch_at_slot(ws_state.slot)
current_epoch = compute_epoch_at_slot(get_current_slot(store))
return current_epoch &lt;= ws_state_epoch + ws_period
</pre>

			
			

		
			
			
			<h2 id="LatestWeakSubjectivityEpoch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/weak_subjectivity.go?s=6723:6827#L146">LatestWeakSubjectivityEpoch</a>
				<a class="permalink" href="index.html#LatestWeakSubjectivityEpoch">&#xb6;</a>
				
				
			</h2>
			<pre>func LatestWeakSubjectivityEpoch(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>LatestWeakSubjectivityEpoch returns epoch of the most recent weak subjectivity checkpoint known to a node.
<p>Within the weak subjectivity period, if two conflicting blocks are finalized, 1/3 - D (D := safety decay)
of validators will get slashed. Therefore, it is safe to assume that any finalized checkpoint within that
period is protected by this safety margin.

			
			

		
			
			
			<h2 id="NextPeriodSyncSubcommitteeIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go?s=4029:4160#L115">NextPeriodSyncSubcommitteeIndices</a>
				<a class="permalink" href="index.html#NextPeriodSyncSubcommitteeIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func NextPeriodSyncSubcommitteeIndices(
    st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconStateAltair">BeaconStateAltair</a>, valIdx <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>,
) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>NextPeriodSyncSubcommitteeIndices returns the subcommittee indices of the next period sync committee for input validator.

			
			

		
			
			
			<h2 id="ParseWeakSubjectivityInputString">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/weak_subjectivity.go?s=7130:7219#L157">ParseWeakSubjectivityInputString</a>
				<a class="permalink" href="index.html#ParseWeakSubjectivityInputString">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseWeakSubjectivityInputString(wsCheckpointString <a href="../../../../../../builtin/index.html#string">string</a>) (*<a href="../../../proto/prysm/v1alpha1/index.html">eth</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Checkpoint">Checkpoint</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ParseWeakSubjectivityInputString parses &quot;blocks_root:epoch_number&quot; string into a checkpoint.

			
			

		
			
			
			<h2 id="RandaoMix">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/randao.go?s=1702:1784#L38">RandaoMix</a>
				<a class="permalink" href="index.html#RandaoMix">&#xb6;</a>
				
				
			</h2>
			<pre>func RandaoMix(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) ([]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>RandaoMix returns the randao mix (xor&apos;ed seed)
of a given slot. It is used to shuffle validators.
<p>Spec pseudocode definition:
<pre>def get_randao_mix(state: BeaconState, epoch: Epoch) -&gt; Bytes32:
 &quot;&quot;&quot;
 Return the randao mix at a recent ``epoch``.
 &quot;&quot;&quot;
 return state.randao_mixes[epoch % EPOCHS_PER_HISTORICAL_VECTOR]
</pre>

			
			

		
			
			
			<h2 id="Seed">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/randao.go?s=749:863#L11">Seed</a>
				<a class="permalink" href="index.html#Seed">&#xb6;</a>
				
				
			</h2>
			<pre>func Seed(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>, domain [<a href="../../../crypto/bls/index.html">bls</a>.<a href="../../../crypto/bls/index.html#DomainByteLength">DomainByteLength</a>]<a href="../../../../../../builtin/index.html#byte">byte</a>) ([32]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>Seed returns the randao seed used for shuffling of a given epoch.
<p>Spec pseudocode definition:
<pre>def get_seed(state: BeaconState, epoch: Epoch, domain_type: DomainType) -&gt; Bytes32:
  &quot;&quot;&quot;
  Return the seed at ``epoch``.
  &quot;&quot;&quot;
  mix = get_randao_mix(state, Epoch(epoch + EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1))  # Avoid underflow
  return hash(domain_type + uint_to_bytes(epoch) + mix)
</pre>

			
			

		
			
			
			<h2 id="ShuffleList">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=6260:6353#L142">ShuffleList</a>
				<a class="permalink" href="index.html#ShuffleList">&#xb6;</a>
				
				
			</h2>
			<pre>func ShuffleList(input []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ShuffleList returns list of shuffled indexes in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy.
We utilize &apos;swap or not&apos; shuffling in this implementation; we are allocating the memory with the seed that stays
constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based
on the original implementation from protolambda, <a href="https://github.com/protolambda/eth2-shuffle">https://github.com/protolambda/eth2-shuffle</a>
<pre>improvements:
 - seed is always the first 32 bytes of the hash input, we just copy it into the buffer one time.
 - add round byte to seed and hash that part of the buffer.
 - split up the for-loop in two:
  1. Handle the part from 0 (incl) to pivot (incl). This is mirrored around (pivot / 2).
  2. Handle the part from pivot (excl) to N (excl). This is mirrored around ((pivot / 2) + (size/2)).
 - hash source every 256 iterations.
 - change byteV every 8 iterations.
 - we start at the edges, and work back to the mirror point.
   this makes us process each pear exactly once (instead of unnecessarily twice, like in the spec).
</pre>

			
			

		
			
			
			<h2 id="ShuffledIndex">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=1311:1421#L28">ShuffledIndex</a>
				<a class="permalink" href="index.html#ShuffledIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func ShuffledIndex(index <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, indexCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ShuffledIndex returns `p(index)` in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy.
We utilize &apos;swap or not&apos; shuffling in this implementation; we are allocating the memory with the seed that stays
constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based
on the original implementation from protolambda, <a href="https://github.com/protolambda/eth2-shuffle">https://github.com/protolambda/eth2-shuffle</a>

			
			

		
			
			
			<h2 id="ShuffledIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=9945:10045#L249">ShuffledIndices</a>
				<a class="permalink" href="index.html#ShuffledIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func ShuffledIndices(s <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ShuffledIndices uses input beacon state and returns the shuffled indices of the input epoch,
the shuffled indices then can be used to break up into committees.

			
			

		
			
			
			<h2 id="SlotCommitteeCount">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=1713:1772#L36">SlotCommitteeCount</a>
				<a class="permalink" href="index.html#SlotCommitteeCount">&#xb6;</a>
				
				
			</h2>
			<pre>func SlotCommitteeCount(activeValidatorCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>) <a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>SlotCommitteeCount returns the number of beacon committees of a slot. The
active validator count is provided as an argument rather than an imported implementation
from the spec definition. Having the active validator count as an argument allows for
cheaper computation, instead of retrieving head state, one can retrieve the validator
count.
<p>Spec pseudocode definition:
<pre>def get_committee_count_per_slot(state: BeaconState, epoch: Epoch) -&gt; uint64:
 &quot;&quot;&quot;
 Return the number of committees in each slot for the given ``epoch``.
 &quot;&quot;&quot;
 return max(uint64(1), min(
     MAX_COMMITTEES_PER_SLOT,
     uint64(len(get_active_validator_indices(state, epoch))) // SLOTS_PER_EPOCH // TARGET_COMMITTEE_SIZE,
 ))
</pre>

			
			

		
			
			
			<h2 id="SplitIndices">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=575:625#L13">SplitIndices</a>
				<a class="permalink" href="index.html#SplitIndices">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitIndices(l []<a href="../../../../../../builtin/index.html#uint64">uint64</a>, n <a href="../../../../../../builtin/index.html#uint64">uint64</a>) [][]<a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>SplitIndices splits a list into n pieces.

			
			

		
			
			
			<h2 id="StateRootAtSlot">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/block.go?s=1944:2030#L42">StateRootAtSlot</a>
				<a class="permalink" href="index.html#StateRootAtSlot">&#xb6;</a>
				
				
			</h2>
			<pre>func StateRootAtSlot(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, slot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>) ([]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>StateRootAtSlot returns the cached state root at that particular slot. If no state
root has been cached it will return a zero-hash.

			
			

		
			
			
			<h2 id="TotalActiveBalance">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=1911:1979#L46">TotalActiveBalance</a>
				<a class="permalink" href="index.html#TotalActiveBalance">&#xb6;</a>
				
				
			</h2>
			<pre>func TotalActiveBalance(s <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>) (<a href="../../../../../../builtin/index.html#uint64">uint64</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>TotalActiveBalance returns the total amount at stake in Gwei
of active validators.
<p>Spec pseudocode definition:
<pre>def get_total_active_balance(state: BeaconState) -&gt; Gwei:
 &quot;&quot;&quot;
 Return the combined effective balance of the active validators.
 Note: ``get_total_balance`` returns ``EFFECTIVE_BALANCE_INCREMENT`` Gwei minimum to avoid divisions by zero.
 &quot;&quot;&quot;
 return get_total_balance(state, set(get_active_validator_indices(state, get_current_epoch(state))))
</pre>

			
			

		
			
			
			<h2 id="TotalBalance">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/rewards_penalties.go?s=939:1027#L17">TotalBalance</a>
				<a class="permalink" href="index.html#TotalBalance">&#xb6;</a>
				
				
			</h2>
			<pre>func TotalBalance(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyValidators">ReadOnlyValidators</a>, indices []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>) <a href="../../../../../../builtin/index.html#uint64">uint64</a></pre>
			<p>TotalBalance returns the total amount at stake in Gwei
of input validators.
<p>Spec pseudocode definition:
<pre>def get_total_balance(state: BeaconState, indices: Set[ValidatorIndex]) -&gt; Gwei:
 &quot;&quot;&quot;
 Return the combined effective balance of the ``indices``.
 ``EFFECTIVE_BALANCE_INCREMENT`` Gwei minimum to avoid divisions by zero.
 Math safe up to ~10B ETH, afterwhich this overflows uint64.
 &quot;&quot;&quot;
 return Gwei(max(EFFECTIVE_BALANCE_INCREMENT, sum([state.validators[index].effective_balance for index in indices])))
</pre>

			
			

		
			
			
			<h2 id="UnShuffledIndex">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=1683:1795#L34">UnShuffledIndex</a>
				<a class="permalink" href="index.html#UnShuffledIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func UnShuffledIndex(index <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, indexCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>) (<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>UnShuffledIndex returns the inverse of ShuffledIndex. This implementation is based
on the original implementation from protolambda, <a href="https://github.com/protolambda/eth2-shuffle">https://github.com/protolambda/eth2-shuffle</a>

			
			

		
			
			
			<h2 id="UnshuffleList">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/shuffle.go?s=6501:6596#L147">UnshuffleList</a>
				<a class="permalink" href="index.html#UnshuffleList">&#xb6;</a>
				
				
			</h2>
			<pre>func UnshuffleList(input []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, seed [32]<a href="../../../../../../builtin/index.html#byte">byte</a>) ([]<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>UnshuffleList un-shuffles the list by running backwards through the round count.

			
			

		
			
			
			<h2 id="UpdateCommitteeCache">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=10857:10940#L271">UpdateCommitteeCache</a>
				<a class="permalink" href="index.html#UpdateCommitteeCache">&#xb6;</a>
				
				
			</h2>
			<pre>func UpdateCommitteeCache(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, epoch <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Epoch">Epoch</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>UpdateCommitteeCache gets called at the beginning of every epoch to cache the committee shuffled indices
list with committee index and epoch number. It caches the shuffled indices for current epoch and next epoch.

			
			

		
			
			
			<h2 id="UpdateGenesisEth1Data">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/genesis.go?s=335:466#L4">UpdateGenesisEth1Data</a>
				<a class="permalink" href="index.html#UpdateGenesisEth1Data">&#xb6;</a>
				
				
			</h2>
			<pre>func UpdateGenesisEth1Data(state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, deposits []*<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Deposit">Deposit</a>, eth1Data *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Eth1Data">Eth1Data</a>) (<a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconState">BeaconState</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>UpdateGenesisEth1Data updates eth1 data for genesis state.

			
			

		
			
			
			<h2 id="UpdateProposerIndicesInCache">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=12120:12213#L311">UpdateProposerIndicesInCache</a>
				<a class="permalink" href="index.html#UpdateProposerIndicesInCache">&#xb6;</a>
				
				
			</h2>
			<pre>func UpdateProposerIndicesInCache(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>UpdateProposerIndicesInCache updates proposer indices entry of the committee cache.

			
			

		
			
			
			<h2 id="UpdateSyncCommitteeCache">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/sync_committee.go?s=4877:4940#L143">UpdateSyncCommitteeCache</a>
				<a class="permalink" href="index.html#UpdateSyncCommitteeCache">&#xb6;</a>
				
				
			</h2>
			<pre>func UpdateSyncCommitteeCache(st <a href="../../state/index.html">state</a>.<a href="../../state/index.html#BeaconStateAltair">BeaconStateAltair</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>UpdateSyncCommitteeCache updates sync committee cache.
It uses `state`&apos;s latest block header root as key. To avoid misuse, it disallows
block header with state root zeroed out.

			
			

		
			
			
			<h2 id="ValidateAttestationTime">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=6149:6256#L134">ValidateAttestationTime</a>
				<a class="permalink" href="index.html#ValidateAttestationTime">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidateAttestationTime(attSlot <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>, genesisTime <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>, clockDisparity <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Duration">Duration</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>ValidateAttestationTime Validates that the incoming attestation is in the desired time range.
An attestation is valid only if received within the last ATTESTATION_PROPAGATION_SLOT_RANGE
slots.
<p>Example:
<pre>ATTESTATION_PROPAGATION_SLOT_RANGE = 5
clockDisparity = 24 seconds
current_slot = 100
invalid_attestation_slot = 92
invalid_attestation_slot = 103
valid_attestation_slot = 98
valid_attestation_slot = 101
</pre>
<p>In the attestation must be within the range of 95 to 102 in the example above.

			
			

		
			
			
			<h2 id="ValidateNilAttestation">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=626:691#L11">ValidateNilAttestation</a>
				<a class="permalink" href="index.html#ValidateNilAttestation">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidateNilAttestation(attestation *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>ValidateNilAttestation checks if any composite field of input attestation is nil.
Access to these nil fields will result in run time panic,
it is recommended to run these checks as first line of defense.

			
			

		
			
			
			<h2 id="ValidateSlotTargetEpoch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=1364:1427#L32">ValidateSlotTargetEpoch</a>
				<a class="permalink" href="index.html#ValidateSlotTargetEpoch">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidateSlotTargetEpoch(data *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#AttestationData">AttestationData</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>ValidateSlotTargetEpoch checks if attestation data&apos;s epoch matches target checkpoint&apos;s epoch.
It is recommended to run `ValidateNilAttestation` first to ensure `data.Target` can&apos;t be nil.

			
			

		
			
			
			<h2 id="ValidatorChurnLimit">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/validators.go?s=7614:7683#L198">ValidatorChurnLimit</a>
				<a class="permalink" href="index.html#ValidatorChurnLimit">&#xb6;</a>
				
				
			</h2>
			<pre>func ValidatorChurnLimit(activeValidatorCount <a href="../../../../../../builtin/index.html#uint64">uint64</a>) (<a href="../../../../../../builtin/index.html#uint64">uint64</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ValidatorChurnLimit returns the number of validators that are allowed to
enter and exit validator pool for an epoch.
<p>Spec pseudocode definition:
<pre>def get_validator_churn_limit(state: BeaconState) -&gt; uint64:
 &quot;&quot;&quot;
 Return the validator churn limit for the current epoch.
 &quot;&quot;&quot;
 active_validator_indices = get_active_validator_indices(state, get_current_epoch(state))
 return max(MIN_PER_EPOCH_CHURN_LIMIT, uint64(len(active_validator_indices)) // CHURN_LIMIT_QUOTIENT)
</pre>

			
			

		
			
			
			<h2 id="VerifyAttestationBitfieldLengths">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=9206:9327#L231">VerifyAttestationBitfieldLengths</a>
				<a class="permalink" href="index.html#VerifyAttestationBitfieldLengths">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyAttestationBitfieldLengths(ctx <a href="../../../../../../context/index.html">context</a>.<a href="../../../../../../context/index.html#Context">Context</a>, state <a href="../../state/index.html">state</a>.<a href="../../state/index.html#ReadOnlyBeaconState">ReadOnlyBeaconState</a>, att *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Attestation">Attestation</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyAttestationBitfieldLengths verifies that an attestations aggregation bitfields is
a valid length matching the size of the committee.

			
			

		
			
			
			<h2 id="VerifyBitfieldLength">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=8827:8902#L219">VerifyBitfieldLength</a>
				<a class="permalink" href="index.html#VerifyBitfieldLength">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyBitfieldLength(bf bitfield.<a href="index.html#Bitfield">Bitfield</a>, committeeSize <a href="../../../../../../builtin/index.html#uint64">uint64</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
			<p>VerifyBitfieldLength verifies that a bitfield length matches the given committee size.

			
			

		
			
			
			<h2 id="VerifyCheckpointEpoch">func <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/attestation.go?s=7817:7888#L176">VerifyCheckpointEpoch</a>
				<a class="permalink" href="index.html#VerifyCheckpointEpoch">&#xb6;</a>
				
				
			</h2>
			<pre>func VerifyCheckpointEpoch(c *<a href="../../../proto/prysm/v1alpha1/index.html">ethpb</a>.<a href="../../../proto/prysm/v1alpha1/index.html#Checkpoint">Checkpoint</a>, genesis <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>) <a href="../../../../../../builtin/index.html#bool">bool</a></pre>
			<p>VerifyCheckpointEpoch is within current epoch and previous epoch
with respect to current time. Returns true if it&apos;s within, false if it&apos;s not.

			
			

		
		
			
			
			<h2 id="CommitteeAssignmentContainer">type <a href="http://localhost:6060/src/github.com/prysmaticlabs/prysm/beacon-chain/core/helpers/beacon_committee.go?s=5700:5847#L133">CommitteeAssignmentContainer</a>
				<a class="permalink" href="index.html#CommitteeAssignmentContainer">&#xb6;</a>
				
				
			</h2>
			<p>CommitteeAssignmentContainer represents a committee list, committee index, and to be attested slot for a given epoch.

			<pre>type CommitteeAssignmentContainer struct {
<span id="CommitteeAssignmentContainer.Committee"></span>    Committee      []<a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#ValidatorIndex">ValidatorIndex</a>
<span id="CommitteeAssignmentContainer.AttesterSlot"></span>    AttesterSlot   <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#Slot">Slot</a>
<span id="CommitteeAssignmentContainer.CommitteeIndex"></span>    CommitteeIndex <a href="../../../../eth2-types/index.html">types</a>.<a href="../../../../eth2-types/index.html#CommitteeIndex">CommitteeIndex</a>
}
</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
