<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>bls12381 - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package bls12381
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/ethereum/go-ethereum/crypto/bls12381"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="index.html#E">type E</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#E.Equal">func (g *E) Equal(g2 *E) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#E.IsOne">func (e *E) IsOne() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#E.One">func (e *E) One() *E</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#E.Set">func (e *E) Set(e2 *E) *E</a></dd>
				
			
				
				<dd><a href="index.html#Engine">type Engine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPairingEngine">func NewPairingEngine() *Engine</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.AddPair">func (e *Engine) AddPair(g1 *PointG1, g2 *PointG2) *Engine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.AddPairInv">func (e *Engine) AddPairInv(g1 *PointG1, g2 *PointG2) *Engine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.Check">func (e *Engine) Check() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.GT">func (e *Engine) GT() *GT</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.Reset">func (e *Engine) Reset() *Engine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Engine.Result">func (e *Engine) Result() *E</a></dd>
				
			
				
				<dd><a href="index.html#G1">type G1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewG1">func NewG1() *G1</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Add">func (g *G1) Add(r, p1, p2 *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Affine">func (g *G1) Affine(p *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.ClearCofactor">func (g *G1) ClearCofactor(p *PointG1)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.DecodePoint">func (g *G1) DecodePoint(in []byte) (*PointG1, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Double">func (g *G1) Double(r, p *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.EncodePoint">func (g *G1) EncodePoint(p *PointG1) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Equal">func (g *G1) Equal(p1, p2 *PointG1) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.FromBytes">func (g *G1) FromBytes(in []byte) (*PointG1, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.InCorrectSubgroup">func (g *G1) InCorrectSubgroup(p *PointG1) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.IsAffine">func (g *G1) IsAffine(p *PointG1) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.IsOnCurve">func (g *G1) IsOnCurve(p *PointG1) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.IsZero">func (g *G1) IsZero(p *PointG1) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.MapToCurve">func (g *G1) MapToCurve(in []byte) (*PointG1, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.MulScalar">func (g *G1) MulScalar(c, p *PointG1, e *big.Int) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.MultiExp">func (g *G1) MultiExp(r *PointG1, points []*PointG1, powers []*big.Int) (*PointG1, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Neg">func (g *G1) Neg(r, p *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.New">func (g *G1) New() *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.One">func (g *G1) One() *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Q">func (g *G1) Q() *big.Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Sub">func (g *G1) Sub(c, a, b *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.ToBytes">func (g *G1) ToBytes(p *PointG1) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G1.Zero">func (g *G1) Zero() *PointG1</a></dd>
				
			
				
				<dd><a href="index.html#G2">type G2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewG2">func NewG2() *G2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Add">func (g *G2) Add(r, p1, p2 *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Affine">func (g *G2) Affine(p *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.ClearCofactor">func (g *G2) ClearCofactor(p *PointG2)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.DecodePoint">func (g *G2) DecodePoint(in []byte) (*PointG2, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Double">func (g *G2) Double(r, p *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.EncodePoint">func (g *G2) EncodePoint(p *PointG2) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Equal">func (g *G2) Equal(p1, p2 *PointG2) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.FromBytes">func (g *G2) FromBytes(in []byte) (*PointG2, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.InCorrectSubgroup">func (g *G2) InCorrectSubgroup(p *PointG2) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.IsAffine">func (g *G2) IsAffine(p *PointG2) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.IsOnCurve">func (g *G2) IsOnCurve(p *PointG2) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.IsZero">func (g *G2) IsZero(p *PointG2) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.MapToCurve">func (g *G2) MapToCurve(in []byte) (*PointG2, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.MulScalar">func (g *G2) MulScalar(c, p *PointG2, e *big.Int) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.MultiExp">func (g *G2) MultiExp(r *PointG2, points []*PointG2, powers []*big.Int) (*PointG2, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Neg">func (g *G2) Neg(r, p *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.New">func (g *G2) New() *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.One">func (g *G2) One() *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Q">func (g *G2) Q() *big.Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Sub">func (g *G2) Sub(c, a, b *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.ToBytes">func (g *G2) ToBytes(p *PointG2) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#G2.Zero">func (g *G2) Zero() *PointG2</a></dd>
				
			
				
				<dd><a href="index.html#GT">type GT</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewGT">func NewGT() *GT</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Add">func (g *GT) Add(c, a, b *E)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Exp">func (g *GT) Exp(c, a *E, s *big.Int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.FromBytes">func (g *GT) FromBytes(in []byte) (*E, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Inverse">func (g *GT) Inverse(c, a *E)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.IsValid">func (g *GT) IsValid(e *E) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Mul">func (g *GT) Mul(c, a, b *E)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.New">func (g *GT) New() *E</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Q">func (g *GT) Q() *big.Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Square">func (g *GT) Square(c, a *E)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.Sub">func (g *GT) Sub(c, a, b *E)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#GT.ToBytes">func (g *GT) ToBytes(e *E) []byte</a></dd>
				
			
				
				<dd><a href="index.html#PointG1">type PointG1</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PointG1.Set">func (p *PointG1) Set(p2 *PointG1) *PointG1</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PointG1.Zero">func (p *PointG1) Zero() *PointG1</a></dd>
				
			
				
				<dd><a href="index.html#PointG2">type PointG2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PointG2.Set">func (p *PointG2) Set(p2 *PointG2) *PointG2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PointG2.Zero">func (p *PointG2) Zero() *PointG2</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/arithmetic_fallback.go">arithmetic_fallback.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/bls12_381.go">bls12_381.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/field_element.go">field_element.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/fp.go">fp.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/fp12.go">fp12.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/fp2.go">fp2.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/fp6.go">fp6.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go">g1.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go">g2.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go">gt.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/isogeny.go">isogeny.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go">pairing.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/swu.go">swu.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/utils.go">utils.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
		
			
			
			<h2 id="E">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=883:896#L15">E</a>
				<a class="permalink" href="index.html#E">&#xb6;</a>
				
				
			</h2>
			<p>E is type for target group element

			<pre>type E = fe12</pre>

			

			

			
			
			

			

			
				
				<h3 id="E.Equal">func (*E) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1310:1339#L38">Equal</a>
					<a class="permalink" href="index.html#E.Equal">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#E">E</a>) Equal(g2 *<a href="index.html#E">E</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>Equal returns true if given two element is equal, otherwise returns false

				
				
				
			
				
				<h3 id="E.IsOne">func (*E) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1185:1209#L33">IsOne</a>
					<a class="permalink" href="index.html#E.IsOne">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#E">E</a>) IsOne() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsOne returns true if given element equals to one

				
				
				
			
				
				<h3 id="E.One">func (*E) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1075:1095#L27">One</a>
					<a class="permalink" href="index.html#E.One">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#E">E</a>) One() *<a href="index.html#E">E</a></pre>
				<p>One sets a new target group element to one

				
				
				
			
				
				<h3 id="E.Set">func (*E) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=980:1005#L22">Set</a>
					<a class="permalink" href="index.html#E.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#E">E</a>) Set(e2 *<a href="index.html#E">E</a>) *<a href="index.html#E">E</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Engine">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=982:1080#L19">Engine</a>
				<a class="permalink" href="index.html#Engine">&#xb6;</a>
				
				
			</h2>
			<p>Engine is BLS12-381 elliptic curve pairing engine

			<pre>type Engine struct {
<span id="Engine.G1"></span>    G1 *<a href="index.html#G1">G1</a>
<span id="Engine.G2"></span>    G2 *<a href="index.html#G2">G2</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewPairingEngine">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=1139:1170#L29">NewPairingEngine</a>
					<a class="permalink" href="index.html#NewPairingEngine">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPairingEngine() *<a href="index.html#Engine">Engine</a></pre>
				<p>NewPairingEngine creates new pairing engine instance.

				
				
			

			
				
				<h3 id="Engine.AddPair">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=1707:1765#L59">AddPair</a>
					<a class="permalink" href="index.html#Engine.AddPair">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) AddPair(g1 *<a href="index.html#PointG1">PointG1</a>, g2 *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#Engine">Engine</a></pre>
				<p>AddPair adds a g1, g2 point pair to pairing engine

				
				
				
			
				
				<h3 id="Engine.AddPairInv">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=1949:2010#L69">AddPairInv</a>
					<a class="permalink" href="index.html#Engine.AddPairInv">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) AddPairInv(g1 *<a href="index.html#PointG1">PointG1</a>, g2 *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#Engine">Engine</a></pre>
				<p>AddPairInv adds a G1, G2 point pair to pairing engine. G1 point is negated.

				
				
				
			
				
				<h3 id="Engine.Check">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=6537:6566#L258">Check</a>
					<a class="permalink" href="index.html#Engine.Check">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) Check() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>Check computes pairing and checks if result is equal to one

				
				
				
			
				
				<h3 id="Engine.GT">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=6785:6810#L270">GT</a>
					<a class="permalink" href="index.html#Engine.GT">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) GT() *<a href="index.html#GT">GT</a></pre>
				<p>GT returns target group instance.

				
				
				
			
				
				<h3 id="Engine.Reset">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=2093:2125#L76">Reset</a>
					<a class="permalink" href="index.html#Engine.Reset">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) Reset() *<a href="index.html#Engine">Engine</a></pre>
				<p>Reset deletes added pairs.

				
				
				
			
				
				<h3 id="Engine.Result">func (*Engine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/pairing.go?s=6673:6701#L263">Result</a>
					<a class="permalink" href="index.html#Engine.Result">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Engine">Engine</a>) Result() *<a href="index.html#E">E</a></pre>
				<p>Result computes pairing and returns target group element as result.

				
				
				
			
		
			
			
			<h2 id="G1">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1371:1397#L40">G1</a>
				<a class="permalink" href="index.html#G1">&#xb6;</a>
				
				
			</h2>
			<p>G1 is struct for G1 group.

			<pre>type G1 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewG1">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1438:1454#L45">NewG1</a>
					<a class="permalink" href="index.html#NewG1">&#xb6;</a>
					
					
				</h3>
				<pre>func NewG1() *<a href="index.html#G1">G1</a></pre>
				<p>NewG1 constructs a new G1 instance.

				
				
			

			
				
				<h3 id="G1.Add">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=5954:5999#L239">Add</a>
					<a class="permalink" href="index.html#G1.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Add(r, p1, p2 *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Add adds two G1 points p1, p2 and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G1.Affine">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=5614:5654#L222">Affine</a>
					<a class="permalink" href="index.html#G1.Affine">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Affine(p *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Add adds two G1 points p1, p2 and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G1.ClearCofactor">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=8501:8539#L349">ClearCofactor</a>
					<a class="permalink" href="index.html#G1.ClearCofactor">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) ClearCofactor(p *<a href="index.html#PointG1">PointG1</a>)</pre>
				<p>ClearCofactor maps given a G1 point to correct subgroup

				
				
				
			
				
				<h3 id="G1.DecodePoint">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=2856:2909#L106">DecodePoint</a>
					<a class="permalink" href="index.html#G1.DecodePoint">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) DecodePoint(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG1">PointG1</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>DecodePoint given encoded (x, y) coordinates in 128 bytes returns a valid G1 Point.

				
				
				
			
				
				<h3 id="G1.Double">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=7044:7087#L287">Double</a>
					<a class="permalink" href="index.html#G1.Double">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Double(r, p *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Double doubles a G1 point p and assigns the result to the point at first argument.

				
				
				
			
				
				<h3 id="G1.EncodePoint">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=3709:3752#L141">EncodePoint</a>
					<a class="permalink" href="index.html#G1.EncodePoint">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) EncodePoint(p *<a href="index.html#PointG1">PointG1</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>EncodePoint encodes a point into 128 bytes.

				
				
				
			
				
				<h3 id="G1.Equal">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=4500:4540#L173">Equal</a>
					<a class="permalink" href="index.html#G1.Equal">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Equal(p1, p2 *<a href="index.html#PointG1">PointG1</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>Equal checks if given two G1 point is equal in their affine form.

				
				
				
			
				
				<h3 id="G1.FromBytes">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=2232:2283#L81">FromBytes</a>
					<a class="permalink" href="index.html#G1.FromBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) FromBytes(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG1">PointG1</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>FromBytes constructs a new point given uncompressed byte input.
FromBytes does not take zcash flags into account.
Byte input expected to be larger than 96 bytes.
First 96 bytes should be concatenation of x and y values.
Point (0, 0) is considered as infinity.

				
				
				
			
				
				<h3 id="G1.InCorrectSubgroup">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=4955:5002#L193">InCorrectSubgroup</a>
					<a class="permalink" href="index.html#G1.InCorrectSubgroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) InCorrectSubgroup(p *<a href="index.html#PointG1">PointG1</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>InCorrectSubgroup checks whether given point is in correct subgroup.

				
				
				
			
				
				<h3 id="G1.IsAffine">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=5465:5503#L217">IsAffine</a>
					<a class="permalink" href="index.html#G1.IsAffine">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) IsAffine(p *<a href="index.html#PointG1">PointG1</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsAffine checks a G1 point whether it is in affine form.

				
				
				
			
				
				<h3 id="G1.IsOnCurve">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=5117:5156#L200">IsOnCurve</a>
					<a class="permalink" href="index.html#G1.IsOnCurve">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) IsOnCurve(p *<a href="index.html#PointG1">PointG1</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsOnCurve checks a G1 point is on curve.

				
				
				
			
				
				<h3 id="G1.IsZero">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=4367:4403#L168">IsZero</a>
					<a class="permalink" href="index.html#G1.IsZero">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) IsZero(p *<a href="index.html#PointG1">PointG1</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsZero returns true if given point is equal to zero.

				
				
				
			
				
				<h3 id="G1.MapToCurve">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=10510:10562#L413">MapToCurve</a>
					<a class="permalink" href="index.html#G1.MapToCurve">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) MapToCurve(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG1">PointG1</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>MapToCurve given a byte slice returns a valid G1 point.
This mapping function implements the Simplified Shallue-van de Woestijne-Ulas method.
<a href="https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06">https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06</a>
Input byte slice should be a valid field element, otherwise an error is returned.

				
				
				
			
				
				<h3 id="G1.MulScalar">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=8213:8271#L335">MulScalar</a>
					<a class="permalink" href="index.html#G1.MulScalar">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) MulScalar(c, p *<a href="index.html#PointG1">PointG1</a>, e *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>MulScalar multiplies a point by given scalar value in big.Int and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G1.MultiExp">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=8903:8992#L357">MultiExp</a>
					<a class="permalink" href="index.html#G1.MultiExp">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) MultiExp(r *<a href="index.html#PointG1">PointG1</a>, points []*<a href="index.html#PointG1">PointG1</a>, powers []*<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>) (*<a href="index.html#PointG1">PointG1</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>MultiExp calculates multi exponentiation. Given pairs of G1 point and scalar values
(P_0, e_0), (P_1, e_1), ... (P_n, e_n) calculates r = e_0 * P_0 + e_1 * P_1 + ... + e_n * P_n
Length of points and scalars are expected to be equal, otherwise an error is returned.
Result is assigned to point at first argument.

				
				
				
			
				
				<h3 id="G1.Neg">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=7794:7834#L319">Neg</a>
					<a class="permalink" href="index.html#G1.Neg">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Neg(r, p *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Neg negates a G1 point p and assigns the result to the point at first argument.

				
				
				
			
				
				<h3 id="G1.New">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=3994:4021#L152">New</a>
					<a class="permalink" href="index.html#G1.New">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) New() *<a href="index.html#PointG1">PointG1</a></pre>
				<p>New creates a new G1 Point which is equal to zero in other words point at infinity.

				
				
				
			
				
				<h3 id="G1.One">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=4239:4266#L162">One</a>
					<a class="permalink" href="index.html#G1.One">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) One() *<a href="index.html#PointG1">PointG1</a></pre>
				<p>One returns a new G1 Point which is equal to generator point.

				
				
				
			
				
				<h3 id="G1.Q">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1636:1661#L59">Q</a>
					<a class="permalink" href="index.html#G1.Q">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Q() *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a></pre>
				<p>Q returns group order in big.Int.

				
				
				
			
				
				<h3 id="G1.Sub">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=7992:8035#L327">Sub</a>
					<a class="permalink" href="index.html#G1.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Sub(c, a, b *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Sub subtracts two G1 points p1, p2 and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G1.ToBytes">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=3469:3508#L129">ToBytes</a>
					<a class="permalink" href="index.html#G1.ToBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) ToBytes(p *<a href="index.html#PointG1">PointG1</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>ToBytes serializes a point into bytes in uncompressed form.
ToBytes does not take zcash flags into account.
ToBytes returns (0, 0) if point is infinity.

				
				
				
			
				
				<h3 id="G1.Zero">func (*G1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=4112:4140#L157">Zero</a>
					<a class="permalink" href="index.html#G1.Zero">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G1">G1</a>) Zero() *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Zero returns a new G1 Point which is equal to point at infinity.

				
				
				
			
		
			
			
			<h2 id="G2">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1419:1453#L41">G2</a>
				<a class="permalink" href="index.html#G2">&#xb6;</a>
				
				
			</h2>
			<p>G2 is struct for G2 group.

			<pre>type G2 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewG2">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1494:1510#L47">NewG2</a>
					<a class="permalink" href="index.html#NewG2">&#xb6;</a>
					
					
				</h3>
				<pre>func NewG2() *<a href="index.html#G2">G2</a></pre>
				<p>NewG2 constructs a new G2 instance.

				
				
			

			
				
				<h3 id="G2.Add">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=6506:6551#L259">Add</a>
					<a class="permalink" href="index.html#G2.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Add(r, p1, p2 *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Add adds two G2 points p1, p2 and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G2.Affine">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=6146:6186#L242">Affine</a>
					<a class="permalink" href="index.html#G2.Affine">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Affine(p *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Affine calculates affine form of given G2 point.

				
				
				
			
				
				<h3 id="G2.ClearCofactor">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=9257:9295#L369">ClearCofactor</a>
					<a class="permalink" href="index.html#G2.ClearCofactor">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) ClearCofactor(p *<a href="index.html#PointG2">PointG2</a>)</pre>
				<p>ClearCofactor maps given a G2 point to correct subgroup

				
				
				
			
				
				<h3 id="G2.DecodePoint">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=3017:3070#L115">DecodePoint</a>
					<a class="permalink" href="index.html#G2.DecodePoint">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) DecodePoint(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG2">PointG2</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>DecodePoint given encoded (x, y) coordinates in 256 bytes returns a valid G1 Point.

				
				
				
			
				
				<h3 id="G2.Double">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=7712:7755#L307">Double</a>
					<a class="permalink" href="index.html#G2.Double">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Double(r, p *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Double doubles a G2 point p and assigns the result to the point at first argument.

				
				
				
			
				
				<h3 id="G2.EncodePoint">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4089:4132#L158">EncodePoint</a>
					<a class="permalink" href="index.html#G2.EncodePoint">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) EncodePoint(p *<a href="index.html#PointG2">PointG2</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>EncodePoint encodes a point into 256 bytes.

				
				
				
			
				
				<h3 id="G2.Equal">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4999:5039#L193">Equal</a>
					<a class="permalink" href="index.html#G2.Equal">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Equal(p1, p2 *<a href="index.html#PointG2">PointG2</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>Equal checks if given two G2 point is equal in their affine form.

				
				
				
			
				
				<h3 id="G2.FromBytes">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=2382:2433#L90">FromBytes</a>
					<a class="permalink" href="index.html#G2.FromBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) FromBytes(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG2">PointG2</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>FromBytes constructs a new point given uncompressed byte input.
FromBytes does not take zcash flags into account.
Byte input expected to be larger than 96 bytes.
First 192 bytes should be concatenation of x and y values
Point (0, 0) is considered as infinity.

				
				
				
			
				
				<h3 id="G2.InCorrectSubgroup">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=5486:5533#L213">InCorrectSubgroup</a>
					<a class="permalink" href="index.html#G2.InCorrectSubgroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) InCorrectSubgroup(p *<a href="index.html#PointG2">PointG2</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>InCorrectSubgroup checks whether given point is in correct subgroup.

				
				
				
			
				
				<h3 id="G2.IsAffine">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=6029:6067#L237">IsAffine</a>
					<a class="permalink" href="index.html#G2.IsAffine">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) IsAffine(p *<a href="index.html#PointG2">PointG2</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsAffine checks a G2 point whether it is in affine form.

				
				
				
			
				
				<h3 id="G2.IsOnCurve">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=5648:5687#L220">IsOnCurve</a>
					<a class="permalink" href="index.html#G2.IsOnCurve">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) IsOnCurve(p *<a href="index.html#PointG2">PointG2</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsOnCurve checks a G2 point is on curve.

				
				
				
			
				
				<h3 id="G2.IsZero">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4866:4902#L188">IsZero</a>
					<a class="permalink" href="index.html#G2.IsZero">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) IsZero(p *<a href="index.html#PointG2">PointG2</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsZero returns true if given point is equal to zero.

				
				
				
			
				
				<h3 id="G2.MapToCurve">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=11280:11332#L433">MapToCurve</a>
					<a class="permalink" href="index.html#G2.MapToCurve">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) MapToCurve(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#PointG2">PointG2</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>MapToCurve given a byte slice returns a valid G2 point.
This mapping function implements the Simplified Shallue-van de Woestijne-Ulas method.
<a href="https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-6.6.2">https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-6.6.2</a>
Input byte slice should be a valid field element, otherwise an error is returned.

				
				
				
			
				
				<h3 id="G2.MulScalar">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=8969:9027#L355">MulScalar</a>
					<a class="permalink" href="index.html#G2.MulScalar">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) MulScalar(c, p *<a href="index.html#PointG2">PointG2</a>, e *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>MulScalar multiplies a point by given scalar value in big.Int and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G2.MultiExp">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=9659:9748#L377">MultiExp</a>
					<a class="permalink" href="index.html#G2.MultiExp">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) MultiExp(r *<a href="index.html#PointG2">PointG2</a>, points []*<a href="index.html#PointG2">PointG2</a>, powers []*<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>) (*<a href="index.html#PointG2">PointG2</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>MultiExp calculates multi exponentiation. Given pairs of G2 point and scalar values
(P_0, e_0), (P_1, e_1), ... (P_n, e_n) calculates r = e_0 * P_0 + e_1 * P_1 + ... + e_n * P_n
Length of points and scalars are expected to be equal, otherwise an error is returned.
Result is assigned to point at first argument.

				
				
				
			
				
				<h3 id="G2.Neg">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=8546:8586#L339">Neg</a>
					<a class="permalink" href="index.html#G2.Neg">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Neg(r, p *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Neg negates a G2 point p and assigns the result to the point at first argument.

				
				
				
			
				
				<h3 id="G2.New">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4482:4509#L172">New</a>
					<a class="permalink" href="index.html#G2.New">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) New() *<a href="index.html#PointG2">PointG2</a></pre>
				<p>New creates a new G2 Point which is equal to zero in other words point at infinity.

				
				
				
			
				
				<h3 id="G2.One">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4738:4765#L182">One</a>
					<a class="permalink" href="index.html#G2.One">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) One() *<a href="index.html#PointG2">PointG2</a></pre>
				<p>One returns a new G2 Point which is equal to generator point.

				
				
				
			
				
				<h3 id="G2.Q">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1777:1802#L68">Q</a>
					<a class="permalink" href="index.html#G2.Q">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Q() *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a></pre>
				<p>Q returns group order in big.Int.

				
				
				
			
				
				<h3 id="G2.Sub">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=8748:8791#L347">Sub</a>
					<a class="permalink" href="index.html#G2.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Sub(c, a, b *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Sub subtracts two G2 points p1, p2 and assigns the result to point at first argument.

				
				
				
			
				
				<h3 id="G2.ToBytes">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=3840:3879#L146">ToBytes</a>
					<a class="permalink" href="index.html#G2.ToBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) ToBytes(p *<a href="index.html#PointG2">PointG2</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>ToBytes serializes a point into bytes in uncompressed form,
does not take zcash flags into account,
returns (0, 0) if point is infinity.

				
				
				
			
				
				<h3 id="G2.Zero">func (*G2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=4611:4639#L177">Zero</a>
					<a class="permalink" href="index.html#G2.Zero">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#G2">G2</a>) Zero() *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Zero returns a new G2 Point which is equal to point at infinity.

				
				
				
			
		
			
			
			<h2 id="GT">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=948:978#L18">GT</a>
				<a class="permalink" href="index.html#GT">&#xb6;</a>
				
				
			</h2>
			<p>GT is type for target multiplicative group GT.

			<pre>type GT struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewGT">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1412:1428#L43">NewGT</a>
					<a class="permalink" href="index.html#NewGT">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGT() *<a href="index.html#GT">GT</a></pre>
				<p>NewGT constructs new target group instance.

				
				
			

			
				
				<h3 id="GT.Add">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2403:2431#L84">Add</a>
					<a class="permalink" href="index.html#GT.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Add(c, a, b *<a href="index.html#E">E</a>)</pre>
				<p>Add adds two field element `a` and `b` and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.Exp">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=3038:3075#L104">Exp</a>
					<a class="permalink" href="index.html#GT.Exp">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Exp(c, a *<a href="index.html#E">E</a>, s *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>)</pre>
				<p>Exp exponents an element `a` by a scalar `s` and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.FromBytes">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1711:1756#L55">FromBytes</a>
					<a class="permalink" href="index.html#GT.FromBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) FromBytes(in []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#E">E</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>FromBytes expects 576 byte input and returns target group element
FromBytes returns error if given element is not on correct subgroup.

				
				
				
			
				
				<h3 id="GT.Inverse">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=3204:3233#L109">Inverse</a>
					<a class="permalink" href="index.html#GT.Inverse">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Inverse(c, a *<a href="index.html#E">E</a>)</pre>
				<p>Inverse inverses an element `a` and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.IsValid">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2098:2129#L72">IsValid</a>
					<a class="permalink" href="index.html#GT.IsValid">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) IsValid(e *<a href="index.html#E">E</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsValid checks whether given target group element is in correct subgroup.

				
				
				
			
				
				<h3 id="GT.Mul">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2723:2751#L94">Mul</a>
					<a class="permalink" href="index.html#GT.Mul">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Mul(c, a, b *<a href="index.html#E">E</a>)</pre>
				<p>Mul multiplies two field element `a` and `b` and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.New">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2256:2277#L79">New</a>
					<a class="permalink" href="index.html#GT.New">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) New() *<a href="index.html#E">E</a></pre>
				<p>New initializes a new target group element which is equal to one

				
				
				
			
				
				<h3 id="GT.Q">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1511:1536#L49">Q</a>
					<a class="permalink" href="index.html#GT.Q">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Q() *<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a></pre>
				<p>Q returns group order in big.Int.

				
				
				
			
				
				<h3 id="GT.Square">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2868:2896#L99">Square</a>
					<a class="permalink" href="index.html#GT.Square">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Square(c, a *<a href="index.html#E">E</a>)</pre>
				<p>Square squares an element `a` and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.Sub">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=2563:2591#L89">Sub</a>
					<a class="permalink" href="index.html#GT.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) Sub(c, a, b *<a href="index.html#E">E</a>)</pre>
				<p>Sub subtracts two field element `a` and `b`, and assigns the result to the element in first argument.

				
				
				
			
				
				<h3 id="GT.ToBytes">func (*GT) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/gt.go?s=1956:1989#L67">ToBytes</a>
					<a class="permalink" href="index.html#GT.ToBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#GT">GT</a>) ToBytes(e *<a href="index.html#E">E</a>) []<a href="../../../../../builtin/index.html#byte">byte</a></pre>
				<p>ToBytes serializes target group element.

				
				
				
			
		
			
			
			<h2 id="PointG1">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1026:1044#L18">PointG1</a>
				<a class="permalink" href="index.html#PointG1">&#xb6;</a>
				
				
			</h2>
			<p>PointG1 is type for point in G1.
PointG1 is both used for Affine and Jacobian point representation.
If z is equal to one the point is considered as in affine form.

			<pre>type PointG1 [3]fe</pre>

			

			

			
			
			

			

			
				
				<h3 id="PointG1.Set">func (*PointG1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1046:1089#L20">Set</a>
					<a class="permalink" href="index.html#PointG1.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#PointG1">PointG1</a>) Set(p2 *<a href="index.html#PointG1">PointG1</a>) *<a href="index.html#PointG1">PointG1</a></pre>
				
				
				
				
			
				
				<h3 id="PointG1.Zero">func (*PointG1) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g1.go?s=1220:1253#L28">Zero</a>
					<a class="permalink" href="index.html#PointG1.Zero">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#PointG1">PointG1</a>) Zero() *<a href="index.html#PointG1">PointG1</a></pre>
				<p>Zero returns G1 point in point at infinity representation

				
				
				
			
		
			
			
			<h2 id="PointG2">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1026:1045#L18">PointG2</a>
				<a class="permalink" href="index.html#PointG2">&#xb6;</a>
				
				
			</h2>
			<p>PointG2 is type for point in G2.
PointG2 is both used for Affine and Jacobian point representation.
If z is equal to one the point is considered as in affine form.

			<pre>type PointG2 [3]fe2</pre>

			

			

			
			
			

			

			
				
				<h3 id="PointG2.Set">func (*PointG2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1093:1136#L21">Set</a>
					<a class="permalink" href="index.html#PointG2.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#PointG2">PointG2</a>) Set(p2 *<a href="index.html#PointG2">PointG2</a>) *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Set copies valeus of one point to another.

				
				
				
			
				
				<h3 id="PointG2.Zero">func (*PointG2) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/crypto/bls12381/g2.go?s=1267:1300#L29">Zero</a>
					<a class="permalink" href="index.html#PointG2.Zero">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#PointG2">PointG2</a>) Zero() *<a href="index.html#PointG2">PointG2</a></pre>
				<p>Zero returns G2 point in point at infinity representation

				
				
				
			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
