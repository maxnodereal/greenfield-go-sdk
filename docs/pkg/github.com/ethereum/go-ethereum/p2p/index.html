<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>p2p - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package p2p
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/ethereum/go-ethereum/p2p"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package p2p implements the Ethereum p2p network protocols.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#ExpectMsg">func ExpectMsg(r MsgReader, code uint64, content interface{}) error</a></dd>
			
				
				<dd><a href="index.html#MsgPipe">func MsgPipe() (*MsgPipeRW, *MsgPipeRW)</a></dd>
			
				
				<dd><a href="index.html#Send">func Send(w MsgWriter, msgcode uint64, data interface{}) error</a></dd>
			
				
				<dd><a href="index.html#SendItems">func SendItems(w MsgWriter, msgcode uint64, elems ...interface{}) error</a></dd>
			
			
				
				<dd><a href="index.html#Cap">type Cap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Cap.String">func (cap Cap) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Config">type Config</a></dd>
				
				
			
				
				<dd><a href="index.html#DiscReason">type DiscReason</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DiscReason.Error">func (d DiscReason) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DiscReason.String">func (d DiscReason) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Msg">type Msg</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Msg.Decode">func (msg Msg) Decode(val interface{}) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Msg.Discard">func (msg Msg) Discard() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Msg.String">func (msg Msg) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Msg.Time">func (msg Msg) Time() time.Time</a></dd>
				
			
				
				<dd><a href="index.html#MsgPipeRW">type MsgPipeRW</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MsgPipeRW.Close">func (p *MsgPipeRW) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MsgPipeRW.ReadMsg">func (p *MsgPipeRW) ReadMsg() (Msg, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MsgPipeRW.WriteMsg">func (p *MsgPipeRW) WriteMsg(msg Msg) error</a></dd>
				
			
				
				<dd><a href="index.html#MsgReadWriter">type MsgReadWriter</a></dd>
				
				
			
				
				<dd><a href="index.html#MsgReader">type MsgReader</a></dd>
				
				
			
				
				<dd><a href="index.html#MsgWriter">type MsgWriter</a></dd>
				
				
			
				
				<dd><a href="index.html#NodeDialer">type NodeDialer</a></dd>
				
				
			
				
				<dd><a href="index.html#NodeInfo">type NodeInfo</a></dd>
				
				
			
				
				<dd><a href="index.html#Peer">type Peer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPeer">func NewPeer(id enode.ID, name string, caps []Cap) *Peer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPeerPipe">func NewPeerPipe(id enode.ID, name string, caps []Cap, pipe *MsgPipeRW) *Peer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Caps">func (p *Peer) Caps() []Cap</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Disconnect">func (p *Peer) Disconnect(reason DiscReason)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Fullname">func (p *Peer) Fullname() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.ID">func (p *Peer) ID() enode.ID</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Inbound">func (p *Peer) Inbound() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Info">func (p *Peer) Info() *PeerInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.LocalAddr">func (p *Peer) LocalAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Log">func (p *Peer) Log() log.Logger</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Name">func (p *Peer) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.Node">func (p *Peer) Node() *enode.Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.RemoteAddr">func (p *Peer) RemoteAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.RunningCap">func (p *Peer) RunningCap(protocol string, versions []uint) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Peer.String">func (p *Peer) String() string</a></dd>
				
			
				
				<dd><a href="index.html#PeerEvent">type PeerEvent</a></dd>
				
				
			
				
				<dd><a href="index.html#PeerEventType">type PeerEventType</a></dd>
				
				
			
				
				<dd><a href="index.html#PeerInfo">type PeerInfo</a></dd>
				
				
			
				
				<dd><a href="index.html#Protocol">type Protocol</a></dd>
				
				
			
				
				<dd><a href="index.html#Server">type Server</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.AddPeer">func (srv *Server) AddPeer(node *enode.Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.AddTrustedPeer">func (srv *Server) AddTrustedPeer(node *enode.Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.LocalNode">func (srv *Server) LocalNode() *enode.LocalNode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.NodeInfo">func (srv *Server) NodeInfo() *NodeInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.PeerCount">func (srv *Server) PeerCount() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.Peers">func (srv *Server) Peers() []*Peer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.PeersInfo">func (srv *Server) PeersInfo() []*PeerInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.RemovePeer">func (srv *Server) RemovePeer(node *enode.Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.RemoveTrustedPeer">func (srv *Server) RemoveTrustedPeer(node *enode.Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.Self">func (srv *Server) Self() *enode.Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.SetupConn">func (srv *Server) SetupConn(fd net.Conn, flags connFlag, dialDest *enode.Node) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.Start">func (srv *Server) Start() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.Stop">func (srv *Server) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server.SubscribeEvents">func (srv *Server) SubscribeEvents(ch chan *PeerEvent) event.Subscription</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_MsgPipe">MsgPipe</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/dial.go">dial.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go">message.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/metrics.go">metrics.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go">peer.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer_error.go">peer_error.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/protocol.go">protocol.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go">server.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/transport.go">transport.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/util.go">util.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (

    <span class="comment">// HandleHistName is the prefix of the per-packet serving time histograms.</span>
    <span id="HandleHistName">HandleHistName</span> = &#34;p2p/handle&#34;
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>ErrPipeClosed is returned from pipe operations after the
pipe has been closed.

				<pre>var <span id="ErrPipeClosed">ErrPipeClosed</span> = <a href="../../../../errors/index.html">errors</a>.<a href="../../../../errors/index.html#New">New</a>(&#34;p2p: read or write on closed message pipe&#34;)</pre>
			
				
				<pre>var (
    <span id="ErrShuttingDown">ErrShuttingDown</span> = <a href="../../../../errors/index.html">errors</a>.<a href="../../../../errors/index.html#New">New</a>(&#34;shutting down&#34;)
)</pre>
			
		
		
			
			
			<h2 id="ExpectMsg">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=6523:6590#L219">ExpectMsg</a>
				<a class="permalink" href="index.html#ExpectMsg">&#xb6;</a>
				
				
			</h2>
			<pre>func ExpectMsg(r <a href="index.html#MsgReader">MsgReader</a>, code <a href="../../../../builtin/index.html#uint64">uint64</a>, content interface{}) <a href="../../../../builtin/index.html#error">error</a></pre>
			<p>ExpectMsg reads a message from r and verifies that its
code and encoded RLP content match the provided values.
If content is nil, the payload is discarded and not verified.

			
			

		
			
			
			<h2 id="MsgPipe">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=4595:4634#L146">MsgPipe</a>
				<a class="permalink" href="index.html#MsgPipe">&#xb6;</a>
				
				
			</h2>
			<pre>func MsgPipe() (*<a href="index.html#MsgPipeRW">MsgPipeRW</a>, *<a href="index.html#MsgPipeRW">MsgPipeRW</a>)</pre>
			<p>MsgPipe creates a message pipe. Reads on one end are matched
with writes on the other. The pipe is full-duplex, both ends
implement MsgReadWriter.

			<div id="example_MsgPipe" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">rw1, rw2 := MsgPipe()
go func() {
    Send(rw1, 8, [][]byte{{0, 0}})
    Send(rw1, 5, [][]byte{{1, 1}})
    rw1.Close()
}()

for {
    msg, err := rw2.ReadMsg()
    if err != nil {
        break
    }
    var data [][]byte
    msg.Decode(&amp;data)
    fmt.Printf(&#34;msg: %d, %x\n&#34;, msg.Code, data[0])
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">msg: 8, 0000
msg: 5, 0101
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Send">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=3058:3120#L89">Send</a>
				<a class="permalink" href="index.html#Send">&#xb6;</a>
				
				
			</h2>
			<pre>func Send(w <a href="index.html#MsgWriter">MsgWriter</a>, msgcode <a href="../../../../builtin/index.html#uint64">uint64</a>, data interface{}) <a href="../../../../builtin/index.html#error">error</a></pre>
			<p>Send writes an RLP-encoded message with the given code.
data should encode as an RLP list.

			
			

		
			
			
			<h2 id="SendItems">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=3494:3565#L106">SendItems</a>
				<a class="permalink" href="index.html#SendItems">&#xb6;</a>
				
				
			</h2>
			<pre>func SendItems(w <a href="index.html#MsgWriter">MsgWriter</a>, msgcode <a href="../../../../builtin/index.html#uint64">uint64</a>, elems ...interface{}) <a href="../../../../builtin/index.html#error">error</a></pre>
			<p>SendItems writes an RLP with the given code and data elements.
For a call such as:
<pre>SendItems(w, code, e1, e2, e3)
</pre>
<p>the message payload will be an RLP list containing the items:
<pre>[e1, e2, e3]
</pre>

			
			

		
		
			
			
			<h2 id="Cap">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/protocol.go?s=2533:2582#L61">Cap</a>
				<a class="permalink" href="index.html#Cap">&#xb6;</a>
				
				
			</h2>
			<p>Cap is the structure of a peer capability.

			<pre>type Cap struct {
<span id="Cap.Name"></span>    Name    <a href="../../../../builtin/index.html#string">string</a>
<span id="Cap.Version"></span>    Version <a href="../../../../builtin/index.html#uint">uint</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Cap.String">func (Cap) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/protocol.go?s=2584:2614#L66">String</a>
					<a class="permalink" href="index.html#Cap.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (cap <a href="index.html#Cap">Cap</a>) String() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Config">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=2239:5645#L60">Config</a>
				<a class="permalink" href="index.html#Config">&#xb6;</a>
				
				
			</h2>
			<p>Config holds Server options.

			<pre>type Config struct {
    <span class="comment">// This field must be set to a valid secp256k1 private key.</span>
<span id="Config.PrivateKey"></span>    PrivateKey *<a href="../../../../crypto/ecdsa/index.html">ecdsa</a>.<a href="../../../../crypto/ecdsa/index.html#PrivateKey">PrivateKey</a> `toml:&#34;-&#34;`

<span id="Config.MaxPeers"></span>    <span class="comment">// MaxPeers is the maximum number of peers that can be</span>
    <span class="comment">// connected. It must be greater than zero.</span>
    MaxPeers <a href="../../../../builtin/index.html#int">int</a>

<span id="Config.MaxPendingPeers"></span>    <span class="comment">// MaxPendingPeers is the maximum number of peers that can be pending in the</span>
    <span class="comment">// handshake phase, counted separately for inbound and outbound connections.</span>
    <span class="comment">// Zero defaults to preset values.</span>
    MaxPendingPeers <a href="../../../../builtin/index.html#int">int</a> `toml:&#34;,omitempty&#34;`

<span id="Config.DialRatio"></span>    <span class="comment">// DialRatio controls the ratio of inbound to dialed connections.</span>
    <span class="comment">// Example: a DialRatio of 2 allows 1/2 of connections to be dialed.</span>
    <span class="comment">// Setting DialRatio to zero defaults it to 3.</span>
    DialRatio <a href="../../../../builtin/index.html#int">int</a> `toml:&#34;,omitempty&#34;`

<span id="Config.NoDiscovery"></span>    <span class="comment">// NoDiscovery can be used to disable the peer discovery mechanism.</span>
    <span class="comment">// Disabling is useful for protocol debugging (manual topology).</span>
    NoDiscovery <a href="../../../../builtin/index.html#bool">bool</a>

<span id="Config.DiscoveryV5"></span>    <span class="comment">// DiscoveryV5 specifies whether the new topic-discovery based V5 discovery</span>
    <span class="comment">// protocol should be started or not.</span>
    DiscoveryV5 <a href="../../../../builtin/index.html#bool">bool</a> `toml:&#34;,omitempty&#34;`

<span id="Config.Name"></span>    <span class="comment">// Name sets the node name of this server.</span>
    <span class="comment">// Use common.MakeName to create a name that follows existing conventions.</span>
    Name <a href="../../../../builtin/index.html#string">string</a> `toml:&#34;-&#34;`

<span id="Config.BootstrapNodes"></span>    <span class="comment">// BootstrapNodes are used to establish connectivity</span>
    <span class="comment">// with the rest of the network.</span>
    BootstrapNodes []*<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>

<span id="Config.BootstrapNodesV5"></span>    <span class="comment">// BootstrapNodesV5 are used to establish connectivity</span>
    <span class="comment">// with the rest of the network using the V5 discovery</span>
    <span class="comment">// protocol.</span>
    BootstrapNodesV5 []*<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a> `toml:&#34;,omitempty&#34;`

    <span class="comment">// Static nodes are used as pre-configured connections which are always</span>
    <span class="comment">// maintained and re-connected on disconnects.</span>
<span id="Config.StaticNodes"></span>    StaticNodes []*<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>

    <span class="comment">// Trusted nodes are used as pre-configured connections which are always</span>
    <span class="comment">// allowed to connect, even above the peer limit.</span>
<span id="Config.TrustedNodes"></span>    TrustedNodes []*<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>

    <span class="comment">// Connectivity can be restricted to certain IP networks.</span>
    <span class="comment">// If this option is set to a non-nil value, only hosts which match one of the</span>
    <span class="comment">// IP networks contained in the list are considered.</span>
<span id="Config.NetRestrict"></span>    NetRestrict *<a href="netutil/index.html">netutil</a>.<a href="netutil/index.html#Netlist">Netlist</a> `toml:&#34;,omitempty&#34;`

<span id="Config.NodeDatabase"></span>    <span class="comment">// NodeDatabase is the path to the database containing the previously seen</span>
    <span class="comment">// live nodes in the network.</span>
    NodeDatabase <a href="../../../../builtin/index.html#string">string</a> `toml:&#34;,omitempty&#34;`

<span id="Config.Protocols"></span>    <span class="comment">// Protocols should contain the protocols supported</span>
    <span class="comment">// by the server. Matching protocols are launched for</span>
    <span class="comment">// each peer.</span>
    Protocols []<a href="index.html#Protocol">Protocol</a> `toml:&#34;-&#34; json:&#34;-&#34;`

    <span class="comment">// If ListenAddr is set to a non-nil address, the server</span>
    <span class="comment">// will listen for incoming connections.</span>
    <span class="comment">//</span>
    <span class="comment">// If the port is zero, the operating system will pick a port. The</span>
<span id="Config.ListenAddr"></span>    <span class="comment">// ListenAddr field will be updated with the actual address when</span>
    <span class="comment">// the server is started.</span>
    ListenAddr <a href="../../../../builtin/index.html#string">string</a>

    <span class="comment">// If DiscAddr is set to a non-nil value, the server will use ListenAddr</span>
    <span class="comment">// for TCP and DiscAddr for the UDP discovery protocol.</span>
<span id="Config.DiscAddr"></span>    DiscAddr <a href="../../../../builtin/index.html#string">string</a>

    <span class="comment">// If set to a non-nil value, the given NAT port mapper</span>
    <span class="comment">// is used to make the listening port available to the</span>
    <span class="comment">// Internet.</span>
<span id="Config.NAT"></span>    NAT <a href="nat/index.html">nat</a>.<a href="nat/index.html#Interface">Interface</a> `toml:&#34;,omitempty&#34;`

    <span class="comment">// If Dialer is set to a non-nil value, the given Dialer</span>
    <span class="comment">// is used to dial outbound peer connections.</span>
<span id="Config.Dialer"></span>    Dialer <a href="index.html#NodeDialer">NodeDialer</a> `toml:&#34;-&#34;`

    <span class="comment">// If NoDial is true, the server will not dial any peers.</span>
<span id="Config.NoDial"></span>    NoDial <a href="../../../../builtin/index.html#bool">bool</a> `toml:&#34;,omitempty&#34;`

    <span class="comment">// If EnableMsgEvents is set then the server will emit PeerEvents</span>
    <span class="comment">// whenever a message is sent to or received from a peer</span>
<span id="Config.EnableMsgEvents"></span>    EnableMsgEvents <a href="../../../../builtin/index.html#bool">bool</a>

<span id="Config.Logger"></span>    <span class="comment">// Logger is a custom logger to use with the p2p.Server.</span>
    Logger <a href="../log/index.html">log</a>.<a href="../log/index.html#Logger">Logger</a> `toml:&#34;,omitempty&#34;`
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="DiscReason">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer_error.go?s=1452:1473#L47">DiscReason</a>
				<a class="permalink" href="index.html#DiscReason">&#xb6;</a>
				
				
			</h2>
			
			<pre>type DiscReason <a href="../../../../builtin/index.html#uint8">uint8</a></pre>

			
				
				<pre>const (
    <span id="DiscRequested">DiscRequested</span> <a href="index.html#DiscReason">DiscReason</a> = <a href="../../../../builtin/index.html#iota">iota</a>
    <span id="DiscNetworkError">DiscNetworkError</span>
    <span id="DiscProtocolError">DiscProtocolError</span>
    <span id="DiscUselessPeer">DiscUselessPeer</span>
    <span id="DiscTooManyPeers">DiscTooManyPeers</span>
    <span id="DiscAlreadyConnected">DiscAlreadyConnected</span>
    <span id="DiscIncompatibleVersion">DiscIncompatibleVersion</span>
    <span id="DiscInvalidIdentity">DiscInvalidIdentity</span>
    <span id="DiscQuitting">DiscQuitting</span>
    <span id="DiscUnexpectedIdentity">DiscUnexpectedIdentity</span>
    <span id="DiscSelf">DiscSelf</span>
    <span id="DiscReadTimeout">DiscReadTimeout</span>
    <span id="DiscSubprotocolError">DiscSubprotocolError</span> = <a href="index.html#DiscReason">DiscReason</a>(0x10)
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="DiscReason.Error">func (DiscReason) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer_error.go?s=2594:2628#L88">Error</a>
					<a class="permalink" href="index.html#DiscReason.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (d <a href="index.html#DiscReason">DiscReason</a>) Error() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="DiscReason.String">func (DiscReason) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer_error.go?s=2424:2459#L81">String</a>
					<a class="permalink" href="index.html#DiscReason.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (d <a href="index.html#DiscReason">DiscReason</a>) String() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Msg">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=1375:1702#L29">Msg</a>
				<a class="permalink" href="index.html#Msg">&#xb6;</a>
				
				
			</h2>
			<p>Msg defines the structure of a p2p message.
<p>Note that a Msg can only be sent once since the Payload reader is
consumed during sending. It is not possible to create a Msg and
send it any number of times. If you want to reuse an encoded
structure, encode the payload into a byte array and create a
separate Msg with a bytes.Reader as Payload for each send.

			<pre>type Msg struct {
<span id="Msg.Code"></span>    Code       <a href="../../../../builtin/index.html#uint64">uint64</a>
<span id="Msg.Size"></span>    Size       <a href="../../../../builtin/index.html#uint32">uint32</a> <span class="comment">// Size of the raw payload</span>
<span id="Msg.Payload"></span>    Payload    <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Reader">Reader</a>
<span id="Msg.ReceivedAt"></span>    ReceivedAt <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Time">Time</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Msg.Decode">func (Msg) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=1854:1898#L44">Decode</a>
					<a class="permalink" href="index.html#Msg.Decode">&#xb6;</a>
					
					
				</h3>
				<pre>func (msg <a href="index.html#Msg">Msg</a>) Decode(val interface{}) <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>Decode parses the RLP content of a message into
the given value, which must be a pointer.
<p>For the decoding rules, please see package rlp.

				
				
				
			
				
				<h3 id="Msg.Discard">func (Msg) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2258:2288#L57">Discard</a>
					<a class="permalink" href="index.html#Msg.Discard">&#xb6;</a>
					
					
				</h3>
				<pre>func (msg <a href="index.html#Msg">Msg</a>) Discard() <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>Discard reads any remaining payload data into a black hole.

				
				
				
			
				
				<h3 id="Msg.String">func (Msg) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2097:2127#L52">String</a>
					<a class="permalink" href="index.html#Msg.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (msg <a href="index.html#Msg">Msg</a>) String() <a href="../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Msg.Time">func (Msg) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2350:2381#L62">Time</a>
					<a class="permalink" href="index.html#Msg.Time">&#xb6;</a>
					
					
				</h3>
				<pre>func (msg <a href="index.html#Msg">Msg</a>) Time() <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Time">Time</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MsgPipeRW">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=5076:5180#L162">MsgPipeRW</a>
				<a class="permalink" href="index.html#MsgPipeRW">&#xb6;</a>
				
				
			</h2>
			<p>MsgPipeRW is an endpoint of a MsgReadWriter pipe.

			<pre>type MsgPipeRW struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MsgPipeRW.Close">func (*MsgPipeRW) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=6128:6161#L206">Close</a>
					<a class="permalink" href="index.html#MsgPipeRW.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#MsgPipeRW">MsgPipeRW</a>) Close() <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>Close unblocks any pending ReadMsg and WriteMsg calls on both ends
of the pipe. They will return ErrPipeClosed. Close also
interrupts any reads from a message payload.

				
				
				
			
				
				<h3 id="MsgPipeRW.ReadMsg">func (*MsgPipeRW) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=5758:5800#L192">ReadMsg</a>
					<a class="permalink" href="index.html#MsgPipeRW.ReadMsg">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#MsgPipeRW">MsgPipeRW</a>) ReadMsg() (<a href="index.html#Msg">Msg</a>, <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>ReadMsg returns a message sent on the other end of the pipe.

				
				
				
			
				
				<h3 id="MsgPipeRW.WriteMsg">func (*MsgPipeRW) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=5289:5332#L171">WriteMsg</a>
					<a class="permalink" href="index.html#MsgPipeRW.WriteMsg">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#MsgPipeRW">MsgPipeRW</a>) WriteMsg(msg <a href="index.html#Msg">Msg</a>) <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>WriteMsg sends a message on the pipe.
It blocks until the receiver has consumed the message payload.

				
				
				
			
		
			
			
			<h2 id="MsgReadWriter">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2905:2959#L82">MsgReadWriter</a>
				<a class="permalink" href="index.html#MsgReadWriter">&#xb6;</a>
				
				
			</h2>
			<p>MsgReadWriter provides reading and writing of encoded messages.
Implementations should ensure that ReadMsg and WriteMsg can be
called simultaneously from multiple goroutines.

			<pre>type MsgReadWriter interface {
    <a href="index.html#MsgReader">MsgReader</a>
    <a href="index.html#MsgWriter">MsgWriter</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="MsgReader">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2410:2462#L66">MsgReader</a>
				<a class="permalink" href="index.html#MsgReader">&#xb6;</a>
				
				
			</h2>
			
			<pre>type MsgReader interface {
    ReadMsg() (<a href="index.html#Msg">Msg</a>, <a href="../../../../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="MsgWriter">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/message.go?s=2464:2719#L70">MsgWriter</a>
				<a class="permalink" href="index.html#MsgWriter">&#xb6;</a>
				
				
			</h2>
			
			<pre>type MsgWriter interface {
    <span class="comment">// WriteMsg sends a message. It will block until the message&#39;s</span>
    <span class="comment">// Payload has been consumed by the other end.</span>
    <span class="comment">//</span>
    <span class="comment">// Note that messages can be sent only once because their</span>
    <span class="comment">// payload reader is drained.</span>
    WriteMsg(<a href="index.html#Msg">Msg</a>) <a href="../../../../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NodeDialer">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/dial.go?s=1854:1937#L43">NodeDialer</a>
				<a class="permalink" href="index.html#NodeDialer">&#xb6;</a>
				
				
			</h2>
			<p>NodeDialer is used to connect to nodes in the network, typically by using
an underlying net.Dialer but also using net.Pipe in tests.

			<pre>type NodeDialer interface {
    Dial(<a href="../../../../context/index.html">context</a>.<a href="../../../../context/index.html#Context">Context</a>, *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>) (<a href="../../../../net/index.html">net</a>.<a href="../../../../net/index.html#Conn">Conn</a>, <a href="../../../../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NodeInfo">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=29877:30558#L1061">NodeInfo</a>
				<a class="permalink" href="index.html#NodeInfo">&#xb6;</a>
				
				
			</h2>
			<p>NodeInfo represents a short summary of the information known about the host.

			<pre>type NodeInfo struct {
<span id="NodeInfo.ID"></span>    ID    <a href="../../../../builtin/index.html#string">string</a> `json:&#34;id&#34;`    <span class="comment">// Unique node identifier (also the encryption key)</span>
<span id="NodeInfo.Name"></span>    Name  <a href="../../../../builtin/index.html#string">string</a> `json:&#34;name&#34;`  <span class="comment">// Name of the node, including client type, version, OS, custom data</span>
<span id="NodeInfo.Enode"></span>    Enode <a href="../../../../builtin/index.html#string">string</a> `json:&#34;enode&#34;` <span class="comment">// Enode URL for adding this peer from remote peers</span>
<span id="NodeInfo.ENR"></span>    ENR   <a href="../../../../builtin/index.html#string">string</a> `json:&#34;enr&#34;`   <span class="comment">// Ethereum Node Record</span>
<span id="NodeInfo.IP"></span>    IP    <a href="../../../../builtin/index.html#string">string</a> `json:&#34;ip&#34;`    <span class="comment">// IP address of the node</span>
<span id="NodeInfo.Ports"></span>    Ports struct {
        Discovery <a href="../../../../builtin/index.html#int">int</a> `json:&#34;discovery&#34;` <span class="comment">// UDP listening port for discovery protocol</span>
        Listener  <a href="../../../../builtin/index.html#int">int</a> `json:&#34;listener&#34;`  <span class="comment">// TCP listening port for RLPx</span>
    } `json:&#34;ports&#34;`
<span id="NodeInfo.ListenAddr"></span>    ListenAddr <a href="../../../../builtin/index.html#string">string</a>                 `json:&#34;listenAddr&#34;`
<span id="NodeInfo.Protocols"></span>    Protocols  map[<a href="../../../../builtin/index.html#string">string</a>]interface{} `json:&#34;protocols&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Peer">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=3148:3469#L96">Peer</a>
				<a class="permalink" href="index.html#Peer">&#xb6;</a>
				
				
			</h2>
			<p>Peer represents a connected remote node.

			<pre>type Peer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewPeer">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=3519:3575#L113">NewPeer</a>
					<a class="permalink" href="index.html#NewPeer">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPeer(id <a href="enode/index.html">enode</a>.<a href="enode/index.html#ID">ID</a>, name <a href="../../../../builtin/index.html#string">string</a>, caps []<a href="index.html#Cap">Cap</a>) *<a href="index.html#Peer">Peer</a></pre>
				<p>NewPeer returns a peer for testing purposes.

				
				
			
				
				<h3 id="NewPeerPipe">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=4313:4390#L133">NewPeerPipe</a>
					<a class="permalink" href="index.html#NewPeerPipe">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPeerPipe(id <a href="enode/index.html">enode</a>.<a href="enode/index.html#ID">ID</a>, name <a href="../../../../builtin/index.html#string">string</a>, caps []<a href="index.html#Cap">Cap</a>, pipe *<a href="index.html#MsgPipeRW">MsgPipeRW</a>) *<a href="index.html#Peer">Peer</a></pre>
				<p>NewPeerPipe creates a peer for testing purposes.
The message pipe given as the last parameter is closed when
Disconnect is called on the peer.

				
				
			

			
				
				<h3 id="Peer.Caps">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=5004:5031#L164">Caps</a>
					<a class="permalink" href="index.html#Peer.Caps">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Caps() []<a href="index.html#Cap">Cap</a></pre>
				<p>Caps returns the capabilities (supported subprotocols) of the remote peer.

				
				
				
			
				
				<h3 id="Peer.Disconnect">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=5935:5979#L195">Disconnect</a>
					<a class="permalink" href="index.html#Peer.Disconnect">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Disconnect(reason <a href="index.html#DiscReason">DiscReason</a>)</pre>
				<p>Disconnect terminates the peer connection with the given reason.
It returns immediately and does not wait until the connection is closed.

				
				
				
			
				
				<h3 id="Peer.Fullname">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=4870:4902#L159">Fullname</a>
					<a class="permalink" href="index.html#Peer.Fullname">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Fullname() <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>Fullname returns the node name that the remote node advertised.

				
				
				
			
				
				<h3 id="Peer.ID">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=4492:4520#L140">ID</a>
					<a class="permalink" href="index.html#Peer.ID">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) ID() <a href="enode/index.html">enode</a>.<a href="enode/index.html#ID">ID</a></pre>
				<p>ID returns the node&apos;s public key.

				
				
				
			
				
				<h3 id="Peer.Inbound">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=6293:6322#L213">Inbound</a>
					<a class="permalink" href="index.html#Peer.Inbound">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Inbound() <a href="../../../../builtin/index.html#bool">bool</a></pre>
				<p>Inbound returns true if the peer is an inbound connection

				
				
				
			
				
				<h3 id="Peer.Info">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=13721:13752#L491">Info</a>
					<a class="permalink" href="index.html#Peer.Info">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Info() *<a href="index.html#PeerInfo">PeerInfo</a></pre>
				<p>Info gathers and returns a collection of metadata known about a peer.

				
				
				
			
				
				<h3 id="Peer.LocalAddr">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=5722:5757#L189">LocalAddr</a>
					<a class="permalink" href="index.html#Peer.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) LocalAddr() <a href="../../../../net/index.html">net</a>.<a href="../../../../net/index.html#Addr">Addr</a></pre>
				<p>LocalAddr returns the local address of the network connection.

				
				
				
			
				
				<h3 id="Peer.Log">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=6781:6812#L231">Log</a>
					<a class="permalink" href="index.html#Peer.Log">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Log() <a href="../log/index.html">log</a>.<a href="../log/index.html#Logger">Logger</a></pre>
				
				
				
				
			
				
				<h3 id="Peer.Name">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=4698:4726#L150">Name</a>
					<a class="permalink" href="index.html#Peer.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Name() <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>Name returns an abbreviated form of the name

				
				
				
			
				
				<h3 id="Peer.Node">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=4593:4626#L145">Node</a>
					<a class="permalink" href="index.html#Peer.Node">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) Node() *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a></pre>
				<p>Node returns the peer&apos;s node descriptor.

				
				
				
			
				
				<h3 id="Peer.RemoteAddr">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=5585:5621#L184">RemoteAddr</a>
					<a class="permalink" href="index.html#Peer.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) RemoteAddr() <a href="../../../../net/index.html">net</a>.<a href="../../../../net/index.html#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote address of the network connection.

				
				
				
			
				
				<h3 id="Peer.RunningCap">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=5300:5364#L172">RunningCap</a>
					<a class="permalink" href="index.html#Peer.RunningCap">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) RunningCap(protocol <a href="../../../../builtin/index.html#string">string</a>, versions []<a href="../../../../builtin/index.html#uint">uint</a>) <a href="../../../../builtin/index.html#bool">bool</a></pre>
				<p>RunningCap returns true if the peer is actively connected using any of the
enumerated versions of a specific protocol, meaning that at least one of the
versions is supported by both this node and the peer p.

				
				
				
			
				
				<h3 id="Peer.String">func (*Peer) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=6124:6154#L207">String</a>
					<a class="permalink" href="index.html#Peer.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Peer">Peer</a>) String() <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>String implements fmt.Stringer.

				
				
				
			
		
			
			
			<h2 id="PeerEvent">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=2657:3102#L84">PeerEvent</a>
				<a class="permalink" href="index.html#PeerEvent">&#xb6;</a>
				
				
			</h2>
			<p>PeerEvent is an event emitted when peers are either added or dropped from
a p2p.Server or when a message is sent or received on a peer connection

			<pre>type PeerEvent struct {
<span id="PeerEvent.Type"></span>    Type          <a href="index.html#PeerEventType">PeerEventType</a> `json:&#34;type&#34;`
<span id="PeerEvent.Peer"></span>    Peer          <a href="enode/index.html">enode</a>.<a href="enode/index.html#ID">ID</a>      `json:&#34;peer&#34;`
<span id="PeerEvent.Error"></span>    Error         <a href="../../../../builtin/index.html#string">string</a>        `json:&#34;error,omitempty&#34;`
<span id="PeerEvent.Protocol"></span>    Protocol      <a href="../../../../builtin/index.html#string">string</a>        `json:&#34;protocol,omitempty&#34;`
<span id="PeerEvent.MsgCode"></span>    MsgCode       *<a href="../../../../builtin/index.html#uint64">uint64</a>       `json:&#34;msg_code,omitempty&#34;`
<span id="PeerEvent.MsgSize"></span>    MsgSize       *<a href="../../../../builtin/index.html#uint32">uint32</a>       `json:&#34;msg_size,omitempty&#34;`
<span id="PeerEvent.LocalAddress"></span>    LocalAddress  <a href="../../../../builtin/index.html#string">string</a>        `json:&#34;local,omitempty&#34;`
<span id="PeerEvent.RemoteAddress"></span>    RemoteAddress <a href="../../../../builtin/index.html#string">string</a>        `json:&#34;remote,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PeerEventType">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=1898:1923#L62">PeerEventType</a>
				<a class="permalink" href="index.html#PeerEventType">&#xb6;</a>
				
				
			</h2>
			<p>PeerEventType is the type of peer events emitted by a p2p.Server

			<pre>type PeerEventType <a href="../../../../builtin/index.html#string">string</a></pre>

			
				
				<pre>const (
    <span class="comment">// PeerEventTypeAdd is the type of event emitted when a peer is added</span>
    <span class="comment">// to a p2p.Server</span>
    <span id="PeerEventTypeAdd">PeerEventTypeAdd</span> <a href="index.html#PeerEventType">PeerEventType</a> = &#34;add&#34;

    <span class="comment">// PeerEventTypeDrop is the type of event emitted when a peer is</span>
    <span class="comment">// dropped from a p2p.Server</span>
    <span id="PeerEventTypeDrop">PeerEventTypeDrop</span> <a href="index.html#PeerEventType">PeerEventType</a> = &#34;drop&#34;

    <span class="comment">// PeerEventTypeMsgSend is the type of event emitted when a</span>
    <span class="comment">// message is successfully sent to a peer</span>
    <span id="PeerEventTypeMsgSend">PeerEventTypeMsgSend</span> <a href="index.html#PeerEventType">PeerEventType</a> = &#34;msgsend&#34;

    <span class="comment">// PeerEventTypeMsgRecv is the type of event emitted when a</span>
    <span class="comment">// message is received from a peer</span>
    <span id="PeerEventTypeMsgRecv">PeerEventTypeMsgRecv</span> <a href="index.html#PeerEventType">PeerEventType</a> = &#34;msgrecv&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="PeerInfo">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/peer.go?s=12815:13646#L474">PeerInfo</a>
				<a class="permalink" href="index.html#PeerInfo">&#xb6;</a>
				
				
			</h2>
			<p>PeerInfo represents a short summary of the information known about a connected
peer. Sub-protocol independent fields are contained and initialized here, with
protocol specifics delegated to all connected sub-protocols.

			<pre>type PeerInfo struct {
<span id="PeerInfo.ENR"></span>    ENR     <a href="../../../../builtin/index.html#string">string</a>   `json:&#34;enr,omitempty&#34;` <span class="comment">// Ethereum Node Record</span>
<span id="PeerInfo.Enode"></span>    Enode   <a href="../../../../builtin/index.html#string">string</a>   `json:&#34;enode&#34;`         <span class="comment">// Node URL</span>
<span id="PeerInfo.ID"></span>    ID      <a href="../../../../builtin/index.html#string">string</a>   `json:&#34;id&#34;`            <span class="comment">// Unique node identifier</span>
<span id="PeerInfo.Name"></span>    Name    <a href="../../../../builtin/index.html#string">string</a>   `json:&#34;name&#34;`          <span class="comment">// Name of the node, including client type, version, OS, custom data</span>
<span id="PeerInfo.Caps"></span>    Caps    []<a href="../../../../builtin/index.html#string">string</a> `json:&#34;caps&#34;`          <span class="comment">// Protocols advertised by this peer</span>
<span id="PeerInfo.Network"></span>    Network struct {
        LocalAddress  <a href="../../../../builtin/index.html#string">string</a> `json:&#34;localAddress&#34;`  <span class="comment">// Local endpoint of the TCP data connection</span>
        RemoteAddress <a href="../../../../builtin/index.html#string">string</a> `json:&#34;remoteAddress&#34;` <span class="comment">// Remote endpoint of the TCP data connection</span>
        Inbound       <a href="../../../../builtin/index.html#bool">bool</a>   `json:&#34;inbound&#34;`
        Trusted       <a href="../../../../builtin/index.html#bool">bool</a>   `json:&#34;trusted&#34;`
        Static        <a href="../../../../builtin/index.html#bool">bool</a>   `json:&#34;static&#34;`
    } `json:&#34;network&#34;`
<span id="PeerInfo.Protocols"></span>    Protocols map[<a href="../../../../builtin/index.html#string">string</a>]interface{} `json:&#34;protocols&#34;` <span class="comment">// Sub-protocol specific metadata fields</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Protocol">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/protocol.go?s=971:2421#L17">Protocol</a>
				<a class="permalink" href="index.html#Protocol">&#xb6;</a>
				
				
			</h2>
			<p>Protocol represents a P2P subprotocol implementation.

			<pre>type Protocol struct {
<span id="Protocol.Name"></span>    <span class="comment">// Name should contain the official protocol name,</span>
    <span class="comment">// often a three-letter word.</span>
    Name <a href="../../../../builtin/index.html#string">string</a>

<span id="Protocol.Version"></span>    <span class="comment">// Version should contain the version number of the protocol.</span>
    Version <a href="../../../../builtin/index.html#uint">uint</a>

<span id="Protocol.Length"></span>    <span class="comment">// Length should contain the number of message codes used</span>
    <span class="comment">// by the protocol.</span>
    Length <a href="../../../../builtin/index.html#uint64">uint64</a>

<span id="Protocol.Run"></span>    <span class="comment">// Run is called in a new goroutine when the protocol has been</span>
    <span class="comment">// negotiated with a peer. It should read and write messages from</span>
    <span class="comment">// rw. The Payload for each message must be fully consumed.</span>
    <span class="comment">//</span>
    <span class="comment">// The peer connection is closed when Start returns. It should return</span>
    <span class="comment">// any protocol-level error (such as an I/O error) that is</span>
    <span class="comment">// encountered.</span>
    Run func(peer *<a href="index.html#Peer">Peer</a>, rw <a href="index.html#MsgReadWriter">MsgReadWriter</a>) <a href="../../../../builtin/index.html#error">error</a>

<span id="Protocol.NodeInfo"></span>    <span class="comment">// NodeInfo is an optional helper method to retrieve protocol specific metadata</span>
    <span class="comment">// about the host node.</span>
    NodeInfo func() interface{}

<span id="Protocol.PeerInfo"></span>    <span class="comment">// PeerInfo is an optional helper method to retrieve protocol specific metadata</span>
    <span class="comment">// about a certain peer in the network. If an info retrieval function is set,</span>
    <span class="comment">// but returns nil, it is assumed that the protocol handshake is still running.</span>
    PeerInfo func(id <a href="enode/index.html">enode</a>.<a href="enode/index.html#ID">ID</a>) interface{}

<span id="Protocol.DialCandidates"></span>    <span class="comment">// DialCandidates, if non-nil, is a way to tell Server about protocol-specific nodes</span>
    <span class="comment">// that should be dialed. The server continuously reads nodes from the iterator and</span>
    <span class="comment">// attempts to create connections to them.</span>
    DialCandidates <a href="enode/index.html">enode</a>.<a href="enode/index.html#Iterator">Iterator</a>

<span id="Protocol.Attributes"></span>    <span class="comment">// Attributes contains protocol specific information for the node record.</span>
    Attributes []<a href="enr/index.html">enr</a>.<a href="enr/index.html#Entry">Entry</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Server">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=5687:6802#L156">Server</a>
				<a class="permalink" href="index.html#Server">&#xb6;</a>
				
				
			</h2>
			<p>Server manages all peer connections.

			<pre>type Server struct {
    <span class="comment">// Config fields may not be modified while the server is running.</span>
    <a href="index.html#Config">Config</a>

<span id="Server.DiscV5"></span>    DiscV5 *<a href="discover/index.html">discover</a>.<a href="discover/index.html#UDPv5">UDPv5</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Server.AddPeer">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=9623:9667#L316">AddPeer</a>
					<a class="permalink" href="index.html#Server.AddPeer">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) AddPeer(node *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>)</pre>
				<p>AddPeer adds the given node to the static node set. When there is room in the peer set,
the server will connect to the node. If the connection fails for any reason, the server
will attempt to reconnect the peer.

				
				
				
			
				
				<h3 id="Server.AddTrustedPeer">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=10731:10782#L352">AddTrustedPeer</a>
					<a class="permalink" href="index.html#Server.AddTrustedPeer">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) AddTrustedPeer(node *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>)</pre>
				<p>AddTrustedPeer adds the given node to a reserved trusted list which allows the
node to always connect, even if the slot are full.

				
				
				
			
				
				<h3 id="Server.LocalNode">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=8930:8977#L289">LocalNode</a>
					<a class="permalink" href="index.html#Server.LocalNode">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) LocalNode() *<a href="enode/index.html">enode</a>.<a href="enode/index.html#LocalNode">LocalNode</a></pre>
				<p>LocalNode returns the local node record.

				
				
				
			
				
				<h3 id="Server.NodeInfo">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=30639:30678#L1076">NodeInfo</a>
					<a class="permalink" href="index.html#Server.NodeInfo">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) NodeInfo() *<a href="index.html#NodeInfo">NodeInfo</a></pre>
				<p>NodeInfo gathers and returns a collection of metadata known about the host.

				
				
				
			
				
				<h3 id="Server.PeerCount">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=9267:9301#L305">PeerCount</a>
					<a class="permalink" href="index.html#Server.PeerCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) PeerCount() <a href="../../../../builtin/index.html#int">int</a></pre>
				<p>PeerCount returns the number of connected peers.

				
				
				
			
				
				<h3 id="Server.Peers">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=9043:9077#L294">Peers</a>
					<a class="permalink" href="index.html#Server.Peers">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) Peers() []*<a href="index.html#Peer">Peer</a></pre>
				<p>Peers returns all connected peers.

				
				
				
			
				
				<h3 id="Server.PeersInfo">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=31483:31525#L1105">PeersInfo</a>
					<a class="permalink" href="index.html#Server.PeersInfo">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) PeersInfo() []*<a href="index.html#PeerInfo">PeerInfo</a></pre>
				<p>PeersInfo returns an array of metadata objects describing connected peers.

				
				
				
			
				
				<h3 id="Server.RemovePeer">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=10015:10062#L325">RemovePeer</a>
					<a class="permalink" href="index.html#Server.RemovePeer">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) RemovePeer(node *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>)</pre>
				<p>RemovePeer removes a node from the static node set. It also disconnects from the given
node if it is currently connected as a peer.
<p>This method blocks until all protocols have exited and the peer is removed. Do not use
RemovePeer in protocol implementations, call Disconnect on the Peer instead.

				
				
				
			
				
				<h3 id="Server.RemoveTrustedPeer">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=10920:10974#L360">RemoveTrustedPeer</a>
					<a class="permalink" href="index.html#Server.RemoveTrustedPeer">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) RemoveTrustedPeer(node *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>)</pre>
				<p>RemoveTrustedPeer removes the given node from the trusted peer set.

				
				
				
			
				
				<h3 id="Server.Self">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=11276:11313#L373">Self</a>
					<a class="permalink" href="index.html#Server.Self">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) Self() *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a></pre>
				<p>Self returns the local node&apos;s endpoint information.

				
				
				
			
				
				<h3 id="Server.SetupConn">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=25866:25951#L923">SetupConn</a>
					<a class="permalink" href="index.html#Server.SetupConn">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) SetupConn(fd <a href="../../../../net/index.html">net</a>.<a href="../../../../net/index.html#Conn">Conn</a>, flags connFlag, dialDest *<a href="enode/index.html">enode</a>.<a href="enode/index.html#Node">Node</a>) <a href="../../../../builtin/index.html#error">error</a></pre>
				<p>SetupConn runs the handshakes and attempts to add the connection
as a peer. It returns when the connection has been added as a peer
or the handshakes have failed.

				
				
				
			
				
				<h3 id="Server.Start">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=12692:12730#L430">Start</a>
					<a class="permalink" href="index.html#Server.Start">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) Start() (err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>Start starts running the server.
Servers can not be re-used after stopping.

				
				
				
			
				
				<h3 id="Server.Stop">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=11615:11640#L386">Stop</a>
					<a class="permalink" href="index.html#Server.Stop">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) Stop()</pre>
				<p>Stop terminates the server and all active peer connections.
It blocks until all active connections have been closed.

				
				
				
			
				
				<h3 id="Server.SubscribeEvents">func (*Server) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/server.go?s=11107:11180#L368">SubscribeEvents</a>
					<a class="permalink" href="index.html#Server.SubscribeEvents">&#xb6;</a>
					
					
				</h3>
				<pre>func (srv *<a href="index.html#Server">Server</a>) SubscribeEvents(ch chan *<a href="index.html#PeerEvent">PeerEvent</a>) <a href="../event/index.html">event</a>.<a href="../event/index.html#Subscription">Subscription</a></pre>
				<p>SubscribeEvents subscribes the given channel to peer events

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="discover/index.html">discover</a>
					</td>
				
					<td class="pkg-synopsis">
						Package discover implements the Node Discovery Protocol.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="discover/v4wire/index.html">v4wire</a>
					</td>
				
					<td class="pkg-synopsis">
						Package v4wire implements the Discovery v4 Wire Protocol.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="discover/v5wire/index.html">v5wire</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="dnsdisc/index.html">dnsdisc</a>
					</td>
				
					<td class="pkg-synopsis">
						Package dnsdisc implements node discovery via DNS (EIP-1459).
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="enode/index.html">enode</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="enr/index.html">enr</a>
					</td>
				
					<td class="pkg-synopsis">
						Package enr implements Ethereum Node Records as defined in EIP-778.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="msgrate/index.html">msgrate</a>
					</td>
				
					<td class="pkg-synopsis">
						Package msgrate allows estimating the throughput of peers for more balanced syncs.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="nat/index.html">nat</a>
					</td>
				
					<td class="pkg-synopsis">
						Package nat provides access to common network port mapping protocols.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="netutil/index.html">netutil</a>
					</td>
				
					<td class="pkg-synopsis">
						Package netutil contains extensions to the net package.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="nodestate/index.html">nodestate</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="rlpx/index.html">rlpx</a>
					</td>
				
					<td class="pkg-synopsis">
						Package rlpx implements the RLPx transport protocol.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="simulations/index.html">simulations</a>
					</td>
				
					<td class="pkg-synopsis">
						Package simulations simulates p2p networks.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="simulations/adapters/index.html">adapters</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="simulations/examples/index.html">examples</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="simulations/pipes/index.html">pipes</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="tracker/index.html">tracker</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
