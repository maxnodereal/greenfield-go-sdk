<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>nodestate - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package nodestate
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/ethereum/go-ethereum/p2p/nodestate"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
			
				
				<dd><a href="index.html#Field">type Field</a></dd>
				
				
			
				
				<dd><a href="index.html#FieldCallback">type FieldCallback</a></dd>
				
				
			
				
				<dd><a href="index.html#Flags">type Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MergeFlags">func MergeFlags(list ...Flags) Flags</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.And">func (a Flags) And(b Flags) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.AndNot">func (a Flags) AndNot(b Flags) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.Equals">func (a Flags) Equals(b Flags) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.HasAll">func (a Flags) HasAll(b Flags) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.HasNone">func (a Flags) HasNone(b Flags) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.IsEmpty">func (a Flags) IsEmpty() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.Or">func (a Flags) Or(b Flags) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.String">func (f Flags) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Flags.Xor">func (a Flags) Xor(b Flags) Flags</a></dd>
				
			
				
				<dd><a href="index.html#NodeStateMachine">type NodeStateMachine</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewNodeStateMachine">func NewNodeStateMachine(db ethdb.KeyValueStore, dbKey []byte, clock mclock.Clock, setup *Setup) *NodeStateMachine</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.AddLogMetrics">func (ns *NodeStateMachine) AddLogMetrics(requireFlags, disableFlags Flags, name string, inMeter, outMeter metrics.Meter, gauge metrics.Gauge)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.AddTimeout">func (ns *NodeStateMachine) AddTimeout(n *enode.Node, flags Flags, timeout time.Duration) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.ForEach">func (ns *NodeStateMachine) ForEach(requireFlags, disableFlags Flags, cb func(n *enode.Node, state Flags))</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.GetField">func (ns *NodeStateMachine) GetField(n *enode.Node, field Field) interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.GetNode">func (ns *NodeStateMachine) GetNode(id enode.ID) *enode.Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.GetState">func (ns *NodeStateMachine) GetState(n *enode.Node) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.Operation">func (ns *NodeStateMachine) Operation(fn func()) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.Persist">func (ns *NodeStateMachine) Persist(n *enode.Node) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SetField">func (ns *NodeStateMachine) SetField(n *enode.Node, field Field, value interface{}) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SetFieldSub">func (ns *NodeStateMachine) SetFieldSub(n *enode.Node, field Field, value interface{}) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SetState">func (ns *NodeStateMachine) SetState(n *enode.Node, setFlags, resetFlags Flags, timeout time.Duration) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SetStateSub">func (ns *NodeStateMachine) SetStateSub(n *enode.Node, setFlags, resetFlags Flags, timeout time.Duration)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.Start">func (ns *NodeStateMachine) Start()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.Stop">func (ns *NodeStateMachine) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SubscribeField">func (ns *NodeStateMachine) SubscribeField(field Field, callback FieldCallback)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NodeStateMachine.SubscribeState">func (ns *NodeStateMachine) SubscribeState(flags Flags, callback StateCallback)</a></dd>
				
			
				
				<dd><a href="index.html#Setup">type Setup</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Setup.NewField">func (s *Setup) NewField(name string, ftype reflect.Type) Field</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Setup.NewFlag">func (s *Setup) NewFlag(name string) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Setup.NewPersistentField">func (s *Setup) NewPersistentField(name string, ftype reflect.Type, encode func(interface{}) ([]byte, error), decode func([]byte) (interface{}, error)) Field</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Setup.NewPersistentFlag">func (s *Setup) NewPersistentFlag(name string) Flags</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Setup.OfflineFlag">func (s *Setup) OfflineFlag() Flags</a></dd>
				
			
				
				<dd><a href="index.html#StateCallback">type StateCallback</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go">nodestate.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span id="ErrInvalidField">ErrInvalidField</span> = <a href="../../../../../errors/index.html">errors</a>.<a href="../../../../../errors/index.html#New">New</a>(&#34;invalid field type&#34;)
    <span id="ErrClosed">ErrClosed</span>       = <a href="../../../../../errors/index.html">errors</a>.<a href="../../../../../errors/index.html#New">New</a>(&#34;already closed&#34;)
)</pre>
			
		
		
		
			
			
			<h2 id="Field">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=4366:4410#L87">Field</a>
				<a class="permalink" href="index.html#Field">&#xb6;</a>
				
				
			</h2>
			<p>Field represents a field from a certain setup

			<pre>type Field struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="FieldCallback">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=5826:5904#L129">FieldCallback</a>
				<a class="permalink" href="index.html#FieldCallback">&#xb6;</a>
				
				
			</h2>
			<p>FieldCallback is a subscription callback which is called when the value of
a specific field is changed.

			<pre>type FieldCallback func(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, state <a href="index.html#Flags">Flags</a>, oldValue, newValue interface{})</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Flags">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=4265:4313#L81">Flags</a>
				<a class="permalink" href="index.html#Flags">&#xb6;</a>
				
				
			</h2>
			<p>Flags represents a set of flags from a certain setup

			<pre>type Flags struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="MergeFlags">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9949:9985#L276">MergeFlags</a>
					<a class="permalink" href="index.html#MergeFlags">&#xb6;</a>
					
					
				</h3>
				<pre>func MergeFlags(list ...<a href="index.html#Flags">Flags</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>MergeFlags merges multiple sets of state flags

				
				
			

			
				
				<h3 id="Flags.And">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=8865:8898#L252">And</a>
					<a class="permalink" href="index.html#Flags.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) And(b <a href="index.html#Flags">Flags</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>And returns the set of flags present in both a and b

				
				
				
			
				
				<h3 id="Flags.AndNot">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9005:9041#L255">AndNot</a>
					<a class="permalink" href="index.html#Flags.AndNot">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) AndNot(b <a href="index.html#Flags">Flags</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>AndNot returns the set of flags present in a but not in b

				
				
				
			
				
				<h3 id="Flags.Equals">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9709:9744#L270">Equals</a>
					<a class="permalink" href="index.html#Flags.Equals">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) Equals(b <a href="index.html#Flags">Flags</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>Equals returns true if a and b have the same flags set

				
				
				
			
				
				<h3 id="Flags.HasAll">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9412:9447#L264">HasAll</a>
					<a class="permalink" href="index.html#Flags.HasAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) HasAll(b <a href="index.html#Flags">Flags</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>HasAll returns true if b is a subset of a

				
				
				
			
				
				<h3 id="Flags.HasNone">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9559:9595#L267">HasNone</a>
					<a class="permalink" href="index.html#Flags.HasNone">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) HasNone(b <a href="index.html#Flags">Flags</a>) <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>HasNone returns true if a and b have no shared flags

				
				
				
			
				
				<h3 id="Flags.IsEmpty">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9845:9874#L273">IsEmpty</a>
					<a class="permalink" href="index.html#Flags.IsEmpty">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) IsEmpty() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsEmpty returns true if a has no flags set

				
				
				
			
				
				<h3 id="Flags.Or">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9143:9175#L258">Or</a>
					<a class="permalink" href="index.html#Flags.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) Or(b <a href="index.html#Flags">Flags</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>Or returns the set of flags present in either a or b

				
				
				
			
				
				<h3 id="Flags.String">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=10198:10228#L288">String</a>
					<a class="permalink" href="index.html#Flags.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (f <a href="index.html#Flags">Flags</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				<p>String returns a list of the names of the flags specified in the bit mask

				
				
				
			
				
				<h3 id="Flags.Xor">func (Flags) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=9289:9322#L261">Xor</a>
					<a class="permalink" href="index.html#Flags.Xor">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Flags">Flags</a>) Xor(b <a href="index.html#Flags">Flags</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>Xor returns the set of flags present in either a or b but not both

				
				
				
			
		
			
			
			<h2 id="NodeStateMachine">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=3308:4205#L54">NodeStateMachine</a>
				<a class="permalink" href="index.html#NodeStateMachine">&#xb6;</a>
				
				
			</h2>
			<p>NodeStateMachine implements a network node-related event subscription system.
It can assign binary state flags and fields of arbitrary type to each node and allows
subscriptions to flag/field changes which can also modify further flags and fields,
potentially triggering further subscriptions. An operation includes an initial change
and all resulting subsequent changes and always ends in a consistent global state.
It is initiated by a &quot;top level&quot; SetState/SetField call that blocks (also blocking other
top-level functions) until the operation is finished. Callbacks making further changes
should use the non-blocking SetStateSub/SetFieldSub functions. The tree of events
resulting from the initial changes is traversed in a breadth-first order, ensuring for
each subscription callback that all other callbacks caused by the same change triggering
the current callback are processed before anything is triggered by the changes made in the
current callback. In practice this logic ensures that all subscriptions &quot;see&quot; events in
the logical order, callbacks are never called concurrently and &quot;back and forth&quot; effects
are also possible. The state machine design should ensure that infinite event cycles
cannot happen.
The caller can also add timeouts assigned to a certain node and a subset of state flags.
If the timeout elapses, the flags are reset. If all relevant flags are reset then the timer
is dropped. State flags with no timeout are persisted in the database if the flag
descriptor enables saving. If a node has no state flags set at any moment then it is discarded.
Note: in order to avoid mutex deadlocks the callbacks should never lock a mutex that
might be locked when the top level SetState/SetField functions are called. If a function
potentially performs state/field changes then it is recommended to mention this fact in the
function description, along with whether it should run inside an operation callback.

			<pre>type NodeStateMachine struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewNodeStateMachine">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=10699:10813#L310">NewNodeStateMachine</a>
					<a class="permalink" href="index.html#NewNodeStateMachine">&#xb6;</a>
					
					
				</h3>
				<pre>func NewNodeStateMachine(db <a href="../../ethdb/index.html">ethdb</a>.<a href="../../ethdb/index.html#KeyValueStore">KeyValueStore</a>, dbKey []<a href="../../../../../builtin/index.html#byte">byte</a>, clock <a href="../../common/mclock/index.html">mclock</a>.<a href="../../common/mclock/index.html#Clock">Clock</a>, setup *<a href="index.html#Setup">Setup</a>) *<a href="index.html#NodeStateMachine">NodeStateMachine</a></pre>
				<p>NewNodeStateMachine creates a new node state machine.
If db is not nil then the node states, fields and active timeouts are persisted.
Persistence can be enabled or disabled for each state flag and field.

				
				
			

			
				
				<h3 id="NodeStateMachine.AddLogMetrics">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=29827:29969#L983">AddLogMetrics</a>
					<a class="permalink" href="index.html#NodeStateMachine.AddLogMetrics">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) AddLogMetrics(requireFlags, disableFlags <a href="index.html#Flags">Flags</a>, name <a href="../../../../../builtin/index.html#string">string</a>, inMeter, outMeter <a href="../../metrics/index.html">metrics</a>.<a href="../../metrics/index.html#Meter">Meter</a>, gauge <a href="../../metrics/index.html">metrics</a>.<a href="../../metrics/index.html#Gauge">Gauge</a>)</pre>
				<p>AddLogMetrics adds logging and/or metrics for nodes entering, exiting and currently
being in a given set specified by required and disabled state flags

				
				
				
			
				
				<h3 id="NodeStateMachine.AddTimeout">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=24108:24203#L776">AddTimeout</a>
					<a class="permalink" href="index.html#NodeStateMachine.AddTimeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) AddTimeout(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, flags <a href="index.html#Flags">Flags</a>, timeout <a href="../../../../../time/index.html">time</a>.<a href="../../../../../time/index.html#Duration">Duration</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>AddTimeout adds a node state timeout associated to the given state flag(s).
After the specified time interval, the relevant states will be reset.

				
				
				
			
				
				<h3 id="NodeStateMachine.ForEach">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=28793:28899#L949">ForEach</a>
					<a class="permalink" href="index.html#NodeStateMachine.ForEach">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) ForEach(requireFlags, disableFlags <a href="index.html#Flags">Flags</a>, cb func(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, state <a href="index.html#Flags">Flags</a>))</pre>
				<p>ForEach calls the callback for each node having all of the required and none of the
disabled flags set.
Note that this callback is not an operation callback but ForEach can be called from an
Operation callback or Operation can also be called from a ForEach callback if necessary.

				
				
				
			
				
				<h3 id="NodeStateMachine.GetField">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=25989:26065#L844">GetField</a>
					<a class="permalink" href="index.html#NodeStateMachine.GetField">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) GetField(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, field <a href="index.html#Field">Field</a>) interface{}</pre>
				<p>GetField retrieves the given field of the given node. Note that when used in a
subscription callback the result can be out of sync with the state change represented
by the callback parameters so extra safety checks might be necessary.

				
				
				
			
				
				<h3 id="NodeStateMachine.GetNode">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=29469:29529#L970">GetNode</a>
					<a class="permalink" href="index.html#NodeStateMachine.GetNode">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) GetNode(id <a href="../enode/index.html">enode</a>.<a href="../enode/index.html#ID">ID</a>) *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a></pre>
				<p>GetNode returns the enode currently associated with the given ID

				
				
				
			
				
				<h3 id="NodeStateMachine.GetState">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=26515:26572#L861">GetState</a>
					<a class="permalink" href="index.html#NodeStateMachine.GetState">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) GetState(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>GetState retrieves the current state of the given node. Note that when used in a
subscription callback the result can be out of sync with the state change represented
by the callback parameters so extra safety checks might be necessary.

				
				
				
			
				
				<h3 id="NodeStateMachine.Operation">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=22666:22720#L725">Operation</a>
					<a class="permalink" href="index.html#NodeStateMachine.Operation">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) Operation(fn func()) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>Operation calls the given function as an operation callback. This allows the caller
to start an operation with multiple initial changes. The same rules apply as for
subscription callbacks.

				
				
				
			
				
				<h3 id="NodeStateMachine.Persist">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=19199:19255#L598">Persist</a>
					<a class="permalink" href="index.html#NodeStateMachine.Persist">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) Persist(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>Persist saves the persistent state and fields of the given node immediately

				
				
				
			
				
				<h3 id="NodeStateMachine.SetField">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=26885:26974#L876">SetField</a>
					<a class="permalink" href="index.html#NodeStateMachine.SetField">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SetField(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, field <a href="index.html#Field">Field</a>, value interface{}) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>SetField sets the given field of the given node and blocks until the operation is finished

				
				
				
			
				
				<h3 id="NodeStateMachine.SetFieldSub">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=27260:27352#L890">SetFieldSub</a>
					<a class="permalink" href="index.html#NodeStateMachine.SetFieldSub">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SetFieldSub(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, field <a href="index.html#Field">Field</a>, value interface{}) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>SetFieldSub sets the given field of the given node without blocking (should be called
from a subscription/operation callback).

				
				
				
			
				
				<h3 id="NodeStateMachine.SetState">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=19714:19822#L615">SetState</a>
					<a class="permalink" href="index.html#NodeStateMachine.SetState">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SetState(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, setFlags, resetFlags <a href="index.html#Flags">Flags</a>, timeout <a href="../../../../../time/index.html">time</a>.<a href="../../../../../time/index.html#Duration">Duration</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>SetState updates the given node state flags and blocks until the operation is finished.
If a flag with a timeout is set again, the operation removes or replaces the existing timeout.

				
				
				
			
				
				<h3 id="NodeStateMachine.SetStateSub">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=20114:20219#L629">SetStateSub</a>
					<a class="permalink" href="index.html#NodeStateMachine.SetStateSub">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SetStateSub(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, setFlags, resetFlags <a href="index.html#Flags">Flags</a>, timeout <a href="../../../../../time/index.html">time</a>.<a href="../../../../../time/index.html#Duration">Duration</a>)</pre>
				<p>SetStateSub updates the given node state flags without blocking (should be called
from a subscription/operation callback).

				
				
				
			
				
				<h3 id="NodeStateMachine.Start">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=14126:14161#L408">Start</a>
					<a class="permalink" href="index.html#NodeStateMachine.Start">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) Start()</pre>
				<p>Start starts the state machine, enabling state and field operations and disabling
further subscriptions.

				
				
				
			
				
				<h3 id="NodeStateMachine.Stop">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=14457:14491#L425">Stop</a>
					<a class="permalink" href="index.html#NodeStateMachine.Stop">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) Stop()</pre>
				<p>Stop stops the state machine and saves its state if a database was supplied

				
				
				
			
				
				<h3 id="NodeStateMachine.SubscribeField">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=13377:13456#L383">SubscribeField</a>
					<a class="permalink" href="index.html#NodeStateMachine.SubscribeField">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SubscribeField(field <a href="index.html#Field">Field</a>, callback <a href="index.html#FieldCallback">FieldCallback</a>)</pre>
				<p>SubscribeField adds a node field subscription. Same rules apply as for SubscribeState.

				
				
				
			
				
				<h3 id="NodeStateMachine.SubscribeState">func (*NodeStateMachine) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=13022:13101#L372">SubscribeState</a>
					<a class="permalink" href="index.html#NodeStateMachine.SubscribeState">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="index.html#NodeStateMachine">NodeStateMachine</a>) SubscribeState(flags <a href="index.html#Flags">Flags</a>, callback <a href="index.html#StateCallback">StateCallback</a>)</pre>
				<p>SubscribeState adds a node state subscription. The callback is called while the state
machine mutex is not held and it is allowed to make further state updates using the
non-blocking SetStateSub/SetFieldSub functions. All callbacks of an operation are running
from the thread/goroutine of the initial caller and parallel operations are not permitted.
Therefore the callback is never called concurrently. It is the responsibility of the
implemented state logic to avoid deadlocks and to reach a stable state in a finite amount
of steps.
State subscriptions should be installed before loading the node database or making the
first state update.

				
				
				
			
		
			
			
			<h2 id="Setup">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=5118:5205#L111">Setup</a>
				<a class="permalink" href="index.html#Setup">&#xb6;</a>
				
				
			</h2>
			<p>stateSetup contains the list of flags and fields used by the application

			<pre>type Setup struct {
<span id="Setup.Version"></span>    Version <a href="../../../../../builtin/index.html#uint">uint</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Setup.NewField">func (*Setup) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=7523:7586#L200">NewField</a>
					<a class="permalink" href="index.html#Setup.NewField">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Setup">Setup</a>) NewField(name <a href="../../../../../builtin/index.html#string">string</a>, ftype <a href="../../../../../reflect/index.html">reflect</a>.<a href="../../../../../reflect/index.html#Type">Type</a>) <a href="index.html#Field">Field</a></pre>
				<p>NewField creates a new node state field

				
				
				
			
				
				<h3 id="Setup.NewFlag">func (*Setup) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=6727:6769#L175">NewFlag</a>
					<a class="permalink" href="index.html#Setup.NewFlag">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Setup">Setup</a>) NewFlag(name <a href="../../../../../builtin/index.html#string">string</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>NewFlag creates a new node state flag

				
				
				
			
				
				<h3 id="Setup.NewPersistentField">func (*Setup) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=7785:7942#L210">NewPersistentField</a>
					<a class="permalink" href="index.html#Setup.NewPersistentField">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Setup">Setup</a>) NewPersistentField(name <a href="../../../../../builtin/index.html#string">string</a>, ftype <a href="../../../../../reflect/index.html">reflect</a>.<a href="../../../../../reflect/index.html#Type">Type</a>, encode func(interface{}) ([]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>), decode func([]<a href="../../../../../builtin/index.html#byte">byte</a>) (interface{}, <a href="../../../../../builtin/index.html#error">error</a>)) <a href="index.html#Field">Field</a></pre>
				<p>NewPersistentField creates a new persistent node field

				
				
				
			
				
				<h3 id="Setup.NewPersistentFlag">func (*Setup) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=7036:7088#L185">NewPersistentFlag</a>
					<a class="permalink" href="index.html#Setup.NewPersistentFlag">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Setup">Setup</a>) NewPersistentFlag(name <a href="../../../../../builtin/index.html#string">string</a>) <a href="index.html#Flags">Flags</a></pre>
				<p>NewPersistentFlag creates a new persistent node state flag

				
				
				
			
				
				<h3 id="Setup.OfflineFlag">func (*Setup) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=7395:7430#L195">OfflineFlag</a>
					<a class="permalink" href="index.html#Setup.OfflineFlag">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#Setup">Setup</a>) OfflineFlag() <a href="index.html#Flags">Flags</a></pre>
				<p>OfflineFlag returns the system-defined offline flag belonging to the given setup

				
				
				
			
		
			
			
			<h2 id="StateCallback">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/p2p/nodestate/nodestate.go?s=5652:5711#L125">StateCallback</a>
				<a class="permalink" href="index.html#StateCallback">&#xb6;</a>
				
				
			</h2>
			<p>StateCallback is a subscription callback which is called when one of the
state flags that is included in the subscription state mask is changed.
Note: oldState and newState are also masked with the subscription mask so only
the relevant bits are included.

			<pre>type StateCallback func(n *<a href="../enode/index.html">enode</a>.<a href="../enode/index.html#Node">Node</a>, oldState, newState <a href="index.html#Flags">Flags</a>)</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
