<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>abi - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.10";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package abi
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/ethereum/go-ethereum/accounts/abi"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package abi implements the Ethereum ABI (Application Binary
Interface).
<p>The Ethereum ABI is strongly typed, known at compile time
and static. This ABI will handle basic type casting; unsigned
to signed and visa versa. It does not handle slice casting such
as unsigned slice to signed slice. Bit size type casting is also
handled. ints with a bit size of 32 will be properly cast to int256,
etc.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#ConvertType">func ConvertType(in interface{}, proto interface{}) interface{}</a></dd>
			
				
				<dd><a href="index.html#MakeTopics">func MakeTopics(query ...[]interface{}) ([][]common.Hash, error)</a></dd>
			
				
				<dd><a href="index.html#ParseTopics">func ParseTopics(out interface{}, fields Arguments, topics []common.Hash) error</a></dd>
			
				
				<dd><a href="index.html#ParseTopicsIntoMap">func ParseTopicsIntoMap(out map[string]interface{}, fields Arguments, topics []common.Hash) error</a></dd>
			
				
				<dd><a href="index.html#ReadFixedBytes">func ReadFixedBytes(t Type, word []byte) (interface{}, error)</a></dd>
			
				
				<dd><a href="index.html#ReadInteger">func ReadInteger(typ Type, b []byte) interface{}</a></dd>
			
				
				<dd><a href="index.html#ResolveNameConflict">func ResolveNameConflict(rawName string, used func(string) bool) string</a></dd>
			
				
				<dd><a href="index.html#ToCamelCase">func ToCamelCase(input string) string</a></dd>
			
				
				<dd><a href="index.html#UnpackRevert">func UnpackRevert(data []byte) (string, error)</a></dd>
			
			
				
				<dd><a href="index.html#ABI">type ABI</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#JSON">func JSON(reader io.Reader) (ABI, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.EventByID">func (abi *ABI) EventByID(topic common.Hash) (*Event, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.HasFallback">func (abi *ABI) HasFallback() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.HasReceive">func (abi *ABI) HasReceive() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.MethodById">func (abi *ABI) MethodById(sigdata []byte) (*Method, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.Pack">func (abi ABI) Pack(name string, args ...interface{}) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.UnmarshalJSON">func (abi *ABI) UnmarshalJSON(data []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.Unpack">func (abi ABI) Unpack(name string, data []byte) ([]interface{}, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.UnpackIntoInterface">func (abi ABI) UnpackIntoInterface(v interface{}, name string, data []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ABI.UnpackIntoMap">func (abi ABI) UnpackIntoMap(v map[string]interface{}, name string, data []byte) (err error)</a></dd>
				
			
				
				<dd><a href="index.html#Argument">type Argument</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Argument.UnmarshalJSON">func (argument *Argument) UnmarshalJSON(data []byte) error</a></dd>
				
			
				
				<dd><a href="index.html#ArgumentMarshaling">type ArgumentMarshaling</a></dd>
				
				
			
				
				<dd><a href="index.html#Arguments">type Arguments</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.Copy">func (arguments Arguments) Copy(v interface{}, values []interface{}) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.NonIndexed">func (arguments Arguments) NonIndexed() Arguments</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.Pack">func (arguments Arguments) Pack(args ...interface{}) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.PackValues">func (arguments Arguments) PackValues(args []interface{}) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.Unpack">func (arguments Arguments) Unpack(data []byte) ([]interface{}, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.UnpackIntoMap">func (arguments Arguments) UnpackIntoMap(v map[string]interface{}, data []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Arguments.UnpackValues">func (arguments Arguments) UnpackValues(data []byte) ([]interface{}, error)</a></dd>
				
			
				
				<dd><a href="index.html#Error">type Error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewError">func NewError(name string, inputs Arguments) Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Error.String">func (e *Error) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Error.Unpack">func (e *Error) Unpack(data []byte) (interface{}, error)</a></dd>
				
			
				
				<dd><a href="index.html#Event">type Event</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewEvent">func NewEvent(name, rawName string, anonymous bool, inputs Arguments) Event</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Event.String">func (e Event) String() string</a></dd>
				
			
				
				<dd><a href="index.html#FunctionType">type FunctionType</a></dd>
				
				
			
				
				<dd><a href="index.html#Method">type Method</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewMethod">func NewMethod(name string, rawName string, funType FunctionType, mutability string, isConst, isPayable bool, inputs Arguments, outputs Arguments) Method</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Method.IsConstant">func (method Method) IsConstant() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Method.IsPayable">func (method Method) IsPayable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Method.String">func (method Method) String() string</a></dd>
				
			
				
				<dd><a href="index.html#SelectorMarshaling">type SelectorMarshaling</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseSelector">func ParseSelector(unescapedSelector string) (SelectorMarshaling, error)</a></dd>
				
				
			
				
				<dd><a href="index.html#Type">type Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewType">func NewType(t string, internalType string, components []ArgumentMarshaling) (typ Type, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.GetType">func (t Type) GetType() reflect.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Type.String">func (t Type) String() (out string)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_JSON">JSON</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go">abi.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go">argument.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error.go">error.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error_handling.go">error_handling.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/event.go">event.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go">method.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/pack.go">pack.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/reflect.go">reflect.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/selector_parser.go">selector_parser.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/topics.go">topics.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/type.go">type.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/unpack.go">unpack.go</a>
			
				<a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/utils.go">utils.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Type enumerator

				<pre>const (
    <span id="IntTy">IntTy</span> <a href="../../../../../builtin/index.html#byte">byte</a> = <a href="../../../../../builtin/index.html#iota">iota</a>
    <span id="UintTy">UintTy</span>
    <span id="BoolTy">BoolTy</span>
    <span id="StringTy">StringTy</span>
    <span id="SliceTy">SliceTy</span>
    <span id="ArrayTy">ArrayTy</span>
    <span id="TupleTy">TupleTy</span>
    <span id="AddressTy">AddressTy</span>
    <span id="FixedBytesTy">FixedBytesTy</span>
    <span id="BytesTy">BytesTy</span>
    <span id="HashTy">HashTy</span>
    <span id="FixedPointTy">FixedPointTy</span>
    <span id="FunctionTy">FunctionTy</span>
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span class="comment">// MaxUint256 is the maximum value that can be represented by a uint256.</span>
    <span id="MaxUint256">MaxUint256</span> = <a href="../../../../../builtin/index.html#new">new</a>(<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>).<a href="index.html#Sub">Sub</a>(<a href="../../../../../builtin/index.html#new">new</a>(<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>).<a href="index.html#Lsh">Lsh</a>(<a href="../../common/index.html">common</a>.<a href="../../common/index.html#Big1">Big1</a>, 256), <a href="../../common/index.html">common</a>.<a href="../../common/index.html#Big1">Big1</a>)
    <span class="comment">// MaxInt256 is the maximum value that can be represented by a int256.</span>
    <span id="MaxInt256">MaxInt256</span> = <a href="../../../../../builtin/index.html#new">new</a>(<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>).<a href="index.html#Sub">Sub</a>(<a href="../../../../../builtin/index.html#new">new</a>(<a href="../../../../../math/big/index.html">big</a>.<a href="../../../../../math/big/index.html#Int">Int</a>).<a href="index.html#Lsh">Lsh</a>(<a href="../../common/index.html">common</a>.<a href="../../common/index.html#Big1">Big1</a>, 255), <a href="../../common/index.html">common</a>.<a href="../../common/index.html#Big1">Big1</a>)
)</pre>
			
		
		
			
			
			<h2 id="ConvertType">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/reflect.go?s=1218:1281#L28">ConvertType</a>
				<a class="permalink" href="index.html#ConvertType">&#xb6;</a>
				
				
			</h2>
			<pre>func ConvertType(in interface{}, proto interface{}) interface{}</pre>
			<p>ConvertType converts an interface of a runtime type into a interface of the
given type
e.g. turn
var fields []reflect.StructField
<pre>fields = append(fields, reflect.StructField{
		Name: &quot;X&quot;,
		Type: reflect.TypeOf(new(big.Int)),
		Tag:  reflect.StructTag(&quot;json:\&quot;&quot; + &quot;x&quot; + &quot;\&quot;&quot;),
}
</pre>
<p>into
type TupleT struct { X *big.Int }

			
			

		
			
			
			<h2 id="MakeTopics">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/topics.go?s=1039:1103#L21">MakeTopics</a>
				<a class="permalink" href="index.html#MakeTopics">&#xb6;</a>
				
				
			</h2>
			<pre>func MakeTopics(query ...[]interface{}) ([][]<a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>MakeTopics converts a filter query argument list into a filter topic set.

			
			

		
			
			
			<h2 id="ParseTopics">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/topics.go?s=3952:4031#L105">ParseTopics</a>
				<a class="permalink" href="index.html#ParseTopics">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseTopics(out interface{}, fields <a href="index.html#Arguments">Arguments</a>, topics []<a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
			<p>ParseTopics converts the indexed topic fields into actual log field values.

			
			

		
			
			
			<h2 id="ParseTopicsIntoMap">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/topics.go?s=4340:4437#L114">ParseTopicsIntoMap</a>
				<a class="permalink" href="index.html#ParseTopicsIntoMap">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseTopicsIntoMap(out map[<a href="../../../../../builtin/index.html#string">string</a>]interface{}, fields <a href="index.html#Arguments">Arguments</a>, topics []<a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
			<p>ParseTopicsIntoMap converts the indexed topic field-value pairs into map key-value pairs.

			
			

		
			
			
			<h2 id="ReadFixedBytes">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/unpack.go?s=3346:3407#L99">ReadFixedBytes</a>
				<a class="permalink" href="index.html#ReadFixedBytes">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadFixedBytes(t <a href="index.html#Type">Type</a>, word []<a href="../../../../../builtin/index.html#byte">byte</a>) (interface{}, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>ReadFixedBytes uses reflection to create a fixed array to be read from.

			
			

		
			
			
			<h2 id="ReadInteger">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/unpack.go?s=1310:1358#L26">ReadInteger</a>
				<a class="permalink" href="index.html#ReadInteger">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadInteger(typ <a href="index.html#Type">Type</a>, b []<a href="../../../../../builtin/index.html#byte">byte</a>) interface{}</pre>
			<p>ReadInteger reads the integer based on its kind and returns the appropriate value.

			
			

		
			
			
			<h2 id="ResolveNameConflict">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/utils.go?s=1439:1510#L23">ResolveNameConflict</a>
				<a class="permalink" href="index.html#ResolveNameConflict">&#xb6;</a>
				
				
			</h2>
			<pre>func ResolveNameConflict(rawName <a href="../../../../../builtin/index.html#string">string</a>, used func(<a href="../../../../../builtin/index.html#string">string</a>) <a href="../../../../../builtin/index.html#bool">bool</a>) <a href="../../../../../builtin/index.html#string">string</a></pre>
			<p>ResolveNameConflict returns the next available name for a given thing.
This helper can be used for lots of purposes:
<ul>
<li>In solidity function overloading is supported, this function can fix
the name conflicts of overloaded functions.
<li>In golang binding generation, the parameter(in function, event, error,
and struct definition) name will be converted to camelcase style which
may eventually lead to name conflicts.
</ul>
<p>Name conflicts are mostly resolved by adding number suffix.
<pre>	 e.g. if the abi contains Methods send, send1
  ResolveNameConflict would return send2 for input send.
</pre>

			
			

		
			
			
			<h2 id="ToCamelCase">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=8498:8535#L255">ToCamelCase</a>
				<a class="permalink" href="index.html#ToCamelCase">&#xb6;</a>
				
				
			</h2>
			<pre>func ToCamelCase(input <a href="../../../../../builtin/index.html#string">string</a>) <a href="../../../../../builtin/index.html#string">string</a></pre>
			<p>ToCamelCase converts an under-score string to a camel-case string

			
			

		
			
			
			<h2 id="UnpackRevert">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=8477:8523#L232">UnpackRevert</a>
				<a class="permalink" href="index.html#UnpackRevert">&#xb6;</a>
				
				
			</h2>
			<pre>func UnpackRevert(data []<a href="../../../../../builtin/index.html#byte">byte</a>) (<a href="../../../../../builtin/index.html#string">string</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
			<p>UnpackRevert resolves the abi-encoded revert reason. According to the solidity
spec <a href="https://solidity.readthedocs.io/en/latest/control-structures.html#revert">https://solidity.readthedocs.io/en/latest/control-structures.html#revert</a>,
the provided revert reason is abi-encoded as if it were a call to a function
`Error(string)`. So it&apos;s a special tool for it.

			
			

		
		
			
			
			<h2 id="ABI">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=1122:1543#L23">ABI</a>
				<a class="permalink" href="index.html#ABI">&#xb6;</a>
				
				
			</h2>
			<p>The ABI holds information about a contract&apos;s context and available
invokable methods. It will allow you to type check function calls and
packs data accordingly.

			<pre>type ABI struct {
<span id="ABI.Constructor"></span>    Constructor <a href="index.html#Method">Method</a>
<span id="ABI.Methods"></span>    Methods     map[<a href="../../../../../builtin/index.html#string">string</a>]<a href="index.html#Method">Method</a>
<span id="ABI.Events"></span>    Events      map[<a href="../../../../../builtin/index.html#string">string</a>]<a href="index.html#Event">Event</a>
<span id="ABI.Errors"></span>    Errors      map[<a href="../../../../../builtin/index.html#string">string</a>]<a href="index.html#Error">Error</a>

    <span class="comment">// Additional &#34;special&#34; functions introduced in solidity v0.6.0.</span>
    <span class="comment">// It&#39;s separated from the original default fallback. Each contract</span>
    <span class="comment">// can only define one fallback and receive function.</span>
<span id="ABI.Fallback"></span>    Fallback <a href="index.html#Method">Method</a> <span class="comment">// Note it&#39;s also used to represent legacy fallback before v0.6.0</span>
<span id="ABI.Receive"></span>    Receive  <a href="index.html#Method">Method</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="JSON">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=1608:1648#L37">JSON</a>
					<a class="permalink" href="index.html#JSON">&#xb6;</a>
					
					
				</h3>
				<pre>func JSON(reader <a href="../../../../../io/index.html">io</a>.<a href="../../../../../io/index.html#Reader">Reader</a>) (<a href="index.html#ABI">ABI</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>JSON returns a parsed ABI interface and error if it failed.

				<div id="example_JSON" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">const definition = `[{&#34;constant&#34;:true,&#34;inputs&#34;:[{&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;address&#34;}],&#34;name&#34;:&#34;isBar&#34;,&#34;outputs&#34;:[{&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;bool&#34;}],&#34;type&#34;:&#34;function&#34;}]`

abi, err := JSON(strings.NewReader(definition))
if err != nil {
    panic(err)
}
out, err := abi.Pack(&#34;isBar&#34;, common.HexToAddress(&#34;01&#34;))
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%x\n&#34;, out)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1f2c40920000000000000000000000000000000000000000000000000000000000000001
</pre>
			
		
	</div>
</div>

				
			

			
				
				<h3 id="ABI.EventByID">func (*ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=7486:7546#L206">EventByID</a>
					<a class="permalink" href="index.html#ABI.EventByID">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi *<a href="index.html#ABI">ABI</a>) EventByID(topic <a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>) (*<a href="index.html#Event">Event</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>EventByID looks an event up by its topic hash in the
ABI and returns nil if none found.

				
				
				
			
				
				<h3 id="ABI.HasFallback">func (*ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=7808:7842#L216">HasFallback</a>
					<a class="permalink" href="index.html#ABI.HasFallback">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi *<a href="index.html#ABI">ABI</a>) HasFallback() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>HasFallback returns an indicator whether a fallback function is included.

				
				
				
			
				
				<h3 id="ABI.HasReceive">func (*ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=7961:7994#L221">HasReceive</a>
					<a class="permalink" href="index.html#ABI.HasReceive">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi *<a href="index.html#ABI">ABI</a>) HasReceive() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>HasReceive returns an indicator whether a receive function is included.

				
				
				
			
				
				<h3 id="ABI.MethodById">func (*ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=7037:7096#L192">MethodById</a>
					<a class="permalink" href="index.html#ABI.MethodById">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi *<a href="index.html#ABI">ABI</a>) MethodById(sigdata []<a href="../../../../../builtin/index.html#byte">byte</a>) (*<a href="index.html#Method">Method</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>MethodById looks up a method by the 4-byte id,
returns nil if none found.

				
				
				
			
				
				<h3 id="ABI.Pack">func (ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=2101:2170#L52">Pack</a>
					<a class="permalink" href="index.html#ABI.Pack">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi <a href="index.html#ABI">ABI</a>) Pack(name <a href="../../../../../builtin/index.html#string">string</a>, args ...interface{}) ([]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>Pack the given method name to conform the ABI. Method call&apos;s data
will consist of method_id, args0, arg1, ... argN. Method id consists
of 4 bytes and arguments are all 32 bytes.
Method ids are created from the first 4 bytes of the hash of the
methods string signature. (signature = baz(uint32,string32))

				
				
				
			
				
				<h3 id="ABI.UnmarshalJSON">func (*ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=4406:4454#L127">UnmarshalJSON</a>
					<a class="permalink" href="index.html#ABI.UnmarshalJSON">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi *<a href="index.html#ABI">ABI</a>) UnmarshalJSON(data []<a href="../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>UnmarshalJSON implements json.Unmarshaler interface.

				
				
				
			
				
				<h3 id="ABI.Unpack">func (ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=3360:3430#L94">Unpack</a>
					<a class="permalink" href="index.html#ABI.Unpack">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi <a href="index.html#ABI">ABI</a>) Unpack(name <a href="../../../../../builtin/index.html#string">string</a>, data []<a href="../../../../../builtin/index.html#byte">byte</a>) ([]interface{}, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>Unpack unpacks the output according to the abi specification.

				
				
				
			
				
				<h3 id="ABI.UnpackIntoInterface">func (ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=3804:3885#L105">UnpackIntoInterface</a>
					<a class="permalink" href="index.html#ABI.UnpackIntoInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi <a href="index.html#ABI">ABI</a>) UnpackIntoInterface(v interface{}, name <a href="../../../../../builtin/index.html#string">string</a>, data []<a href="../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>UnpackIntoInterface unpacks the output in v according to the abi specification.
It performs an additional copy. Please only use, if you want to unpack into a
structure that does not strictly conform to the abi structure (e.g. has additional arguments)

				
				
				
			
				
				<h3 id="ABI.UnpackIntoMap">func (ABI) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/abi.go?s=4140:4232#L118">UnpackIntoMap</a>
					<a class="permalink" href="index.html#ABI.UnpackIntoMap">&#xb6;</a>
					
					
				</h3>
				<pre>func (abi <a href="index.html#ABI">ABI</a>) UnpackIntoMap(v map[<a href="../../../../../builtin/index.html#string">string</a>]interface{}, name <a href="../../../../../builtin/index.html#string">string</a>, data []<a href="../../../../../builtin/index.html#byte">byte</a>) (err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>UnpackIntoMap unpacks a log into the provided map[string]interface{}.

				
				
				
			
		
			
			
			<h2 id="Argument">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=999:1101#L19">Argument</a>
				<a class="permalink" href="index.html#Argument">&#xb6;</a>
				
				
			</h2>
			<p>Argument holds the name of the argument and the corresponding type.
Types are used when packing and testing arguments.

			<pre>type Argument struct {
<span id="Argument.Name"></span>    Name    <a href="../../../../../builtin/index.html#string">string</a>
<span id="Argument.Type"></span>    Type    <a href="index.html#Type">Type</a>
<span id="Argument.Indexed"></span>    Indexed <a href="../../../../../builtin/index.html#bool">bool</a> <span class="comment">// indexed is only used by events</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Argument.UnmarshalJSON">func (*Argument) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=1339:1397#L36">UnmarshalJSON</a>
					<a class="permalink" href="index.html#Argument.UnmarshalJSON">&#xb6;</a>
					
					
				</h3>
				<pre>func (argument *<a href="index.html#Argument">Argument</a>) UnmarshalJSON(data []<a href="../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>UnmarshalJSON implements json.Unmarshaler interface.

				
				
				
			
		
			
			
			<h2 id="ArgumentMarshaling">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=1130:1281#L27">ArgumentMarshaling</a>
				<a class="permalink" href="index.html#ArgumentMarshaling">&#xb6;</a>
				
				
			</h2>
			
			<pre>type ArgumentMarshaling struct {
<span id="ArgumentMarshaling.Name"></span>    Name         <a href="../../../../../builtin/index.html#string">string</a>
<span id="ArgumentMarshaling.Type"></span>    Type         <a href="../../../../../builtin/index.html#string">string</a>
<span id="ArgumentMarshaling.InternalType"></span>    InternalType <a href="../../../../../builtin/index.html#string">string</a>
<span id="ArgumentMarshaling.Components"></span>    Components   []<a href="index.html#ArgumentMarshaling">ArgumentMarshaling</a>
<span id="ArgumentMarshaling.Indexed"></span>    Indexed      <a href="../../../../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Arguments">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=1103:1128#L25">Arguments</a>
				<a class="permalink" href="index.html#Arguments">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Arguments []<a href="index.html#Argument">Argument</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="Arguments.Copy">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=3238:3312#L103">Copy</a>
					<a class="permalink" href="index.html#Arguments.Copy">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) Copy(v interface{}, values []interface{}) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>Copy performs the operation go format -&gt; provided struct.

				
				
				
			
				
				<h3 id="Arguments.NonIndexed">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=1788:1837#L54">NonIndexed</a>
					<a class="permalink" href="index.html#Arguments.NonIndexed">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) NonIndexed() <a href="index.html#Arguments">Arguments</a></pre>
				<p>NonIndexed returns the arguments with indexed arguments filtered out.

				
				
				
			
				
				<h3 id="Arguments.Pack">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=7183:7251#L212">Pack</a>
					<a class="permalink" href="index.html#Arguments.Pack">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) Pack(args ...interface{}) ([]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>Pack performs the operation Go format -&gt; Hexdata.

				
				
				
			
				
				<h3 id="Arguments.PackValues">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=7019:7092#L207">PackValues</a>
					<a class="permalink" href="index.html#Arguments.PackValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) PackValues(args []interface{}) ([]<a href="../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>PackValues performs the operation Go format -&gt; Hexdata.
It is the semantic opposite of UnpackValues.

				
				
				
			
				
				<h3 id="Arguments.Unpack">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=2169:2238#L70">Unpack</a>
					<a class="permalink" href="index.html#Arguments.Unpack">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) Unpack(data []<a href="../../../../../builtin/index.html#byte">byte</a>) ([]interface{}, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>Unpack performs the operation hexdata -&gt; Go format.

				
				
				
			
				
				<h3 id="Arguments.UnpackIntoMap">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=2585:2670#L81">UnpackIntoMap</a>
					<a class="permalink" href="index.html#Arguments.UnpackIntoMap">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) UnpackIntoMap(v map[<a href="../../../../../builtin/index.html#string">string</a>]interface{}, data []<a href="../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../builtin/index.html#error">error</a></pre>
				<p>UnpackIntoMap performs the operation hexdata -&gt; mapping of argument name to argument value.

				
				
				
			
				
				<h3 id="Arguments.UnpackValues">func (Arguments) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/argument.go?s=5628:5703#L174">UnpackValues</a>
					<a class="permalink" href="index.html#Arguments.UnpackValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (arguments <a href="index.html#Arguments">Arguments</a>) UnpackValues(data []<a href="../../../../../builtin/index.html#byte">byte</a>) ([]interface{}, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>UnpackValues can be used to unpack ABI-encoded hexdata according to the ABI-specification,
without supplying a struct to unpack into. Instead, this method returns a list containing the
values. An atomic argument will be a list with one element.

				
				
				
			
		
			
			
			<h2 id="Error">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error.go?s=940:1382#L19">Error</a>
				<a class="permalink" href="index.html#Error">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Error struct {
<span id="Error.Name"></span>    Name   <a href="../../../../../builtin/index.html#string">string</a>
<span id="Error.Inputs"></span>    Inputs <a href="index.html#Arguments">Arguments</a>

<span id="Error.Sig"></span>    <span class="comment">// Sig contains the string signature according to the ABI spec.</span>
    <span class="comment">// e.g.	 error foo(uint32 a, int b) = &#34;foo(uint32,int256)&#34;</span>
    <span class="comment">// Please note that &#34;int&#34; is substitute for its canonical representation &#34;int256&#34;</span>
    Sig <a href="../../../../../builtin/index.html#string">string</a>

<span id="Error.ID"></span>    <span class="comment">// ID returns the canonical representation of the error&#39;s signature used by the</span>
    <span class="comment">// abi definition to identify event names and types.</span>
    ID <a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewError">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error.go?s=1384:1434#L34">NewError</a>
					<a class="permalink" href="index.html#NewError">&#xb6;</a>
					
					
				</h3>
				<pre>func NewError(name <a href="../../../../../builtin/index.html#string">string</a>, inputs <a href="index.html#Arguments">Arguments</a>) <a href="index.html#Error">Error</a></pre>
				
				
				
			

			
				
				<h3 id="Error.String">func (*Error) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error.go?s=2361:2392#L71">String</a>
					<a class="permalink" href="index.html#Error.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Error">Error</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Error.Unpack">func (*Error) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/error.go?s=2412:2468#L75">Unpack</a>
					<a class="permalink" href="index.html#Error.Unpack">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#Error">Error</a>) Unpack(data []<a href="../../../../../builtin/index.html#byte">byte</a>) (interface{}, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Event">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/event.go?s=1156:2059#L20">Event</a>
				<a class="permalink" href="index.html#Event">&#xb6;</a>
				
				
			</h2>
			<p>Event is an event potentially triggered by the EVM&apos;s LOG mechanism. The Event
holds type information (inputs) about the yielded output. Anonymous events
don&apos;t get the signature canonical representation as the first LOG topic.

			<pre>type Event struct {
<span id="Event.Name"></span>    <span class="comment">// Name is the event name used for internal representation. It&#39;s derived from</span>
    <span class="comment">// the raw name and a suffix will be added in the case of event overloading.</span>
    <span class="comment">//</span>
    <span class="comment">// e.g.</span>
    <span class="comment">// These are two events that have the same name:</span>
    <span class="comment">// * foo(int,int)</span>
    <span class="comment">// * foo(uint,uint)</span>
    <span class="comment">// The event name of the first one will be resolved as foo while the second one</span>
    <span class="comment">// will be resolved as foo0.</span>
    Name <a href="../../../../../builtin/index.html#string">string</a>

<span id="Event.RawName"></span>    <span class="comment">// RawName is the raw event name parsed from ABI.</span>
    RawName   <a href="../../../../../builtin/index.html#string">string</a>
<span id="Event.Anonymous"></span>    Anonymous <a href="../../../../../builtin/index.html#bool">bool</a>
<span id="Event.Inputs"></span>    Inputs    <a href="index.html#Arguments">Arguments</a>

<span id="Event.Sig"></span>    <span class="comment">// Sig contains the string signature according to the ABI spec.</span>
    <span class="comment">// e.g.	 event foo(uint32 a, int b) = &#34;foo(uint32,int256)&#34;</span>
    <span class="comment">// Please note that &#34;int&#34; is substitute for its canonical representation &#34;int256&#34;</span>
    Sig <a href="../../../../../builtin/index.html#string">string</a>

<span id="Event.ID"></span>    <span class="comment">// ID returns the canonical representation of the event&#39;s signature used by the</span>
    <span class="comment">// abi definition to identify event names and types.</span>
    ID <a href="../../common/index.html">common</a>.<a href="../../common/index.html#Hash">Hash</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewEvent">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/event.go?s=2243:2318#L52">NewEvent</a>
					<a class="permalink" href="index.html#NewEvent">&#xb6;</a>
					
					
				</h3>
				<pre>func NewEvent(name, rawName <a href="../../../../../builtin/index.html#string">string</a>, anonymous <a href="../../../../../builtin/index.html#bool">bool</a>, inputs <a href="index.html#Arguments">Arguments</a>) <a href="index.html#Event">Event</a></pre>
				<p>NewEvent creates a new Event.
It sanitizes the input arguments to remove unnamed arguments.
It also precomputes the id, signature and string representation
of the event.

				
				
			

			
				
				<h3 id="Event.String">func (Event) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/event.go?s=3312:3342#L91">String</a>
					<a class="permalink" href="index.html#Event.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="index.html#Event">Event</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FunctionType">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=958:979#L17">FunctionType</a>
				<a class="permalink" href="index.html#FunctionType">&#xb6;</a>
				
				
			</h2>
			<p>FunctionType represents different types of functions a contract might have.

			<pre>type FunctionType <a href="../../../../../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// Constructor represents the constructor of the contract.</span>
    <span class="comment">// The constructor function is called while deploying a contract.</span>
    <span id="Constructor">Constructor</span> <a href="index.html#FunctionType">FunctionType</a> = <a href="../../../../../builtin/index.html#iota">iota</a>
    <span class="comment">// Fallback represents the fallback function.</span>
    <span class="comment">// This function is executed if no other function matches the given function</span>
    <span class="comment">// signature and no receive function is specified.</span>
    <span id="Fallback">Fallback</span>
    <span class="comment">// Receive represents the receive function.</span>
    <span class="comment">// This function is executed on plain Ether transfers.</span>
    <span id="Receive">Receive</span>
    <span class="comment">// Function represents a normal function.</span>
    <span id="Function">Function</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Method">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=2034:3340#L42">Method</a>
				<a class="permalink" href="index.html#Method">&#xb6;</a>
				
				
			</h2>
			<p>Method represents a callable given a `Name` and whether the method is a constant.
If the method is `Const` no transaction needs to be created for this
particular Method call. It can easily be simulated using a local VM.
For example a `Balance()` method only needs to retrieve something
from the storage and therefore requires no Tx to be sent to the
network. A method such as `Transact` does require a Tx and thus will
be flagged `false`.
Input specifies the required input parameters for this gives method.

			<pre>type Method struct {
<span id="Method.Name"></span>    <span class="comment">// Name is the method name used for internal representation. It&#39;s derived from</span>
    <span class="comment">// the raw name and a suffix will be added in the case of a function overload.</span>
    <span class="comment">//</span>
    <span class="comment">// e.g.</span>
    <span class="comment">// These are two functions that have the same name:</span>
    <span class="comment">// * foo(int,int)</span>
    <span class="comment">// * foo(uint,uint)</span>
    <span class="comment">// The method name of the first one will be resolved as foo while the second one</span>
    <span class="comment">// will be resolved as foo0.</span>
    Name    <a href="../../../../../builtin/index.html#string">string</a>
<span id="Method.RawName"></span>    RawName <a href="../../../../../builtin/index.html#string">string</a> <span class="comment">// RawName is the raw method name parsed from ABI</span>

<span id="Method.Type"></span>    <span class="comment">// Type indicates whether the method is a</span>
    <span class="comment">// special fallback introduced in solidity v0.6.0</span>
    Type <a href="index.html#FunctionType">FunctionType</a>

<span id="Method.StateMutability"></span>    <span class="comment">// StateMutability indicates the mutability state of method,</span>
    <span class="comment">// the default value is nonpayable. It can be empty if the abi</span>
    <span class="comment">// is generated by legacy compiler.</span>
    StateMutability <a href="../../../../../builtin/index.html#string">string</a>

    <span class="comment">// Legacy indicators generated by compiler before v0.6.0</span>
<span id="Method.Constant"></span>    Constant <a href="../../../../../builtin/index.html#bool">bool</a>
<span id="Method.Payable"></span>    Payable  <a href="../../../../../builtin/index.html#bool">bool</a>

<span id="Method.Inputs"></span>    Inputs  <a href="index.html#Arguments">Arguments</a>
<span id="Method.Outputs"></span>    Outputs <a href="index.html#Arguments">Arguments</a>

<span id="Method.Sig"></span>    <span class="comment">// Sig returns the methods string signature according to the ABI spec.</span>
    <span class="comment">// e.g.		function foo(uint32 a, int b) = &#34;foo(uint32,int256)&#34;</span>
    <span class="comment">// Please note that &#34;int&#34; is substitute for its canonical representation &#34;int256&#34;</span>
    Sig <a href="../../../../../builtin/index.html#string">string</a>
<span id="Method.ID"></span>    <span class="comment">// ID returns the canonical representation of the method&#39;s signature used by the</span>
    <span class="comment">// abi definition to identify method names and types.</span>
    ID []<a href="../../../../../builtin/index.html#byte">byte</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewMethod">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=3525:3678#L84">NewMethod</a>
					<a class="permalink" href="index.html#NewMethod">&#xb6;</a>
					
					
				</h3>
				<pre>func NewMethod(name <a href="../../../../../builtin/index.html#string">string</a>, rawName <a href="../../../../../builtin/index.html#string">string</a>, funType <a href="index.html#FunctionType">FunctionType</a>, mutability <a href="../../../../../builtin/index.html#string">string</a>, isConst, isPayable <a href="../../../../../builtin/index.html#bool">bool</a>, inputs <a href="index.html#Arguments">Arguments</a>, outputs <a href="index.html#Arguments">Arguments</a>) <a href="index.html#Method">Method</a></pre>
				<p>NewMethod creates a new Method.
A method should always be created using NewMethod.
It also precomputes the sig representation and the string representation
of the method.

				
				
			

			
				
				<h3 id="Method.IsConstant">func (Method) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=5393:5431#L149">IsConstant</a>
					<a class="permalink" href="index.html#Method.IsConstant">&#xb6;</a>
					
					
				</h3>
				<pre>func (method <a href="index.html#Method">Method</a>) IsConstant() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsConstant returns the indicator whether the method is read-only.

				
				
				
			
				
				<h3 id="Method.IsPayable">func (Method) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=5625:5662#L155">IsPayable</a>
					<a class="permalink" href="index.html#Method.IsPayable">&#xb6;</a>
					
					
				</h3>
				<pre>func (method <a href="index.html#Method">Method</a>) IsPayable() <a href="../../../../../builtin/index.html#bool">bool</a></pre>
				<p>IsPayable returns the indicator whether the method can process
plain ether transfers.

				
				
				
			
				
				<h3 id="Method.String">func (Method) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/method.go?s=5263:5299#L144">String</a>
					<a class="permalink" href="index.html#Method.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (method <a href="index.html#Method">Method</a>) String() <a href="../../../../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SelectorMarshaling">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/selector_parser.go?s=825:990#L13">SelectorMarshaling</a>
				<a class="permalink" href="index.html#SelectorMarshaling">&#xb6;</a>
				
				
			</h2>
			
			<pre>type SelectorMarshaling struct {
<span id="SelectorMarshaling.Name"></span>    Name   <a href="../../../../../builtin/index.html#string">string</a>               `json:&#34;name&#34;`
<span id="SelectorMarshaling.Type"></span>    Type   <a href="../../../../../builtin/index.html#string">string</a>               `json:&#34;type&#34;`
<span id="SelectorMarshaling.Inputs"></span>    Inputs []<a href="index.html#ArgumentMarshaling">ArgumentMarshaling</a> `json:&#34;inputs&#34;`
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ParseSelector">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/selector_parser.go?s=4982:5054#L141">ParseSelector</a>
					<a class="permalink" href="index.html#ParseSelector">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseSelector(unescapedSelector <a href="../../../../../builtin/index.html#string">string</a>) (<a href="index.html#SelectorMarshaling">SelectorMarshaling</a>, <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>ParseSelector converts a method selector into a struct that can be JSON encoded
and consumed by other functions in this package.
Note, although uppercase letters are not part of the ABI spec, this function
still accepts it as the general format is valid.

				
				
			

			
		
			
			
			<h2 id="Type">type <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/type.go?s=1176:1635#L40">Type</a>
				<a class="permalink" href="index.html#Type">&#xb6;</a>
				
				
			</h2>
			<p>Type is the reflection of the supported argument type.

			<pre>type Type struct {
<span id="Type.Elem"></span>    Elem *<a href="index.html#Type">Type</a>
<span id="Type.Size"></span>    Size <a href="../../../../../builtin/index.html#int">int</a>
<span id="Type.T"></span>    T    <a href="../../../../../builtin/index.html#byte">byte</a> <span class="comment">// Our own type checking</span>

    <span class="comment">// Tuple relative fields</span>
<span id="Type.TupleRawName"></span>    TupleRawName  <a href="../../../../../builtin/index.html#string">string</a>       <span class="comment">// Raw struct name defined in source code, may be empty.</span>
<span id="Type.TupleElems"></span>    TupleElems    []*<a href="index.html#Type">Type</a>      <span class="comment">// Type information of all tuple fields</span>
<span id="Type.TupleRawNames"></span>    TupleRawNames []<a href="../../../../../builtin/index.html#string">string</a>     <span class="comment">// Raw field name of all tuple fields</span>
<span id="Type.TupleType"></span>    TupleType     <a href="../../../../../reflect/index.html">reflect</a>.<a href="../../../../../reflect/index.html#Type">Type</a> <span class="comment">// Underlying struct of the tuple</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewType">func <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/type.go?s=1820:1918#L60">NewType</a>
					<a class="permalink" href="index.html#NewType">&#xb6;</a>
					
					
				</h3>
				<pre>func NewType(t <a href="../../../../../builtin/index.html#string">string</a>, internalType <a href="../../../../../builtin/index.html#string">string</a>, components []<a href="index.html#ArgumentMarshaling">ArgumentMarshaling</a>) (typ <a href="index.html#Type">Type</a>, err <a href="../../../../../builtin/index.html#error">error</a>)</pre>
				<p>NewType creates a new reflection type of abi type given in t.

				
				
			

			
				
				<h3 id="Type.GetType">func (Type) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/type.go?s=6400:6436#L217">GetType</a>
					<a class="permalink" href="index.html#Type.GetType">&#xb6;</a>
					
					
				</h3>
				<pre>func (t <a href="index.html#Type">Type</a>) GetType() <a href="../../../../../reflect/index.html">reflect</a>.<a href="../../../../../reflect/index.html#Type">Type</a></pre>
				<p>GetType returns the reflection type of the ABI type.

				
				
				
			
				
				<h3 id="Type.String">func (Type) <a href="http://localhost:6060/src/github.com/ethereum/go-ethereum/accounts/abi/type.go?s=7366:7401#L253">String</a>
					<a class="permalink" href="index.html#Type.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (t <a href="index.html#Type">Type</a>) String() (out <a href="../../../../../builtin/index.html#string">string</a>)</pre>
				<p>String implements Stringer.

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="bind/index.html">bind</a>
					</td>
				
					<td class="pkg-synopsis">
						Package bind generates Ethereum contract Go bindings.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="bind/backends/index.html">backends</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.19.10.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
